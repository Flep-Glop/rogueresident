==== START: app/page.tsx ====
'use client';
import { useEffect, useState } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import GameContainer from './components/GameContainer';
import JournalAcquisitionAnimation from './components/journal/JournalAcquisitionAnimation';
import PixelThemeProvider from './components/PixelThemeProvider';
import { useCoreInitialization } from './core/init';

/**
 * Vertical Slice Entry Point
 * 
 * Entry point for the Rogue Resident vertical slice. This component:
 * 1. Initializes core systems (event bus, state machine, progression resolver)
 * 2. Provides error boundary for crash resilience
 * 3. Wraps the game in necessary theme providers
 * 4. Handles journal acquisition animation
 */
export default function VerticalSlicePage() {
  // Initialize core systems
  const { initialized, reinitialize } = useCoreInitialization();
  
  // Track journal animation state
  const [journalAnimationCompleted, setJournalAnimationCompleted] = useState(false);
  
  // Make the reinitialize function available globally for emergency recovery
  useEffect(() => {
    if (typeof window !== 'undefined') {
      (window as any).__FORCE_REINITIALIZE__ = reinitialize;
    }
    
    console.log(`Core systems ${initialized ? 'are initialized' : 'initialization pending'}`);
    
    // Cleanup when component unmounts
    return () => {
      if (typeof window !== 'undefined') {
        delete (window as any).__FORCE_REINITIALIZE__;
      }
    };
  }, [initialized, reinitialize]);

  // Fallback UI for critical errors
  const ErrorFallback = ({ error, resetErrorBoundary }: { 
    error: Error, 
    resetErrorBoundary: () => void 
  }) => (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white p-6">
      <div className="max-w-lg">
        <h1 className="text-2xl font-bold mb-4 text-red-500">Game Error</h1>
        <div className="bg-gray-800 p-4 rounded mb-4 font-mono text-sm overflow-auto max-h-64">
          {error.message}
          {error.stack && (
            <pre className="mt-2 text-xs text-gray-400">
              {error.stack.split('\n').slice(0, 5).join('\n')}
            </pre>
          )}
        </div>
        <button 
          onClick={() => {
            // First reinitialize core systems
            reinitialize();
            console.log('Core systems reinitialized after error');
            // Then reset the error boundary
            resetErrorBoundary();
          }}
          className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded"
        >
          Try Again
        </button>
        <button 
          onClick={() => window.location.reload()}
          className="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded ml-2"
        >
          Reload Page
        </button>
      </div>
    </div>
  );

  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onReset={() => {
        // Core systems will be reinitialized in the ErrorFallback component
        console.log('Error boundary reset');
      }}
    >
      <div className="min-h-screen bg-black text-white">
        <GameContainer />
        {/* Journal acquisition animation overlay */}
        <JournalAcquisitionAnimation 
          onComplete={() => setJournalAnimationCompleted(true)} 
        />
      </div>
    </ErrorBoundary>
  );
}
==== END: app/page.tsx ====

==== START: app/components/PixelThemeProvider.tsx ====
// app/components/PixelThemeProvider.tsx
'use client';
import React from 'react';
import { motion } from 'framer-motion';

// Interface definitions remain the same...
interface PixelTextProps {
  children: React.ReactNode;
  className?: string;
  pixelated?: boolean;
}

interface PixelButtonProps {
  children: React.ReactNode;
  className?: string;
  onClick?: () => void;
  disabled?: boolean;
  variant?: 'default' | 'primary' | 'clinical' | 'qa' | 'educational' | 'success' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  icon?: React.ReactNode;
}

interface PixelBoxProps {
  children: React.ReactNode;
  className?: string;
  variant?: 'default' | 'dark' | 'light' | 'clinical' | 'qa' | 'educational';
  bordered?: boolean;
}


/**
 * PixelText - Typography component with pixel-perfect rendering
 * (This is the definitive version to be imported by other components)
 */
export function PixelText({
  children,
  className = '',
  pixelated = false
}: PixelTextProps) {
  return (
    <div
      className={`font-pixel ${pixelated ? 'text-rendering-pixelated' : ''} ${className}`}
      style={pixelated ? { imageRendering: 'pixelated' } : undefined}
    >
      {children}
    </div>
  );
} // [source: 18, 1244]

/**
 * PixelButton - Interactive component with consistent tactile feedback
 */
export function PixelButton({
  children,
  className = '',
  onClick,
  disabled = false,
  variant = 'default',
  size = 'md',
  icon
}: PixelButtonProps) {
  const variantClasses = {
    default: "bg-gray-800 border-gray-900 hover:bg-gray-700 text-white",
    primary: "bg-blue-700 border-blue-900 hover:bg-blue-600 text-white",
    clinical: "bg-clinical border-clinical-dark hover:bg-clinical-light text-white",
    qa: "bg-qa border-qa-dark hover:bg-qa-light text-white",
    educational: "bg-educational border-educational-dark hover:bg-educational-light text-white",
    success: "bg-green-700 border-green-900 hover:bg-green-600 text-white",
    danger: "bg-red-700 border-red-900 hover:bg-red-600 text-white"
  }; // [source: 19-20, 1245-1246]

  const sizeClasses = {
    sm: "px-2 py-1 text-xs",
    md: "px-4 py-2 text-sm",
    lg: "px-6 py-3 text-base"
  }; // [source: 20, 1246]

  return (
    <motion.button
      className={`
        font-pixel border-2 pixel-borders
        ${sizeClasses[size]}
        ${variantClasses[variant]}
        ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
        ${className}
      `}
      onClick={onClick}
      disabled={disabled}
      whileHover={disabled ? {} : { y: -2 }}
      whileTap={disabled ? {} : { y: 1 }} // [source: 21-22, 1247-1248]
      style={{ boxShadow: "inset 0 0 0 1px rgba(255,255,255,0.1)" }}
    >
      <div className="flex items-center justify-center">
        {icon && <span className="mr-2">{icon}</span>}
        {children}
      </div>
    </motion.button>
  );
} // [source: 19, 1245]

/**
 * PixelBox - Container with pixel-perfect borders
 */
export function PixelBox({
  children,
  className = '',
  variant = 'default',
  bordered = true
}: PixelBoxProps) {
  const variantClasses = {
    default: "bg-surface",
    dark: "bg-surface-dark",
    light: "bg-surface-light",
    clinical: "bg-clinical bg-opacity-10",
    qa: "bg-qa bg-opacity-10",
    educational: "bg-educational bg-opacity-10"
  }; // [source: 23, 1249]

  return (
    <div
      className={`
        ${variantClasses[variant]}
        ${bordered ? 'pixel-borders' : ''}
        ${className}
      `}
      style={bordered ? { boxShadow: "inset 0 0 0 1px rgba(255,255,255,0.1)" } : undefined}
    >
      {children}
    </div>
  );
} // [source: 23, 1249]

/**
 * PixelThemeProvider - Context provider for consistent theming
 */
export default function PixelThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <>
      {children}

      {/* Global pixel styles */}
      <style jsx global>{`
        /* Pixel rendering quality */
        .text-rendering-pixelated {
          text-rendering: optimizeSpeed;
          -webkit-font-smoothing: none;
        } // [source: 25, 1251]

        /* Custom pixel borders with inset highlight */
        .pixel-borders {
          position: relative;
          border: 2px solid #0f172a;
          box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
        } // [source: 26, 1252]


        .pixel-borders::after {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 1px;
          height: 1px;
          background-color: rgba(255,255,255,0.2);
        } // [source: 27, 1253]


        .pixel-borders-thin {
          position: relative;
          border: 1px solid #0f172a;
        } // [source: 28, 1254]

        /* Thicker borders for emphasis */
        .pixel-borders-lg {
          position: relative;
          border: 3px solid #0f172a; // [source: 29, 1255]
          box-shadow: 0 0 0 1px rgba(0,0,0,0.4); // [source: 29, 1255]
        } // [source: 28, 1254]

        .pixel-borders-lg::after {
          content: '';
          position: absolute; // [source: 31, 1257]
          top: 0;
          left: 0;
          width: 2px;
          height: 2px;
          background-color: rgba(255,255,255,0.2); // [source: 31, 1257]
        } // [source: 30, 1256]

        /* Glow effects */
        .pixel-glow {
          text-shadow: 0 0 4px currentColor; // [source: 32, 1258]
        } // [source: 32, 1258]

        /* Font size for tiny text */
        .text-2xs {
          font-size: 0.625rem; // [source: 33, 1259]
          line-height: 0.75rem; // [source: 34, 1260]
        }
      `}</style>
    </>
  );
} // [source: 25, 1251]
==== END: app/components/PixelThemeProvider.tsx ====

==== START: app/components/journal/Journal.tsx ====
// app/components/journal/Journal.tsx
'use client';
import { useState, useEffect } from 'react';
import { useJournalStore } from '@/app/store/journalStore'; // [source: 36, 1265]
import { useGameStore } from '@/app/store/gameStore'; // [source: 36, 1265]
import { useEventSubscription } from '@/app/core/events/CentralEventBus'; // [source: 36, 1265]
import { GameEventType } from '@/app/core/events/EventTypes'; // [source: 37, 1266]
import { PixelText } from '../PixelThemeProvider'; // *** ADDED IMPORT ***

// Define valid page types to ensure type safety across the UI
export type JournalPageType = 'knowledge' | 'characters' | 'notes' | 'references'; // [source: 37-38, 1266-1267]

// Simple placeholder components for the missing journal pages
const JournalKnowledgePage = () => (
  <div className="p-4">
    <h2 className="text-2xl mb-4">Knowledge</h2>
    <p className="text-gray-300">Knowledge entries will appear here as you discover them.</p>
  </div>
);
const JournalCharactersPage = () => ( // [source: 39, 1268]
  <div className="p-4">
    <h2 className="text-2xl mb-4">Characters</h2>
    <p className="text-gray-300">Character information will be recorded here.</p>
  </div>
);
const JournalNotesPage = () => ( // [source: 40, 1269]
  <div className="p-4">
    <h2 className="text-2xl mb-4">Notes</h2>
    <p className="text-gray-300">Your research notes will be collected here.</p>
  </div>
);
const JournalReferencesPage = () => ( // [source: 41, 1270]
  <div className="p-4">
    <h2 className="text-2xl mb-4">References</h2>
    <p className="text-gray-300">Reference materials will be cataloged here.</p>
  </div>
);

// *** REMOVED LOCAL PIXELTEXT DEFINITION *** [source: 42, 1271]

/**
 * Journal Component - Simplified for prototype
 */
export default function Journal() { // [source: 43, 1272]
  const {
    isOpen,
    currentPage,
    setCurrentPage,
    toggleJournal,
    currentUpgrade,
    hasJournal
  } = useJournalStore(); // [source: 43, 1272]
  const { gamePhase } = useGameStore(); // [source: 44, 1273]

  // Animation states
  const [isAnimating, setIsAnimating] = useState(false);
  const [showParticles, setShowParticles] = useState(false);
  const [showFloatingButton, setShowFloatingButton] = useState(false); // [source: 45, 1274]
  const [journalAnimating, setJournalAnimating] = useState(false); // [source: 45, 1274]

  // Listen for journal acquisition events
  useEventSubscription( // [source: 46, 1275]
    GameEventType.JOURNAL_ACQUIRED,
    (event) => {
      const payload = event.payload as any;
      if (payload) {
        // Show animation first
        setJournalAnimating(true);

        // Show floating button after animation completes
        setTimeout(() => {
          setJournalAnimating(false);
          setShowFloatingButton(true); // [source: 47, 1276]
        }, 3000);
      }
    },
    [] // [source: 47, 1276]
  );

  // Lock body when journal is open
  useEffect(() => { // [source: 48, 1277]
    if (isOpen) {
      // Store original overflow
      const originalOverflow = document.body.style.overflow;

      // Lock the background
      document.body.style.overflow = 'hidden';

      // Unlock when closing
      return () => {
        document.body.style.overflow = originalOverflow;
      };
    } // [source: 49, 1278]
  }, [isOpen]);

  // Handle open/close animations
  useEffect(() => {
    if (isOpen) {
      setIsAnimating(true);

      // After animation completes
      const timer = setTimeout(() => setIsAnimating(false), 300);
      return () => clearTimeout(timer);
    }
  }, [isOpen]);

  // Special effects during night phase
  useEffect(() => { // [source: 50, 1279]
    if (isOpen && gamePhase === 'night') {
      setShowParticles(true);

      const timer = setTimeout(() => setShowParticles(false), 5000);
      return () => clearTimeout(timer);
    }
  }, [isOpen, gamePhase]); // [source: 50, 1279]

  // Floating journal button when closed
  if (hasJournal && !isOpen && showFloatingButton) { // [source: 51, 1280]
    return (
      <div className="fixed bottom-4 right-4 z-50">
        <button
          className="px-4 py-2 bg-clinical text-white font-pixel hover:bg-clinical-light transition-colors shadow-lg animate-float"
          onClick={() => toggleJournal()}
        >
          Open Journal
        </button>
      </div> // [source: 52, 1281]
    );
  }

  // Don't render anything if player doesn't have journal or it's not open
  if (!hasJournal || !isOpen) return null; // [source: 52, 1281]

  // Determine journal cover style based on upgrade level
  const getJournalCoverStyle = () => { // [source: 53, 1282]
    switch(currentUpgrade) {
      case 'base': return 'bg-gradient-to-b from-amber-800 to-amber-900';
      case 'technical': return 'bg-gradient-to-b from-clinical-dark to-clinical'; // [source: 54, 1283]
      case 'annotated': return 'bg-gradient-to-b from-clinical-dark to-clinical-light'; // [source: 54, 1283]
      case 'indexed': return 'bg-gradient-to-b from-blue-900 to-blue-700'; // [source: 54, 1283]
      case 'integrated': return 'bg-gradient-to-b from-educational-dark to-educational'; // [source: 55, 1284]
      default: return 'bg-gradient-to-b from-amber-800 to-amber-900'; // [source: 55, 1284]
    }
  };

  return ( // [source: 56, 1285]
    <div
      className="fixed inset-0 flex items-center justify-center z-[9999] bg-black/70"
      onClick={(e) => {
        e.stopPropagation();
        toggleJournal();
      }}
      style={{ touchAction: 'none' }} // Prevent scroll on mobile
    >
      {/* Main journal container */}
      <div
        className={`
          journal-container // [source: 57, 1286]
          relative w-[900px] h-[650px]
          ${getJournalCoverStyle()}
          pixel-borders
          transform transition-all duration-300
          ${isAnimating ? 'scale-95 opacity-90' : 'scale-100 opacity-100'}
        `}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Journal cover decoration */}
        <div className="absolute inset-2 border border-amber-500/30 pointer-events-none"></div> {/* [source: 58, 1287] */}

        {/* Night phase knowledge transfer particles */}
        {showParticles && (
          <div className="absolute inset-0 overflow-hidden pointer-events-none z-50">
            <div className="absolute inset-0 bg-educational/10 animate-pulse"></div>
            <div className="absolute top-0 left-1/2 w-1 h-1 bg-educational rounded-full animate-ping"></div>
            <div className="absolute top-0 left-1/3 w-2 h-2 bg-clinical rounded-full animate-ping" style={{ animationDelay: '100ms' }}></div> {/* [source: 59, 1288] */}
            <div className="absolute top-0 right-1/4 w-1 h-1 bg-qa rounded-full animate-ping" style={{ animationDelay: '300ms' }}></div> {/* [source: 59, 1288] */}
            <div className="absolute top-0 left-2/3 w-2 h-2 bg-educational-light rounded-full animate-ping" style={{ animationDelay: '500ms' }}></div> {/* [source: 59, 1288] */}
            <div className="absolute top-0 right-1/3 w-1 h-1 bg-clinical-light rounded-full animate-ping" style={{ animationDelay: '700ms' }}></div> {/* [source: 59, 1288] */}
          </div> // [source: 60, 1289]
        )}

        {/* Close button */}
        <div
          role="button"
          tabIndex={0}
          className="absolute -top-4 -right-4 w-8 h-8 bg-surface pixel-borders-thin flex items-center justify-center hover:bg-clinical transition-colors z-[100] cursor-pointer"
          onClick={() => toggleJournal()}
          onKeyDown={(e) => { // [source: 61, 1290]
            if (e.key === 'Enter') {
              e.stopPropagation();
              toggleJournal(); // [source: 62, 1291]
            }
          }}
          aria-label="Close journal"
        >
          <span>✕</span>
        </div>

        {/* Journal content */}
        <div className="flex h-full journal-content relative z-10" onClick={(e) => e.stopPropagation()}>
          {/* Tabs sidebar with simplified buttons */}
          <div className="w-[200px] bg-surface-dark border-r border-border relative z-20"> {/* [source: 63, 1292] */}
            <div className="p-4">
              <PixelText className="text-xl mb-4 text-center">Journal</PixelText>

              <div className="space-y-2">
                {/* Tab buttons */}
                {['knowledge', 'characters', 'notes', 'references'].map((tabId) => ( // [source: 64, 1293]
                  <div
                    key={tabId}
                    className={`w-full cursor-pointer transition-colors relative z-30 ${currentPage === tabId ? 'bg-clinical text-white' : 'hover:bg-surface'}`}
                    role="button" // [source: 65, 1294]
                    tabIndex={0}
                    onClick={() => setCurrentPage(tabId as JournalPageType)} // [source: 65, 1294]
                  >
                    <div className="p-2">
                      <PixelText>{tabId.charAt(0).toUpperCase() + tabId.slice(1)}</PixelText> {/* [source: 66, 1295] */}
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* Journal quality indicator */}
            <div className="absolute bottom-4 left-4 w-[180px]"> {/* [source: 67, 1296] */}
              <div className="p-2 bg-surface-dark/70 text-center">
                <PixelText className="text-xs">
                  {currentUpgrade === 'base' && "Basic Notebook"}
                  {currentUpgrade === 'technical' && "Technical Journal"} {/* [source: 68, 1297] */}
                  {currentUpgrade === 'annotated' && "Annotated Journal"} {/* [source: 68, 1297] */}
                  {currentUpgrade === 'indexed' && "Indexed Compendium"} {/* [source: 68, 1297] */}
                  {currentUpgrade === 'integrated' && "Integrated Codex"} {/* [source: 68, 1297] */}
                </PixelText> {/* [source: 69, 1298] */}
              </div>
            </div>
          </div>

          {/* Journal pages */}
          <div
            className="flex-1 bg-surface overflow-y-auto p-6 relative z-20"
            onClick={(e) => e.stopPropagation()} // [source: 70, 1299]
          >
            {currentPage === 'knowledge' && <JournalKnowledgePage />}
            {currentPage === 'characters' && <JournalCharactersPage />}
            {currentPage === 'notes' && <JournalNotesPage />}
            {currentPage === 'references' && <JournalReferencesPage />}
          </div>
        </div>
      </div> {/* [source: 71, 1300] */}

      {/* CSS Animations (Keep these for now until consolidated) */}
      <style jsx>{`
        @keyframes pulse {
          0%, 100% { opacity: 1; } // [source: 71, 1300]
          50% { opacity: 0.7; } // [source: 72, 1301]
        }

        @keyframes ping {
          75%, 100% {
            transform: scale(2);
            opacity: 0; // [source: 74, 1303]
          }
        }

        @keyframes float {
          0%, 100% { transform: translateY(0); } // [source: 74, 1303]
          50% { transform: translateY(-5px); } // [source: 75, 1304]
        } // [source: 76, 1305]

        .animate-pulse {
          animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; // [source: 76, 1305]
        }

        .animate-ping {
          animation: ping 1.5s cubic-bezier(0, 0, 0.2, 1) infinite; // [source: 77, 1306]
        }

        .animate-float {
          animation: float 3s ease-in-out infinite; // [source: 78, 1307]
        }
      `}</style> {/* [source: 79, 1308] */}
    </div>
  );
} // [source: 80, 1309]
==== END: app/components/journal/Journal.tsx ====

==== START: app/components/journal/JournalAcquisitionAnimation.tsx ====
// app/components/journal/JournalAcquisitionAnimation.tsx
import React, { useEffect, useState } from 'react';
import { useJournalStore } from '../../store/journalStore';
import { useEventSubscription } from '../../core/events/CentralEventBus';
import { GameEventType } from '../../core/events/EventTypes';

interface JournalAcquisitionAnimationProps {
  onComplete?: () => void;
}

/**
 * JournalAcquisitionAnimation - Displays an animation when the player
 * acquires a journal, with a button to open it after acquisition
 */
export default function JournalAcquisitionAnimation({ 
  onComplete 
}: JournalAcquisitionAnimationProps) {
  // State for animation phases
  const [show, setShow] = useState(false);
  const [animationPhase, setAnimationPhase] = useState<'fadeIn' | 'display' | 'fadeOut'>('fadeIn');
  const [journalTier, setJournalTier] = useState<'base' | 'technical' | 'annotated'>('base');
  
  // Access journal store
  const { toggleJournal, hasJournal } = useJournalStore();
  
  // Listen for journal acquisition events
  useEventSubscription(
    GameEventType.JOURNAL_ACQUIRED,
    (event) => {
      const payload = event.payload as any;
      if (payload && payload.tier) {
        setJournalTier(payload.tier);
        setShow(true);
        setAnimationPhase('fadeIn');
        
        // Transition to display phase after fade in
        setTimeout(() => {
          setAnimationPhase('display');
        }, 1000);
      }
    },
    []
  );
  
  // Handle animation completion
  const handleClose = () => {
    setAnimationPhase('fadeOut');
    
    // Hide component after fade out
    setTimeout(() => {
      setShow(false);
      if (onComplete) {
        onComplete();
      }
    }, 1000);
  };
  
  // Handle journal open button
  const handleOpenJournal = () => {
    toggleJournal();
    handleClose();
  };
  
  // Don't render if not showing or if player doesn't have journal
  if (!show || !hasJournal) {
    return null;
  }
  
  return (
    <div 
      className={`fixed inset-0 flex items-center justify-center z-[1000] bg-black/80
        ${animationPhase === 'fadeIn' ? 'animate-fadeIn' : ''}
        ${animationPhase === 'fadeOut' ? 'animate-fadeOut' : ''}
      `}
    >
      <div className="max-w-md text-center">
        {/* Journal icon */}
        <div className="w-32 h-40 mx-auto mb-6 relative">
          <div 
            className={`w-full h-full ${
              journalTier === 'base' ? 'bg-amber-800' :
              journalTier === 'technical' ? 'bg-clinical' :
              'bg-clinical-light'
            } shadow-lg rounded-sm animate-float`}
          >
            <div className="absolute inset-2 border border-amber-500/30"></div>
            
            {/* Visual embellishments based on tier */}
            {journalTier === 'technical' && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-16 h-16 border-4 border-amber-500/50 rounded-full"></div>
              </div>
            )}
            
            {journalTier === 'annotated' && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-16 h-16 border-4 border-amber-500/50 rounded-full"></div>
                <div className="absolute inset-0 m-auto w-10 h-10 border-2 border-amber-300/70 transform rotate-45"></div>
              </div>
            )}
            
            {/* Particle effects */}
            <div className="absolute -inset-4 pointer-events-none">
              <div className="absolute top-0 left-1/2 w-1 h-1 bg-clinical rounded-full animate-particle1"></div>
              <div className="absolute top-0 left-1/3 w-2 h-2 bg-educational rounded-full animate-particle2"></div>
              <div className="absolute bottom-0 right-1/4 w-1 h-1 bg-qa rounded-full animate-particle3"></div>
            </div>
          </div>
        </div>
        
        {/* Title */}
        <h2 className="text-2xl font-pixel text-white mb-4 animate-glow">
          Journal Acquired!
        </h2>
        
        {/* Description based on tier */}
        <p className="text-gray-300 mb-6">
          {journalTier === 'base' && "You've received a basic notebook to record your observations."}
          {journalTier === 'technical' && "You've received a technical journal with specialized sections for medical physics notes."}
          {journalTier === 'annotated' && "You've received an annotated journal with expert guidance and reference sections!"}
        </p>
        
        {/* Buttons */}
        <div className="flex justify-center space-x-4">
          <button
            className="px-6 py-2 bg-clinical hover:bg-clinical-light text-white font-pixel transition-colors"
            onClick={handleOpenJournal}
          >
            Open Journal
          </button>
          
          <button
            className="px-6 py-2 bg-surface hover:bg-surface-dark text-white font-pixel transition-colors"
            onClick={handleClose}
          >
            Continue
          </button>
        </div>
      </div>
      
      {/* CSS for animations */}
      <style jsx>{`
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        
        @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
        }
        
        @keyframes float {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-10px); }
        }
        
        @keyframes glow {
          0%, 100% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
          50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8); }
        }
        
        @keyframes particle1 {
          0% { transform: translate(0, 0); opacity: 1; }
          100% { transform: translate(-20px, -50px); opacity: 0; }
        }
        
        @keyframes particle2 {
          0% { transform: translate(0, 0); opacity: 1; }
          100% { transform: translate(30px, -40px); opacity: 0; }
        }
        
        @keyframes particle3 {
          0% { transform: translate(0, 0); opacity: 1; }
          100% { transform: translate(-10px, 60px); opacity: 0; }
        }
        
        .animate-fadeIn {
          animation: fadeIn 1s forwards;
        }
        
        .animate-fadeOut {
          animation: fadeOut 1s forwards;
        }
        
        .animate-float {
          animation: float 3s ease-in-out infinite;
        }
        
        .animate-glow {
          animation: glow 2s ease-in-out infinite;
        }
        
        .animate-particle1 {
          animation: particle1 2s ease-out infinite;
        }
        
        .animate-particle2 {
          animation: particle2 2.5s ease-out infinite;
        }
        
        .animate-particle3 {
          animation: particle3 3s ease-out infinite;
        }
      `}</style>
    </div>
  );
}
==== END: app/components/journal/JournalAcquisitionAnimation.tsx ====

==== START: app/components/knowledge/ConstellationView.tsx ====
// app/components/knowledge/ConstellationView.tsx
'use client';
import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { useKnowledgeStore, ConceptNode, ConceptConnection, KNOWLEDGE_DOMAINS, KnowledgeDomain } from '../../store/knowledgeStore';
import { DOMAIN_COLORS, DOMAIN_COLORS_LIGHT } from '../../core/themeConstants'; // Import theme constants

// Import Drawing Utilities
import {
  drawStarryBackground,
  drawConnections,
  drawNodes,
  drawPendingConnection,
  drawParticles
} from './constellationCanvasUtils';

// Import Interaction Hook
import { useConstellationInteraction } from '../../hooks/useConstellationInteraction';

// Import UI Sub-components
import ConstellationInfoPanel from './ui/ConstellationInfoPanel';
import ConstellationLegend from './ui/ConstellationLegend';
import ConstellationControls from './ui/ConstellationControls';
import ConstellationActions from './ui/ConstellationActions';
import SelectedNodePanel from './ui/SelectedNodePanel';
import ConnectionSuggestionsPanel from './ui/ConnectionSuggestionsPanel';
import JournalOverlay from './ui/JournalOverlay';
import HelpOverlay from './ui/HelpOverlay';

// Re-export KNOWLEDGE_DOMAINS for consistency if needed elsewhere
export { KNOWLEDGE_DOMAINS };

// Helper type for particle effects (ensure consistency with utils)
type ParticleEffect = {
  id: string;
  x: number;
  y: number;
  targetX: number;
  targetY: number;
  color: string;
  size: number;
  life: number;
  maxLife: number;
  opacity?: number;
  velocity?: { x: number, y: number }
};

interface ConstellationViewProps {
  nightMode?: boolean;
  showLabels?: boolean;
  interactive?: boolean;
  width?: number;
  height?: number;
  onClose?: () => void;
  activeNodes?: string[]; // IDs of nodes to highlight (newly discovered/updated)
  fullscreen?: boolean; // Control fullscreen mode
  enableJournal?: boolean;
}

/**
 * ConstellationView - Refactored interactive knowledge visualization system.
 * Uses extracted utilities, hooks, and sub-components for better organization.
 */
export default function ConstellationView({
  onClose,
  width,
  height,
  interactive = true,
  enableJournal = true,
  activeNodes = [],
  fullscreen = true,
  nightMode = false,
  showLabels = true
}: ConstellationViewProps) {
  // CORE REFS
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const animationFrameRef = useRef<number | null>(null);
  const isComponentMountedRef = useRef(true); // Use ref for mount status

  // STORE ACCESS
  const nodes = useKnowledgeStore(useCallback(state => state.nodes, []));
  const connections = useKnowledgeStore(useCallback(state => state.connections, []));
  const totalMastery = useKnowledgeStore(useCallback(state => state.totalMastery, []));
  const domainMastery = useKnowledgeStore(useCallback(state => state.domainMastery, []));
  const newlyDiscovered = useKnowledgeStore(useCallback(state => state.newlyDiscovered, []));
  const journalEntries = useKnowledgeStore(useCallback(state => state.journalEntries, []));
  const resetNewlyDiscovered = useKnowledgeStore(useCallback(state => state.resetNewlyDiscovered, []));

  // STATE MANAGEMENT
  const [activeNode, setActiveNode] = useState<ConceptNode | null>(null);
  const [selectedNode, setSelectedNode] = useState<ConceptNode | null>(null);
  const [pendingConnection, setPendingConnection] = useState<string | null>(null);
  const [journalVisible, setJournalVisible] = useState(false);
  const [recentInsights, setRecentInsights] = useState<{conceptId: string, amount: number}[]>([]);
  const [showHelp, setShowHelp] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(0.8);
  const [cameraPosition, setCameraPosition] = useState({ x: 0, y: 0 });
  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });
  const [particleEffects, setParticleEffects] = useState<ParticleEffect[]>([]);

  // Use Interaction Hook
  const interactionHandlers = useConstellationInteraction({
    canvasRef,
    interactive,
    discoveredNodes: useMemo(() => nodes.filter(node => node.discovered), [nodes]), // Pass memoized nodes
    discoveredConnections: useMemo(() => connections.filter(conn => conn.discovered), [connections]), // Pass memoized connections
    zoomLevel,
    setZoomLevel,
    cameraPosition,
    setCameraPosition,
    activeNode,
    setActiveNode,
    selectedNode,
    setSelectedNode,
    pendingConnection,
    setPendingConnection,
    setParticleEffects,
    isComponentMountedRef,
  });

  // Initialize dimensions
  useEffect(() => {
    if (fullscreen) {
      const updateDimensions = () => {
        const containerWidth = containerRef.current?.parentElement?.clientWidth || window.innerWidth;
        const containerHeight = containerRef.current?.parentElement?.clientHeight || window.innerHeight;
        const padding = 24;
        setDimensions({
          width: Math.max(800, containerWidth - padding * 2),
          height: Math.max(600, containerHeight - padding * 2)
        });
      };
      updateDimensions();
      window.addEventListener('resize', updateDimensions);
      return () => window.removeEventListener('resize', updateDimensions);
    } else if (width && height) {
      setDimensions({ width, height });
    }
  }, [fullscreen, width, height]);

  // Memoize discovered data
  const discoveredNodes = useMemo(() => nodes.filter(node => node.discovered), [nodes]);
  const discoveredConnections = useMemo(() => connections.filter(conn => conn.discovered), [connections]);

  // Track component mount status
  useEffect(() => {
    isComponentMountedRef.current = true;
    return () => {
      isComponentMountedRef.current = false;
      if (animationFrameRef.current !== null) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, []);

  // Focus on active/newly discovered nodes and create particle effects
  useEffect(() => {
    if (!isComponentMountedRef.current || nodes.length === 0) return;

    const nodesToHighlight = [...activeNodes, ...newlyDiscovered];
    if (nodesToHighlight.length === 0) return;

    // Focus on the first highlighted node if none is selected
    if (!selectedNode) {
         const nodeToFocus = nodes.find(n => nodesToHighlight.includes(n.id));
         if (nodeToFocus) setSelectedNode(nodeToFocus);
    }


    const newParticles: ParticleEffect[] = [];
    nodesToHighlight.forEach(nodeId => {
      const node = nodes.find(n => n.id === nodeId);
      if (node?.position) {
        for (let i = 0; i < 15; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * 100 + 50;
          const color = DOMAIN_COLORS[node.domain] || DOMAIN_COLORS.general;
          newParticles.push({
            id: `particle-${nodeId}-${i}-${Date.now()}`,
            x: node.position.x + Math.cos(angle) * distance,
            y: node.position.y + Math.sin(angle) * distance,
            targetX: node.position.x,
            targetY: node.position.y,
            color: color,
            size: Math.random() * 3 + 1,
            life: 100,
            maxLife: 100
          });
        }
      }
    });

    if (newParticles.length > 0) {
      setParticleEffects(prev => [...prev, ...newParticles]);
       if (activeNodes.length > 0) { // Only play sound for externally activated nodes
           console.log('Would play success sound');
       }
    }
  }, [activeNodes, newlyDiscovered, nodes, selectedNode]); // Add selectedNode dependency


  // Track recent insights for Journal Overlay
  useEffect(() => {
    if (!isComponentMountedRef.current) return;
    if (journalEntries.length > 0) {
      const recent = journalEntries
        .sort((a, b) => b.timestamp - a.timestamp)
        .slice(0, 5)
        .map(entry => ({ conceptId: entry.conceptId, amount: entry.masteryGained }));
      setRecentInsights(recent);
    } else {
       // Placeholder if no entries
       setRecentInsights([
         { conceptId: 'electron-equilibrium', amount: 15 },
         { conceptId: 'radiation-safety', amount: 30 }
       ]);
    }
  }, [journalEntries]);

  // Particle Animation Loop
  useEffect(() => {
    if (!isComponentMountedRef.current || particleEffects.length === 0) return;

    let active = true;
    const animate = () => {
      if (!active || !isComponentMountedRef.current) return;
      let animating = false;
      setParticleEffects(prev => {
        if (!active) return prev;
        const updated = prev.map(p => {
          const dx = p.targetX - p.x;
          const dy = p.targetY - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 5) {
            animating = true;
            return { ...p, x: p.x + dx * 0.05, y: p.y + dy * 0.05, life: p.life - 1 };
          } else {
            return { ...p, life: p.life - 3 }; // Decay faster at target
          }
        }).filter(p => p.life > 0);
        return updated;
      });
      if (animating && active && isComponentMountedRef.current) {
        animationFrameRef.current = requestAnimationFrame(animate);
      } else {
        animationFrameRef.current = null;
      }
    };
    animationFrameRef.current = requestAnimationFrame(animate);
    return () => {
      active = false;
      if (animationFrameRef.current !== null) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [particleEffects.length]); // Re-run only if particle count changes

  // Main Canvas Drawing Loop
  useEffect(() => {
    if (!canvasRef.current || !isComponentMountedRef.current) return;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Apply transformations
    ctx.save();
    ctx.translate(canvas.width / 2 + cameraPosition.x, canvas.height / 2 + cameraPosition.y);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-canvas.width / 2, -canvas.height / 2);

    // Call drawing utilities
    drawStarryBackground(ctx, canvas.width, canvas.height);
    drawConnections(ctx, discoveredConnections, discoveredNodes, selectedNode, pendingConnection);
    drawNodes(ctx, discoveredNodes, activeNode, selectedNode, pendingConnection, activeNodes, newlyDiscovered, showLabels);
    drawPendingConnection(ctx, discoveredNodes, pendingConnection, activeNode);
    drawParticles(ctx, particleEffects);

    // Restore transformations
    ctx.restore();

  }, [
    discoveredNodes, discoveredConnections, activeNode, selectedNode, pendingConnection,
    activeNodes, newlyDiscovered, particleEffects, zoomLevel, cameraPosition, dimensions, showLabels // Add dimensions and showLabels
  ]);

  // Handle closing the view
  const handleClose = useCallback(() => {
    if (!isComponentMountedRef.current || !onClose) return;
    setSelectedNode(null);
    setActiveNode(null);
    setPendingConnection(null);
    resetNewlyDiscovered(); // Reset highlights on close
    onClose();
  }, [onClose, resetNewlyDiscovered]);

  return (
    <div
      ref={containerRef}
      className="relative bg-black pixel-borders"
      style={{
        width: dimensions.width,
        height: dimensions.height,
        maxWidth: '100%',
        maxHeight: '100%'
      }}
    >
      {/* Main Canvas */}
      <canvas
        ref={canvasRef}
        width={dimensions.width}
        height={dimensions.height}
        className="w-full h-full"
        // Attach interaction handlers from the hook
        onMouseMove={interactionHandlers.handleMouseMove}
        onClick={interactionHandlers.handleClick}
        onMouseDown={interactionHandlers.handleMouseDown}
        onMouseUp={interactionHandlers.handleMouseUp}
        onMouseLeave={interactionHandlers.handleMouseLeave}
        onWheel={interactionHandlers.handleWheel}
        onContextMenu={(e) => e.preventDefault()}
      />

      {/* Render UI Sub-components */}
      <ConstellationInfoPanel
        discoveredNodes={discoveredNodes}
        totalNodes={nodes.length}
        discoveredConnections={discoveredConnections}
        totalMastery={totalMastery}
      />

      <ConstellationLegend domainMastery={domainMastery} />

      <ConstellationControls
        zoomLevel={zoomLevel}
        setZoomLevel={setZoomLevel}
        setCameraPosition={setCameraPosition}
      />

      <ConstellationActions
        enableJournal={enableJournal}
        setJournalVisible={setJournalVisible}
        setShowHelp={setShowHelp}
        onClose={handleClose} // Use the wrapped handleClose
      />

      <SelectedNodePanel
        selectedNode={selectedNode}
        discoveredNodes={discoveredNodes}
        pendingConnection={pendingConnection}
        setPendingConnection={setPendingConnection}
      />

      {interactive && selectedNode && (
         <ConnectionSuggestionsPanel
           selectedNode={selectedNode}
           discoveredNodes={discoveredNodes}
           discoveredConnections={discoveredConnections}
           setPendingConnection={setPendingConnection}
         />
       )}


      {/* Render Overlays */}
      <JournalOverlay
        journalVisible={journalVisible}
        setJournalVisible={setJournalVisible}
        discoveredNodes={discoveredNodes}
        recentInsights={recentInsights}
      />

      <HelpOverlay
        showHelp={showHelp}
        setShowHelp={setShowHelp}
      />
    </div>
  );
}

==== END: app/components/knowledge/ConstellationView.tsx ====

==== START: app/components/knowledge/ui/ConstellationActions.tsx ====
// app/components/knowledge/ui/ConstellationActions.tsx
import React from 'react';
import { PixelButton } from '../../PixelThemeProvider';

interface ConstellationActionsProps {
  enableJournal: boolean;
  setJournalVisible: React.Dispatch<React.SetStateAction<boolean>>;
  setShowHelp: React.Dispatch<React.SetStateAction<boolean>>;
  onClose?: () => void;
}

/**
 * Provides main action buttons like Journal, Help, and Close.
 */
export const ConstellationActions: React.FC<ConstellationActionsProps> = ({
  enableJournal,
  setJournalVisible,
  setShowHelp,
  onClose,
}) => {
  return (
    <div className="absolute bottom-4 right-4 flex space-x-3 z-10">
      {/* Journal Button (conditional) */}
      {enableJournal && (
        <PixelButton
          className="bg-surface hover:bg-surface-dark text-text-primary"
          onClick={() => setJournalVisible(true)}
        >
          Journal
        </PixelButton>
      )}
      {/* Help Button */}
      <PixelButton
        className="bg-surface hover:bg-surface-dark text-text-primary"
        onClick={() => setShowHelp(true)}
      >
        Help
      </PixelButton>
      {/* Close Button (conditional) */}
      {onClose && (
        <PixelButton
          className="bg-surface hover:bg-danger text-text-primary"
          onClick={onClose}
        >
          Close
        </PixelButton>
      )}
    </div>
  );
};

export default ConstellationActions;

==== END: app/components/knowledge/ui/ConstellationActions.tsx ====

==== START: app/components/knowledge/ui/ConstellationControls.tsx ====
// app/components/knowledge/ui/ConstellationControls.tsx
import React from 'react';
import { PixelButton } from '../../PixelThemeProvider';

interface ConstellationControlsProps {
  zoomLevel: number;
  setZoomLevel: React.Dispatch<React.SetStateAction<number>>;
  setCameraPosition: React.Dispatch<React.SetStateAction<{ x: number; y: number }>>;
}

/**
 * Provides zoom and reset controls for the constellation view.
 */
export const ConstellationControls: React.FC<ConstellationControlsProps> = ({
  zoomLevel,
  setZoomLevel,
  setCameraPosition,
}) => {
  return (
    <div className="absolute bottom-20 right-4 flex flex-col space-y-2 z-10">
      {/* Zoom In Button */}
      <PixelButton
        className="w-8 h-8 flex items-center justify-center bg-surface-dark"
        onClick={() => setZoomLevel(prev => Math.min(2, prev + 0.1))}
        aria-label="Zoom In"
      >
        +
      </PixelButton>
      {/* Zoom Out Button */}
      <PixelButton
        className="w-8 h-8 flex items-center justify-center bg-surface-dark"
        onClick={() => setZoomLevel(prev => Math.max(0.5, prev - 0.1))}
        aria-label="Zoom Out"
      >
        -
      </PixelButton>
      {/* Reset View Button */}
      <PixelButton
        className="w-8 h-8 flex items-center justify-center bg-surface-dark"
        onClick={() => {
          setZoomLevel(0.8); // Reset to initial zoom
          setCameraPosition({ x: 0, y: 0 }); // Reset camera position
        }}
        aria-label="Reset View"
      >
        ↺
      </PixelButton>
    </div>
  );
};

export default ConstellationControls;

==== END: app/components/knowledge/ui/ConstellationControls.tsx ====

==== START: app/components/knowledge/ui/ConstellationInfoPanel.tsx ====
// app/components/knowledge/ui/ConstellationInfoPanel.tsx
import React from 'react';
import { PixelText } from '../../PixelThemeProvider';
import { ConceptNode, ConceptConnection } from '../../../store/knowledgeStore';

interface ConstellationInfoPanelProps {
  discoveredNodes: ConceptNode[];
  totalNodes: number;
  discoveredConnections: ConceptConnection[];
  totalMastery: number;
}

/**
 * Displays overview information about the constellation.
 */
export const ConstellationInfoPanel: React.FC<ConstellationInfoPanelProps> = ({
  discoveredNodes,
  totalNodes,
  discoveredConnections,
  totalMastery,
}) => {
  return (
    <div className="absolute top-4 left-4 z-10">
      <div className="bg-surface-dark/80 p-3 pixel-borders-thin text-sm">
        <PixelText className="text-text-primary mb-1">Knowledge Constellation</PixelText>
        <div className="text-text-secondary">
          {/* Display count of discovered nodes vs total nodes */}
          <div>Discovered: {discoveredNodes.length}/{totalNodes}</div>
          {/* Display count of discovered connections */}
          <div>Connections: {discoveredConnections.length}</div>
          {/* Display total mastery percentage */}
          <div>Mastery: {totalMastery}%</div>
        </div>
      </div>
    </div>
  );
};

export default ConstellationInfoPanel;

==== END: app/components/knowledge/ui/ConstellationInfoPanel.tsx ====

==== START: app/components/knowledge/ui/ConstellationLegend.tsx ====
// app/components/knowledge/ui/ConstellationLegend.tsx
import React from 'react';
import { PixelText } from '../../PixelThemeProvider';
import { KnowledgeDomain, KNOWLEDGE_DOMAINS } from '../../../store/knowledgeStore';
import { DOMAIN_COLORS } from '../../../core/themeConstants';

interface ConstellationLegendProps {
  domainMastery: Record<KnowledgeDomain, number>;
}

/**
 * Displays the legend for knowledge domains and their mastery.
 */
export const ConstellationLegend: React.FC<ConstellationLegendProps> = ({ domainMastery }) => {
  return (
    <div className="absolute bottom-4 left-4 bg-surface-dark/80 p-3 pixel-borders-thin z-10">
      <PixelText className="text-text-primary mb-2">Knowledge Domains</PixelText>
      <div className="space-y-1 text-sm">
        {/* Map through domain mastery entries */}
        {Object.entries(domainMastery)
          // Filter out domains with 0 mastery
          .filter(([_, mastery]) => mastery > 0)
          .map(([key, mastery]) => {
            const domain = KNOWLEDGE_DOMAINS[key as KnowledgeDomain];
            // Skip if domain info is missing
            if (!domain) return null;

            return (
              <div key={key} className="flex items-center">
                {/* Domain color indicator */}
                <div
                  className="w-3 h-3 mr-2"
                  style={{ backgroundColor: DOMAIN_COLORS[key as KnowledgeDomain] }}
                ></div>
                {/* Domain name and mastery percentage */}
                <PixelText className="text-sm">{domain.name}: {mastery}%</PixelText>
              </div>
            );
          })}
      </div>
    </div>
  );
};

export default ConstellationLegend;

==== END: app/components/knowledge/ui/ConstellationLegend.tsx ====

==== START: app/components/knowledge/ui/ConnectionSuggestionsPanel.tsx ====
// app/components/knowledge/ui/ConnectionSuggestionsPanel.tsx
import React from 'react';
import { PixelText } from '../../PixelThemeProvider';
import { ConceptNode, ConceptConnection, KnowledgeDomain, useKnowledgeStore } from '../../../store/knowledgeStore';
import { DOMAIN_COLORS } from '../../../core/themeConstants';

interface ConnectionSuggestionsPanelProps {
  selectedNode: ConceptNode | null;
  discoveredNodes: ConceptNode[];
  discoveredConnections: ConceptConnection[];
  setPendingConnection: React.Dispatch<React.SetStateAction<string | null>>;
}

/**
 * Displays suggested connections for the selected node.
 */
export const ConnectionSuggestionsPanel: React.FC<ConnectionSuggestionsPanelProps> = ({
  selectedNode,
  discoveredNodes,
  discoveredConnections,
  setPendingConnection,
}) => {
  if (!selectedNode) return null;

  // Zustand actions
  const createConnection = useKnowledgeStore(state => state.createConnection);
  const updateMastery = useKnowledgeStore(state => state.updateMastery);

  // Find possible connections
  const possibleConnections = discoveredNodes.filter(node =>
    // Must be a different node than selected
    node.id !== selectedNode.id &&
    // Must not already be connected
    !discoveredConnections.some(conn =>
      (conn.source === selectedNode.id && conn.target === node.id) ||
      (conn.target === selectedNode.id && conn.source === node.id)
    )
  );

  // If no suggestions, don't render anything
  if (possibleConnections.length === 0) return null;

  // Take up to 3 suggestions
  const suggestions = possibleConnections.slice(0, 3);

  const handleSuggestionClick = (targetNode: ConceptNode) => {
    if (!selectedNode) return;

    // Start the connection process visually
    setPendingConnection(selectedNode.id);

    // Use setTimeout to allow UI update before creating connection
    setTimeout(() => {
      try {
        // Create the connection in the store
        createConnection(selectedNode.id, targetNode.id);

        // Boost mastery slightly for both nodes
        updateMastery(selectedNode.id, 3);
        updateMastery(targetNode.id, 3);

        console.log('Would play connection success sound');

        // Reset pending connection state after successful creation
        setPendingConnection(null);
      } catch (error) {
        console.error("Error creating connection from suggestion:", error);
        setPendingConnection(null); // Reset even on error
      }
    }, 50); // Short delay
  };

  return (
    <div className="absolute top-4 right-4 w-64 z-10">
      <div className="bg-surface-dark/80 p-3 pixel-borders-thin">
        <PixelText className="text-text-primary mb-2">Suggested Connections</PixelText>
        <div className="space-y-2">
          {suggestions.map(node => (
            <div
              key={node.id}
              className="bg-surface p-2 hover:bg-surface-dark cursor-pointer pixel-borders-thin"
              onClick={() => handleSuggestionClick(node)}
              role="button"
              tabIndex={0}
              onKeyDown={(e) => e.key === 'Enter' && handleSuggestionClick(node)}
            >
              <div className="flex items-center">
                {/* Domain color indicator */}
                <div
                  className="w-2 h-2 rounded-full mr-2 flex-shrink-0"
                  style={{ backgroundColor: DOMAIN_COLORS[node.domain] }}
                ></div>
                {/* Node name */}
                <PixelText className="text-sm text-text-primary truncate">{node.name}</PixelText>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default ConnectionSuggestionsPanel;

==== END: app/components/knowledge/ui/ConnectionSuggestionsPanel.tsx ====

==== START: app/components/knowledge/ui/SelectedNodePanel.tsx ====
// app/components/knowledge/ui/SelectedNodePanel.tsx
import React from 'react';
import { PixelText, PixelButton } from '../../PixelThemeProvider';
import { ConceptNode, KnowledgeDomain, KNOWLEDGE_DOMAINS } from '../../../store/knowledgeStore';
import { DOMAIN_COLORS } from '../../../core/themeConstants';

interface SelectedNodePanelProps {
  selectedNode: ConceptNode | null;
  discoveredNodes: ConceptNode[]; // Needed to count connections
  pendingConnection: string | null;
  setPendingConnection: React.Dispatch<React.SetStateAction<string | null>>;
}

/**
 * Displays details for the currently selected concept node.
 */
export const SelectedNodePanel: React.FC<SelectedNodePanelProps> = ({
  selectedNode,
  discoveredNodes,
  pendingConnection,
  setPendingConnection,
}) => {
  if (!selectedNode) return null;

  const domainInfo = KNOWLEDGE_DOMAINS[selectedNode.domain];
  const domainColor = DOMAIN_COLORS[selectedNode.domain];

  // Calculate number of *discovered* connections for the selected node
  const connectionCount = selectedNode.connections.filter(targetId =>
    discoveredNodes.some(node => node.id === targetId && node.discovered)
  ).length;

  return (
    <div className="absolute top-1/2 right-4 transform -translate-y-1/2 max-w-xs bg-surface-dark/90 p-3 pixel-borders z-10">
      {/* Header section with node name, domain, and mastery */}
      <div className="flex justify-between items-start mb-2">
        <div>
          <div className="flex items-center mb-1">
            {/* Domain color indicator */}
            <div
              className="w-3 h-3 mr-2 flex-shrink-0"
              style={{ backgroundColor: domainColor }}
            ></div>
            {/* Node Name */}
            <PixelText className="text-lg font-medium text-white">
              {selectedNode.name}
            </PixelText>
          </div>
          {/* Domain Name */}
          <PixelText className="text-sm text-text-secondary">
            {domainInfo?.name || 'Unknown Domain'}
          </PixelText>
        </div>
        {/* Mastery Display */}
        <div className="bg-surface px-2 py-1 text-sm ml-2 flex-shrink-0">
          <PixelText className="text-text-secondary">Mastery:</PixelText>
          <PixelText className="text-white">{selectedNode.mastery}%</PixelText>
        </div>
      </div>

      {/* Node Description */}
      <PixelText className="text-sm mb-3 text-text-primary">{selectedNode.description}</PixelText>

      {/* Connection Info and Button */}
      <div className="flex justify-between items-center mt-2">
        {/* Connection Status Text */}
        <PixelText className="text-text-secondary text-xs">
          {pendingConnection === selectedNode.id
            ? 'Click another node to connect'
            : `Connections: ${connectionCount}`}
        </PixelText>

        {/* Connect Button (shown only if not currently starting a connection from this node) */}
        {!pendingConnection && (
          <PixelButton
            size="sm" // Smaller button for this context
            className="text-xs py-1 bg-blue-600 text-white"
            onClick={() => setPendingConnection(selectedNode.id)}
          >
            Connect
          </PixelButton>
        )}
        {/* Cancel Button (shown only if starting a connection from this node) */}
         {pendingConnection === selectedNode.id && (
           <PixelButton
             size="sm"
             className="text-xs py-1 bg-red-700 text-white"
             onClick={() => setPendingConnection(null)}
           >
             Cancel
           </PixelButton>
         )}
      </div>
    </div>
  );
};

export default SelectedNodePanel;

==== END: app/components/knowledge/ui/SelectedNodePanel.tsx ====

==== START: app/components/knowledge/ui/JournalOverlay.tsx ====
// app/components/knowledge/ui/JournalOverlay.tsx
import React from 'react';
import { PixelText, PixelButton } from '../../PixelThemeProvider';
import { ConceptNode, KnowledgeDomain, KNOWLEDGE_DOMAINS } from '../../../store/knowledgeStore';
import { DOMAIN_COLORS } from '../../../core/themeConstants';

interface JournalOverlayProps {
  journalVisible: boolean;
  setJournalVisible: React.Dispatch<React.SetStateAction<boolean>>;
  discoveredNodes: ConceptNode[]; // Needed to find node details
  recentInsights: Array<{ conceptId: string, amount: number }>;
}

/**
 * Displays the Research Journal overlay.
 */
export const JournalOverlay: React.FC<JournalOverlayProps> = ({
  journalVisible,
  setJournalVisible,
  discoveredNodes,
  recentInsights,
}) => {
  if (!journalVisible) return null;

  return (
    <div className="absolute inset-0 bg-black/90 z-20 flex items-center justify-center p-4">
      <div className="bg-surface p-6 max-w-md w-full pixel-borders">
        {/* Overlay Header */}
        <div className="flex justify-between items-center mb-4">
          <PixelText className="text-2xl text-white">Research Journal</PixelText>
          <PixelButton
            className="bg-red-600 hover:bg-red-500 text-white"
            onClick={() => setJournalVisible(false)}
            size="sm"
          >
            Close
          </PixelButton>
        </div>

        {/* Recent Insights Section */}
        <div className="mb-4">
          <PixelText className="mb-2 text-text-primary">Recent Insights</PixelText>
          <div className="space-y-2 max-h-60 overflow-y-auto pr-2">
            {recentInsights.length > 0 ? recentInsights.map((insight, index) => {
              // Find the corresponding node details
              const node = discoveredNodes.find(n => n.id === insight.conceptId);
              if (!node) return null; // Skip if node not found (shouldn't happen ideally)

              const domainInfo = KNOWLEDGE_DOMAINS[node.domain];
              const domainColor = DOMAIN_COLORS[node.domain];

              return (
                <div
                  key={`insight-${index}-${insight.conceptId}`}
                  className="p-3 pixel-borders-thin bg-surface-dark"
                >
                  <div className="flex justify-between items-start">
                    {/* Node Name and Domain Indicator */}
                    <div className="flex items-center mr-2">
                      <div
                        className="w-3 h-3 mr-2 flex-shrink-0"
                        style={{ backgroundColor: domainColor }}
                      ></div>
                      <PixelText className="text-white truncate">{node.name}</PixelText>
                    </div>
                    {/* Insight Amount */}
                    <div className="bg-surface px-2 py-0.5 text-sm flex-shrink-0">
                      <PixelText className="text-green-400">+{insight.amount}%</PixelText>
                    </div>
                  </div>
                  {/* Domain Name */}
                  <PixelText className="text-sm text-text-secondary mt-1">
                    {domainInfo?.name || 'Unknown Domain'}
                  </PixelText>
                </div>
              );
            }) : (
              <PixelText className="text-text-secondary italic text-sm">No recent insights recorded.</PixelText>
            )}
          </div>
        </div>

        {/* Explanatory Text */}
        <div className="p-3 bg-surface-dark pixel-borders-thin">
          <PixelText className="text-text-secondary text-sm italic">
            As you learn and apply knowledge through challenges, your insights will be recorded here, then transferred to your constellation during the night phase.
          </PixelText>
        </div>
      </div>
    </div>
  );
};

export default JournalOverlay;

==== END: app/components/knowledge/ui/JournalOverlay.tsx ====

==== START: app/components/knowledge/ui/HelpOverlay.tsx ====
// app/components/knowledge/ui/HelpOverlay.tsx
import React from 'react';
import { PixelText, PixelButton } from '../../PixelThemeProvider';
import { DOMAIN_COLORS } from '../../../core/themeConstants'; // Import colors for themed text

interface HelpOverlayProps {
  showHelp: boolean;
  setShowHelp: React.Dispatch<React.SetStateAction<boolean>>;
}

/**
 * Displays the Help overlay for the constellation view.
 */
export const HelpOverlay: React.FC<HelpOverlayProps> = ({ showHelp, setShowHelp }) => {
  if (!showHelp) return null;

  return (
    <div className="absolute inset-0 bg-black/90 z-20 flex items-center justify-center p-4">
      <div className="bg-surface p-6 max-w-lg w-full pixel-borders max-h-[90vh] overflow-y-auto">
        {/* Overlay Header */}
        <div className="flex justify-between items-center mb-4">
          <PixelText className="text-2xl text-white">Constellation Help</PixelText>
          <PixelButton
            className="bg-red-600 hover:bg-red-500 text-white"
            onClick={() => setShowHelp(false)}
            size="sm"
          >
            Close
          </PixelButton>
        </div>

        {/* Help Content Sections */}
        <div className="space-y-4 mb-4">
          {/* Viewing Knowledge Section */}
          <div>
            <PixelText className="mb-1 font-medium" style={{ color: DOMAIN_COLORS.theoretical }}>Viewing Knowledge</PixelText>
            <PixelText className="text-sm text-text-secondary">
              Your constellation represents your knowledge in different domains of medical physics.
              Each star is a concept you've learned, with brighter stars indicating higher mastery. Connections show relationships between concepts.
            </PixelText>
          </div>

          {/* Creating Connections Section */}
          <div>
            <PixelText className="mb-1 font-medium" style={{ color: DOMAIN_COLORS.theoretical }}>Creating Connections</PixelText>
            <PixelText className="text-sm text-text-secondary">
              1. Click on a concept star to select it.
            </PixelText>
            <PixelText className="text-sm text-text-secondary">
              2. Click the "Connect" button in the details panel (or click the selected star again).
            </PixelText>
            <PixelText className="text-sm text-text-secondary">
              3. Click another concept star to form the connection.
            </PixelText>
            <PixelText className="text-sm text-text-secondary mt-1">
              Connecting related concepts deepens your understanding and grants additional insight points.
            </PixelText>
          </div>

          {/* Knowledge Application Section */}
          <div>
            <PixelText className="mb-1 font-medium" style={{ color: DOMAIN_COLORS.theoretical }}>Knowledge Application</PixelText>
            <PixelText className="text-sm text-text-secondary">
              Your knowledge constellation unlocks new dialogue options and challenge approaches during gameplay.
              Higher mastery in relevant domains improves your performance in challenges and interactions.
            </PixelText>
          </div>

          {/* Navigation Controls Section */}
          <div>
            <PixelText className="mb-1 font-medium" style={{ color: DOMAIN_COLORS.theoretical }}>Navigation Controls</PixelText>
            <PixelText className="text-sm text-text-secondary">
              • Click and drag anywhere on the background to pan the view.
            </PixelText>
             <PixelText className="text-sm text-text-secondary">
              • Use the mouse wheel to zoom in and out.
            </PixelText>
             <PixelText className="text-sm text-text-secondary">
              • Right-click and drag also works for panning.
            </PixelText>
             <PixelText className="text-sm text-text-secondary">
              • Use the +/- buttons (bottom right) to adjust zoom level.
            </PixelText>
             <PixelText className="text-sm text-text-secondary">
              • Click the ↺ button to reset zoom and position.
            </PixelText>
          </div>
        </div>

        {/* Pro Tip Section */}
        <div className="p-3 bg-surface-dark pixel-borders-thin">
          <PixelText className="mb-1 font-medium" style={{ color: DOMAIN_COLORS['clinical-practice'] }}>Pro Tip</PixelText>
          <PixelText className="text-sm text-text-secondary">
            The most powerful insights often come from connecting concepts across different knowledge domains.
            Try linking clinical knowledge with radiation physics principles!
          </PixelText>
        </div>
      </div>
    </div>
  );
};

export default HelpOverlay;

==== END: app/components/knowledge/ui/HelpOverlay.tsx ====

==== START: app/components/knowledge/KnowledgeUpdate.tsx ====
// app/components/knowledge/KnowledgeUpdate.tsx
'use client';
import { useState, useEffect } from 'react';
import { PixelText } from '../PixelThemeProvider'; // *** ADDED IMPORT ***

// *** REMOVED LOCAL PIXELTEXT DEFINITION *** [source: 347, 1573]

interface KnowledgeUpdateProps { // [source: 348, 1577]
  conceptName: string;
  domainName: string;
  domainColor: string;
  gainAmount: number;
  onComplete?: () => void; // [source: 348, 1577]
}

/**
 * Knowledge Update - Notification component for knowledge gains
 * Simplified version without sound effects
 */
export default function KnowledgeUpdate({
  conceptName,
  domainName,
  domainColor,
  gainAmount,
  onComplete
}: KnowledgeUpdateProps) {
  const [visible, setVisible] = useState(true);
  const [animationStage, setAnimationStage] = useState<'enter' | 'active' | 'exit'>('enter'); // [source: 350, 1579]

  // Animation sequence
  useEffect(() => {
    // Animation sequence
    const enterTimer = setTimeout(() => {
      setAnimationStage('active');
    }, 500);

    const activeTimer = setTimeout(() => {
      setAnimationStage('exit');
    }, 2500);

    const exitTimer = setTimeout(() => {
      setVisible(false);
      if (onComplete) onComplete();
    }, 3000);

    return () => { // [source: 351, 1580]
      clearTimeout(enterTimer);
      clearTimeout(activeTimer);
      clearTimeout(exitTimer);
    };
  }, [gainAmount, onComplete]); // [source: 351, 1580]

  if (!visible) return null; // [source: 352, 1581]

  // Style based on gain amount
  const getGainStyle = () => {
    if (gainAmount >= 20) {
      return 'text-2xl font-bold'; // [source: 352, 1581]
    } else if (gainAmount >= 10) { // [source: 353, 1582]
      return 'text-xl'; // [source: 353, 1582]
    } else {
      return 'text-lg'; // [source: 354, 1583]
    }
  };

  // Get animation classes based on stage
  const getAnimationClass = () => { // [source: 355, 1584]
    switch (animationStage) {
      case 'enter':
        return 'opacity-0 scale-95 translate-y-4'; // [source: 355, 1584]
      case 'active': // [source: 356, 1585]
        return 'opacity-100 scale-100 translate-y-0'; // [source: 356, 1585]
      case 'exit': // [source: 357, 1586]
        return 'opacity-0 scale-105 -translate-y-4'; // [source: 357, 1586]
    }
  };

  return ( // [source: 358, 1587]
    <div
      className={`
        fixed top-1/4 left-1/2 transform -translate-x-1/2
        z-50 pointer-events-none
        transition-all duration-500 ease-in-out
        ${getAnimationClass()}
      `}
    >
      <div
        className="bg-surface/90 backdrop-blur-sm pixel-borders p-4 min-w-[300px] max-w-[400px]"
        style={{ borderColor: domainColor }}
      >
        <div className="text-center mb-2"> {/* [source: 359, 1588] */}
          <PixelText className="text-educational-light">Knowledge Updated</PixelText>
        </div>

        <div className="flex items-center justify-between mb-3">
          <div>
            <PixelText className="text-md font-medium">{conceptName}</PixelText>
            <PixelText className="text-sm text-text-secondary">{domainName}</PixelText>
          </div>

          <div // [source: 360, 1589]
            className={`${getGainStyle()} font-pixel`}
            style={{ color: domainColor }}
          >
            +{gainAmount}%
          </div>
        </div>

        {/* Progress visualization */} {/* [source: 361, 1590] */}
        <div className="w-full h-2 bg-surface-dark">
          <div
            className="h-full"
            style={{
              width: `${gainAmount}%`,
              backgroundColor: domainColor,
              transition: 'width 1s ease-in-out' // [source: 361, 1590]
            }} // [source: 362, 1591]
          ></div>
        </div>

        {/* Insight bonus for significant gains */}
        {gainAmount >= 15 && (
          <div className="mt-2 text-center">
            <PixelText className="text-sm text-clinical-light">+{Math.floor(gainAmount / 5)} Insight Bonus</PixelText>
          </div> // [source: 363, 1592]
        )}

        {/* Special indicator for major knowledge updates */}
        {gainAmount >= 25 && (
          <div className="absolute -top-2 -right-2 w-6 h-6 bg-educational rounded-full flex items-center justify-center text-white text-xs">
            ⭐
          </div>
        )}
      </div> {/* [source: 364, 1593] */}
    </div>
  );
}
==== END: app/components/knowledge/KnowledgeUpdate.tsx ====

==== START: app/components/gameplay/MomentumCounter.tsx ====
// app/components/gameplay/MomentumCounter.tsx
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useResourceStore, MAX_MOMENTUM_LEVEL } from '../../store/resourceStore';

interface MomentumCounterProps {
  showLabel?: boolean;
  className?: string;
  compact?: boolean;
  level?: number;
  // Optional override for displaying specific level
  consecutiveCorrect?: number;
  // Optional consecutive counter
}

/**
 * Momentum Counter Component - Enhanced with Juice!
 *
 * Visual representation of player's momentum level, inspired by resource
 * meters in roguelites like Hades.
 * Shows pips that fill up as the player
 * builds momentum with correct answers.
 */
export default function MomentumCounter({
  showLabel = true,
  className = '',
  compact = false,
  level: overrideLevel,
  consecutiveCorrect: overrideConsecutive
}: MomentumCounterProps) {
  // Get resource state, but allow override
  const {
    momentum: storeMomentum,
    consecutiveCorrect: storeConsecutive,
    momentumEffect
  } = useResourceStore();
  // Use override if provided, otherwise use store value
  const momentum = overrideLevel !== undefined ? overrideLevel : storeMomentum;
  const consecutiveCorrect = overrideConsecutive !== undefined ? overrideConsecutive : storeConsecutive;

  // Animation state
  const [pulseEffect, setPulseEffect] = useState(false);
  // **NEW**: State to track momentum changes for animation
  const [momentumChanged, setMomentumChanged] = useState<'gain' | 'loss' | null>(null);
  const [prevMomentum, setPrevMomentum] = useState(momentum);

  // **NEW**: Detect momentum changes for animations
  useEffect(() => {
    if (momentum > prevMomentum) {
      setMomentumChanged('gain');
    } else if (momentum < prevMomentum) {
      setMomentumChanged('loss');
    }
    // Reset after a short delay
    const timer = setTimeout(() => setMomentumChanged(null), 500);
    setPrevMomentum(momentum); // Update previous momentum
    return () => clearTimeout(timer);
  }, [momentum, prevMomentum]);


  // Handle effect animations
  useEffect(() => {
    if (momentumEffect.active) {
      setPulseEffect(true);

      // Clear effect after animation
      const timer = setTimeout(() => {
        setPulseEffect(false);
      }, momentumEffect.duration);

      return () => clearTimeout(timer);
    }
  }, [momentumEffect]);
  // Create array of MAX_MOMENTUM_LEVEL length for rendering pips
  const momentumPips = Array.from({ length: MAX_MOMENTUM_LEVEL }, (_, i) => i < momentum);
  // Calculate progress to next level
  const nextLevelThreshold = momentum < MAX_MOMENTUM_LEVEL ?
  (momentum + 1) * 2 : Infinity;
  const progressToNextLevel = momentum < MAX_MOMENTUM_LEVEL
    ?
  (consecutiveCorrect % 2) / 2 // 0 or 0.5
    : 0;
  // Get color intensity based on momentum level
  const getMomentumColor = (level: number) => {
    if (level === 0) return { bg: 'bg-gray-800', border: 'border-gray-700', pulse: 'rgba(255, 140, 0, 0.3)', text: 'text-gray-400' };
  if (level === 1) return { bg: 'bg-orange-900', border: 'border-orange-800', pulse: 'rgba(255, 140, 0, 0.4)', text: 'text-orange-300' };
  if (level === 2) return { bg: 'bg-orange-700', border: 'border-orange-600', pulse: 'rgba(255, 140, 0, 0.5)', text: 'text-orange-200' };
  return { bg: 'bg-orange-500', border: 'border-orange-400', pulse: 'rgba(255, 140, 0, 0.7)', text: 'text-orange-100' };
  };
  return (
    <div className={`${className}`}>
      <div className="flex items-center justify-between mb-1">
        {showLabel && (
          <div className={`font-pixel ${compact ? 'text-sm' : 'text-base'} text-orange-300`}>
            {compact ? 'MOM' : 'MOMENTUM'} {/* Shorten label in compact */}
          </div>
        )}

        {/* Show consecutive correct count */}
         {!compact && (
          <AnimatePresence mode="wait">
            <motion.div
              key={consecutiveCorrect}
              className="ml-2 font-pixel text-sm text-orange-300/80 tabular-nums"
              initial={{ opacity: 0, y: -5 }}
              animate={{ opacity: 1,
  y: 0 }}
              exit={{ opacity: 0, y: 5 }}
            >
              {consecutiveCorrect > 0 ? `${consecutiveCorrect}×` : ''}
            </motion.div>
          </AnimatePresence>
        )}

        {/*
  "Max" indicator when at max momentum */}
        {momentum === MAX_MOMENTUM_LEVEL && !compact && (
          <motion.div
            className="ml-auto font-pixel text-sm text-orange-300 font-bold animate-pulse-strong" // **NEW**: Added strong pulse animation class
            initial={{ opacity: 0 }}
            animate={{
              opacity: [0.7, 1, 0.7],
         transition: { repeat: Infinity, duration: 1.5 }
            }}
          >
            MAX! {/* **NEW**: Added exclamation */}
          </motion.div>
        )}
      </div>

      {/* Render momentum pips with improved visual design */}
      <div className="flex space-x-2 items-center">
         {momentumPips.map((filled, index) => {
          const colors = getMomentumColor(filled ?
  index + 1 : 0);

          return (
            <motion.div // **NEW**: Wrap pip in motion.div
              key={`pip-${index}`}
              className={`relative ${compact ? 'w-8 h-8' : 'w-10 h-10'} rounded-full
                ${filled ? colors.bg : 'bg-gray-900'}
                border-2 ${filled ? colors.border : 'border-gray-800'}

                 ${filled && index === MAX_MOMENTUM_LEVEL - 1 ? 'animate-pulse' : ''}`}
              style={{
                boxShadow: filled ? `0 0 8px ${colors.pulse}` : 'none',
                transition: 'all 0.3s ease-in-out'
              }}
              // **NEW**: Add animation based on momentum change
              initial={{ scale: 1 }}
              animate={{
                scale: momentumChanged === 'gain' && index === momentum - 1 ? [1, 1.3, 1] : // Scale pulse on gain
                       momentumChanged === 'loss' && index === momentum ? [1, 0.7, 1] : // Scale down on loss
                       1,
              }}
              transition={{ duration: 0.3 }}
           >
              {/* Inner texture for filled pips */}
              {filled && (
                <div
                  className="absolute inset-0 rounded-full opacity-70"

  style={{
                    backgroundImage: index === 2
                      ? `url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='6' height='6' fill='%23c2410c'/%3E%3Crect x='0' y='0' width='2' height='2' fill='%23ea580c'/%3E%3Crect x='4' y='0' width='2' height='2' fill='%23ea580c'/%3E%3Crect x='2' y='2' width='2' height='2' fill='%23ea580c'/%3E%3Crect x='0' y='4' width='2' height='2' fill='%23ea580c'/%3E%3Crect x='4' y='4' width='2' height='2' fill='%23ea580c'/%3E%3C/svg%3E")`

       : index === 1
                      ?

  `url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='4' height='4' fill='%23c2410c'/%3E%3Crect x='0' y='0' width='1' height='1' fill='%23ea580c'/%3E%3Crect x='2' y='2' width='1' height='1' fill='%23ea580c'/%3E%3C/svg%3E")`
                      : `url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='4' height='4' fill='%23ea580c'/%3E%3Crect x='0' y='0' width='1' height='1' fill='%23f97316'/%3E%3Crect x='2' y='2' width='1' height='1' fill='%23f97316'/%3E%3C/svg%3E")`,
                    backgroundSize: index === 2 ?
  '6px 6px' : '4px 4px',
                    imageRendering: 'pixelated'
                  }}
                />
              )}


   {/* Central highlight dot */}
              {filled && (
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-1 h-1 bg-white rounded-full opacity-80"></div>
              )}

              {/* Partial fill for pip in progress */}

              {!filled && index === momentum && progressToNextLevel > 0 && (
                <motion.div
                  className="absolute bottom-0 left-0 right-0 bg-orange-800/60 rounded-b-full"
                  style={{

  height: `${progressToNextLevel * 100}%`,
                    borderBottomLeftRadius: '100%',
                    borderBottomRightRadius: '100%',
                    backgroundImage: `url("data:image/svg+xml,%3Csvg width='2' height='2' viewBox='0 0 2 2' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='2' height='2' fill='%23c2410c'/%3E%3Crect x='0' y='0' width='1' height='1' fill='%23ea580c'/%3E%3C/svg%3E")`,

     backgroundSize: '2px 2px',
                    imageRendering: 'pixelated'
                  }}
                  initial={{ height: 0 }}
                  animate={{

     height: `${progressToNextLevel * 100}%`,
                    transition: { type: 'spring', damping: 15 }
                  }}
                />
              )}


           {/* Pulse effect for active pips */}
              {filled && pulseEffect && (
                <motion.div
                  className="absolute inset-0 rounded-full bg-orange-500"
                  initial={{ opacity: 0, scale: 0.8 }}

             animate={{
                    opacity: [0, 0.8, 0],
                    scale: [0.8, 1.2, 1.5],
                    transition: {

   duration: 0.8,
                      repeat: momentumEffect.intensity === 'high' ?
  2 : 1
                    }
                  }}
                />
              )}

              {/* Level
  indicator */}
              {filled && (
                <div className="absolute inset-0 flex items-center justify-center">
                  <span className={`text-xs font-bold ${colors.text} font-pixel`}> {/* **NEW**: Dynamic text color */}
                    {index + 1}

  </span>
                </div>
              )}
            </motion.div> // End motion.div wrapper
          );
  })}
      </div>

      {/* Status messages below the counter */}
      <AnimatePresence>
        {momentum > 0 && momentum < MAX_MOMENTUM_LEVEL && (
          <motion.div
            className="mt-1 text-xs font-pixel text-orange-300/80"
            initial={{ opacity: 0, height: 0 }}

  animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
          >
            {momentum === 1 && "Building momentum..."}
            {momentum === 2 && "High momentum!"}
          </motion.div>
        )}
      </AnimatePresence>


     {/* Special notification for max momentum */}
      <AnimatePresence>
        {momentum === MAX_MOMENTUM_LEVEL && (
          <motion.div
            className="mt-1 text-xs font-pixel text-orange-300 font-bold"
            initial={{ opacity: 0, y: -5 }}
            animate={{
              opacity: 1,

               y: 0,
              transition: { type: 'spring', damping: 10 }
            }}
            exit={{ opacity: 0, y: 5 }}
          >
            {/* **NEW**: More exciting text */}
            MAX MOMENTUM! EXTRAPOLATE Unlocked!
  </motion.div>
        )}
      </AnimatePresence>

      {/* **NEW**: Momentum break effect overlay */}
      <AnimatePresence>
          {momentumChanged === 'loss' && (
              <motion.div
                  className="absolute inset-0 bg-red-700/30 backdrop-blur-sm z-10 flex items-center justify-center"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: [0, 1, 0], transition: { duration: 0.6 } }}
                  exit={{ opacity: 0 }}
              >
                  <motion.div
                      className="text-red-200 text-2xl font-pixel font-bold animate-shake-strong" // Use strong shake
                      initial={{ scale: 0.5 }}
                      animate={{ scale: [1, 1.1, 1], transition: { duration: 0.4 } }}
                  >
                      MOMENTUM BROKEN!
                  </motion.div>
              </motion.div>
          )}
      </AnimatePresence>
    </div>
  );
 }
==== END: app/components/gameplay/MomentumCounter.tsx ====

==== START: app/components/gameplay/InsightMeter.tsx ====
// app/components/gameplay/InsightMeter.tsx
'use client';
import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useResourceStore, RESOURCE_THRESHOLDS } from '../../store/resourceStore';

interface InsightMeterProps {
  showLabel?: boolean;
  showValue?: boolean;
  className?: string;
  size?: 'sm' | 'md' | 'lg' | 'xl';
  compact?: boolean;
  vertical?: boolean;
  showAnimation?: boolean;
}

/**
 * Insight Meter Component - Enhanced Visual Design
 * 
 * A strategic resource meter inspired by roguelite persistent resources
 * (like Darkness in Hades). Features clear threshold markers and
 * distinctive visual states as player approaches key unlocks.
 */
export default function InsightMeter({
  showLabel = true,
  showValue = true,
  className = '',
  size = 'md',
  compact = false,
  vertical = false,
  showAnimation = false
}: InsightMeterProps) {
  // Get resource state
  const { 
    insight, 
    insightMax, 
    insightEffect,
  } = useResourceStore();
  
  // Refs for tracking previous values
  const prevInsightRef = useRef(insight);
  
  // Local state
  const [insightDelta, setInsightDelta] = useState(0);
  const [pulseEffect, setPulseEffect] = useState(false);
  const [thresholdCrossed, setThresholdCrossed] = useState<number | null>(null);
  const [actionAvailable, setActionAvailable] = useState<string | null>(null);
  
  // Calculate fill percentage
  const fillPercentage = Math.min(100, Math.max(0, (insight / insightMax) * 100));
  
  // Process insight changes and threshold crossings
  useEffect(() => {
    const prevPercentage = (prevInsightRef.current / insightMax) * 100;
    
    // Calculate delta for animation
    const delta = insight - prevInsightRef.current;
    if (delta !== 0) {
      setInsightDelta(delta);
      // Clear delta after animation duration
      const clearTimer = setTimeout(() => setInsightDelta(0), 1500);
      return () => clearTimeout(clearTimer);
    }
    
    // Check if we crossed important thresholds
    const thresholds = [
      { value: 25, name: 'REFRAME' },
      { value: 50, name: 'EXTRAPOLATE' },
      { value: 75, name: 'SYNTHESIS' }
    ];
    
    thresholds.forEach(threshold => {
      if (prevPercentage < threshold.value && fillPercentage >= threshold.value) {
        setThresholdCrossed(threshold.value);
        setActionAvailable(threshold.name);
        setTimeout(() => setThresholdCrossed(null), 2000);
      }
    });
    
    prevInsightRef.current = insight;
  }, [insight, insightMax, fillPercentage]);
  
  // Handle animation from gameplay effect
  useEffect(() => {
    if (insightEffect.active || showAnimation) {
      setPulseEffect(true);
      
      const timer = setTimeout(() => {
        setPulseEffect(false);
      }, insightEffect.duration || 2000);
      
      return () => clearTimeout(timer);
    }
  }, [insightEffect, showAnimation]);
  
  // Size classes based on orientation
  const sizeClasses = vertical 
    ? {
        sm: "w-2 h-32",
        md: "w-4 h-40",
        lg: "w-6 h-48",
        xl: "w-8 h-64"
      }
    : {
        sm: "h-2 w-full",
        md: "h-4 w-full",
        lg: "h-6 w-full",
        xl: "h-8 w-full"
      };
  
  // Get appropriate fill color based on level
  const getFillColor = () => {
    if (fillPercentage >= 75) return '#2dd4bf'; // Teal for highest tier
    if (fillPercentage >= 50) return '#a855f7'; // Purple for medium tier
    if (fillPercentage >= 25) return '#3b82f6'; // Blue for first tier
    return '#1d4ed8'; // Dark blue for starting tier
  };
  
  // Get appropriate shader colors
  const getShaderColors = () => {
    if (fillPercentage >= 75) {
      return {
        darkShade: '#0d9488',
        lightShade: '#5eead4',
        pattern: 'teal',
        glow: 'rgba(45, 212, 191, 0.5)'
      };
    }
    if (fillPercentage >= 50) {
      return {
        darkShade: '#7e22ce',
        lightShade: '#c084fc',
        pattern: 'purple',
        glow: 'rgba(168, 85, 247, 0.5)'
      };
    }
    return {
      darkShade: '#1d4ed8',
      lightShade: '#60a5fa',
      pattern: 'blue',
      glow: 'rgba(59, 130, 246, 0.4)'
    };
  };
  
  // Get pattern SVG for the fill texture
  const getPatternSvg = () => {
    const { darkShade, lightShade } = getShaderColors();
    const darkHex = darkShade.replace('#', '');
    const lightHex = lightShade.replace('#', '');
    
    return `url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='4' height='4' fill='%23${darkHex}'/%3E%3Crect width='1' height='1' fill='%23${lightHex}'/%3E%3Crect x='2' y='2' width='1' height='1' fill='%23${lightHex}'/%3E%3C/svg%3E")`;
  };
  
  // Threshold markers with improved visualization
  const thresholdMarkers = [
    { 
      percent: 25, 
      label: 'R', 
      action: 'REFRAME',
      colorClass: 'blue' 
    },
    { 
      percent: 50, 
      label: 'E', 
      action: 'EXTRAPOLATE',
      colorClass: 'purple' 
    },
    { 
      percent: 75, 
      label: 'S', 
      action: 'SYNTHESIS',
      colorClass: 'teal' 
    }
  ];
  
  return (
    <div className={`${className} ${vertical ? 'flex items-end' : ''}`}>
      {/* Header with label and value display */}
      <div className={`flex items-center justify-between ${vertical ? 'flex-col mr-2' : 'mb-1'}`}>
        {showLabel && (
          <div className={`
            font-pixel 
            text-${fillPercentage >= 75 ? 'teal' : fillPercentage >= 50 ? 'purple' : 'blue'}-300
            ${compact ? 'text-sm' : 'text-base'} tracking-wider
            ${vertical ? 'rotate-90 origin-bottom-right transform translate-y-6' : ''}
          `}>
            INSIGHT
          </div>
        )}
        
        {showValue && (
          <div className={`
            font-pixel text-sm tabular-nums 
            text-${fillPercentage >= 75 ? 'teal' : fillPercentage >= 50 ? 'purple' : 'blue'}-200
            ${vertical ? 'mt-2' : ''}
          `}>
            <AnimatePresence mode="wait">
              <motion.span
                key={insight}
                initial={{ opacity: 0, y: -5 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: 5 }}
                transition={{ duration: 0.2 }}
              >
                {insight}
              </motion.span>
            </AnimatePresence>
            /{insightMax}
          </div>
        )}
      </div>
      
      {/* Main meter container */}
      <div className={`
        relative bg-blue-900/30 ${sizeClasses[size]}
        overflow-hidden
        ${vertical ? 'flex flex-col-reverse' : ''}
      `}
      style={{ 
        imageRendering: 'pixelated',
        borderWidth: '2px',
        borderStyle: 'solid',
        borderImage: 'url("data:image/svg+xml,%3Csvg width=\'3\' height=\'3\' viewBox=\'0 0 3 3\' fill=\'none\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Crect width=\'1\' height=\'1\' fill=\'%231a1f2e\'/%3E%3Crect width=\'3\' height=\'3\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\'/%3E%3C/svg%3E") 2 stretch'
      }}>
        {/* Enhanced pixelated fill with dynamic color and pattern */}
        <motion.div
          className={`absolute ${vertical ? 'inset-x-0 bottom-0' : 'inset-y-0 left-0'}`}
          style={{ 
            backgroundImage: getPatternSvg(),
            backgroundSize: '4px 4px',
            imageRendering: 'pixelated',
            boxShadow: `0 0 8px ${getShaderColors().glow}`,
            [vertical ? 'height' : 'width']: `${fillPercentage}%` 
          }}
          initial={{ [vertical ? 'height' : 'width']: `${fillPercentage}%` }}
          animate={{ 
            [vertical ? 'height' : 'width']: `${fillPercentage}%`,
            transition: { 
              type: 'spring', 
              damping: 30,
              stiffness: 400
            }
          }}
        >
          {/* Scan lines effect */}
          <div 
            className="absolute inset-0 mix-blend-overlay opacity-30"
            style={{
              backgroundImage: `url("data:image/svg+xml,%3Csvg width='2' height='2' viewBox='0 0 2 2' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect y='1' width='2' height='1' fill='%23000000'/%3E%3C/svg%3E")`,
              backgroundSize: '2px 2px',
              imageRendering: 'pixelated'
            }}
          />
          
          {/* Animated scanline */}
          <motion.div 
            className="absolute inset-0 bg-white/10 origin-top"
            style={{ scaleY: 0.05 }}
            animate={{ 
              top: ['-10%', '110%'],
              transition: { 
                repeat: Infinity, 
                duration: 1.5, 
                ease: 'linear',
                repeatDelay: 1
              }
            }}
          />
        </motion.div>
        
        {/* Threshold markers with improved visibility */}
        {thresholdMarkers.map((marker, index) => {
          const isActive = fillPercentage >= marker.percent;
          const isHighlighted = thresholdCrossed === marker.percent;
          const markerColor = marker.colorClass === 'teal' 
            ? (isActive ? 'text-teal-400' : 'text-teal-900') 
            : marker.colorClass === 'purple'
              ? (isActive ? 'text-purple-400' : 'text-purple-900')
              : (isActive ? 'text-blue-400' : 'text-blue-900');
          
          return (
            <div 
              key={`threshold-${index}`} 
              className={`absolute ${vertical ? 'inset-x-0' : 'inset-y-0'}`} 
              style={{ 
                [vertical ? 'bottom' : 'left']: `${marker.percent}%`, 
                zIndex: 2
              }}
            >
              {/* Marker line */}
              <div className={`
                ${vertical ? 'h-1 w-full' : 'w-1 h-full'} 
                ${isActive 
                  ? marker.colorClass === 'teal' 
                    ? 'bg-teal-400' 
                    : marker.colorClass === 'purple' 
                      ? 'bg-purple-400' 
                      : 'bg-blue-400'
                  : 'bg-gray-700'
                }
                ${isHighlighted ? 'animate-pulse' : ''}
              `}></div>
              
              {/* Action label */}
              {!compact && size !== 'sm' && (
                <div className={`
                  absolute 
                  ${vertical 
                    ? 'left-full ml-1 -translate-y-1/2' 
                    : '-top-6 -translate-x-1/2'} 
                  text-xs font-pixel
                  ${markerColor}
                  ${isHighlighted ? 'text-glow-sm animate-pulse' : ''}
                  ${isActive ? 'font-bold' : 'opacity-50'}
                `}
                style={{
                  textShadow: isHighlighted 
                    ? `0 0 6px ${marker.colorClass === 'teal' 
                        ? '#2dd4bf' 
                        : marker.colorClass === 'purple' 
                          ? '#a855f7' 
                          : '#3b82f6'
                      }`
                    : 'none'
                }}>
                  {marker.label}
                </div>
              )}
              
              {/* Threshold crossing animation */}
              {isHighlighted && (
                <motion.div 
                  className={`
                    absolute ${vertical ? 'inset-x-0 h-3' : 'inset-y-0 w-3'} 
                    ${marker.colorClass === 'teal' 
                      ? 'bg-teal-400' 
                      : marker.colorClass === 'purple' 
                        ? 'bg-purple-400' 
                        : 'bg-blue-400'
                    }
                  `}
                  initial={{ opacity: 0.8 }}
                  animate={{ 
                    opacity: [0.8, 0.3, 0],
                    [vertical ? 'height' : 'width']: ['3px', '16px', '24px'],
                    transition: { duration: 0.8 }
                  }}
                />
              )}
            </div>
          );
        })}
        
        {/* Pulse effect animation */}
        <AnimatePresence>
          {pulseEffect && (
            <motion.div
              className="absolute inset-0 bg-white/20"
              initial={{ opacity: 0 }}
              animate={{ 
                opacity: [0, 0.4, 0],
                transition: { 
                  repeat: insightEffect.intensity === 'high' ? 3 : 2,
                  duration: 0.5 
                }
              }}
              exit={{ opacity: 0 }}
            />
          )}
        </AnimatePresence>
        
        {/* Delta indicator */}
        <AnimatePresence>
          {insightDelta !== 0 && (
            <motion.div
              className={`
                absolute ${vertical ? 'right-full mr-1' : 'bottom-full mb-1'} 
                font-pixel text-xs ${insightDelta > 0 ? 'text-green-400' : 'text-red-400'}
              `}
              initial={{ opacity: 0, y: insightDelta > 0 ? 10 : -10 }}
              animate={{ 
                opacity: 1, 
                y: 0,
                transition: { type: 'spring', damping: 15 }
              }}
              exit={{ 
                opacity: 0, 
                y: insightDelta > 0 ? -10 : 10,
                transition: { duration: 0.3 }
              }}
            >
              {insightDelta > 0 ? '+' : ''}{insightDelta}
            </motion.div>
          )}
        </AnimatePresence>
        
        {/* Decorative corners */}
        <div className="absolute top-0 left-0 w-1 h-1 bg-white/50"></div>
        <div className="absolute top-0 right-0 w-1 h-1 bg-white/30"></div>
        <div className="absolute bottom-0 left-0 w-1 h-1 bg-white/20"></div>
        <div className="absolute bottom-0 right-0 w-1 h-1 bg-black/30"></div>
      </div>
      
      {/* Action unlocked notification */}
      <AnimatePresence>
        {actionAvailable && (
          <motion.div
            className={`
              mt-1 text-xs font-pixel 
              ${actionAvailable === 'SYNTHESIS' 
                ? 'text-teal-300' 
                : actionAvailable === 'EXTRAPOLATE' 
                  ? 'text-purple-300' 
                  : 'text-blue-300'
              }
              ${vertical ? 'ml-2' : ''}
            `}
            initial={{ opacity: 0, y: 5 }}
            animate={{ 
              opacity: 1, 
              y: 0, 
              transition: { type: 'spring', damping: 15 }
            }}
            exit={{ opacity: 0, y: -5 }}
          >
            {actionAvailable} unlocked!
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Threshold labels */}
      {size === 'lg' && !compact && !vertical && (
        <div className="flex justify-between text-2xs mt-1 px-1">
          <div className="text-gray-400">0</div>
          <div className={fillPercentage >= 25 ? 'text-blue-400' : 'text-gray-600'}>25◆</div>
          <div className={fillPercentage >= 50 ? 'text-purple-400' : 'text-gray-600'}>50◆</div>
          <div className={fillPercentage >= 75 ? 'text-teal-400' : 'text-gray-600'}>75◆</div>
          <div className="text-gray-400">100</div>
        </div>
      )}
      
      {/* Vertical mode threshold labels */}
      {size === 'lg' && !compact && vertical && (
        <div className="flex flex-col justify-between text-2xs text-gray-400 ml-1 py-1 h-full">
          <div>100</div>
          <div className={fillPercentage >= 75 ? 'text-teal-400' : 'text-gray-600'}>75◆</div>
          <div className={fillPercentage >= 50 ? 'text-purple-400' : 'text-gray-600'}>50◆</div>
          <div className={fillPercentage >= 25 ? 'text-blue-400' : 'text-gray-600'}>25◆</div>
          <div>0</div>
        </div>
      )}
    </div>
  );
}
==== END: app/components/gameplay/InsightMeter.tsx ====

==== START: app/components/gameplay/StrategicActions.tsx ====
// app/components/gameplay/StrategicActions.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useResourceStore } from '../../store/resourceStore';
import { PixelText } from '../PixelThemeProvider';

// Type definitions
type StrategicActionType = 'reframe' | 'extrapolate' | 'boast' | 'synthesis';

interface StrategicActionsProps {
  characterId: string;
  stageId: string;
  className?: string;
  onActionActivate?: (actionType: StrategicActionType) => void;
  onActionComplete?: (actionType: StrategicActionType, successful: boolean) => void;
  onActionCancel?: (actionType: StrategicActionType) => void;
}

/**
 * Strategic Actions Component
 * 
 * Control options that help shape dialogue flow using action icons
 */
export default function StrategicActions({
  characterId,
  stageId,
  className = '',
  onActionActivate,
  onActionComplete,
  onActionCancel
}: StrategicActionsProps) {
  // Track hover and expanded states
  const [hoveredAction, setHoveredAction] = useState<StrategicActionType | null>(null);
  
  // Access resource store for action availability
  const { availableActions, activeAction, insight } = useResourceStore();
  
  // Action definitions with metadata
  const actionDefinitions: Record<StrategicActionType, {
    label: string;
    description: string;
    cost: number;
    bgClass: string;
    borderClass: string;
    iconPath: string;
  }> = {
    reframe: {
      label: 'Reframe',
      description: 'Shift to more approachable topics',
      cost: 25,
      bgClass: 'bg-blue-800',
      borderClass: 'border-blue-900',
      iconPath: "M4,4 H12 M4,8 H12 M4,12 H10" // Simple text-line icon SVG path
    },
    extrapolate: {
      label: 'Extrapolate',
      description: 'Form connections between concepts',
      cost: 50,
      bgClass: 'bg-purple-800',
      borderClass: 'border-purple-900',
      iconPath: "M5,8 L8,5 M9,6 L12,3 M8,9 L11,6" // Connect-the-dots icon
    },
    boast: {
      label: 'Challenge',
      description: 'Demonstrate expert knowledge',
      cost: 0, // Uses momentum instead
      bgClass: 'bg-orange-700',
      borderClass: 'border-orange-800',
      iconPath: "M8,3 L12,7 L8,11 L4,7 Z" // Diamond shape
    },
    synthesis: {
      label: 'Synthesis',
      description: 'Discover new knowledge domains',
      cost: 75,
      bgClass: 'bg-green-700',
      borderClass: 'border-green-900',
      iconPath: "M4,5 H12 M4,8 H10 M4,11 H8" // Narrowing text lines
    }
  };
  
  // SVG icon component for pixel art icons
  const PixelIcon = ({ path, className = '' }: { path: string, className?: string }) => (
    <svg 
      width="16" 
      height="16" 
      viewBox="0 0 16 16" 
      fill="none" 
      className={`stroke-white stroke-[1.5px] ${className}`}
      style={{ imageRendering: 'pixelated' }}
    >
      <path d={path} strokeLinecap="square" />
    </svg>
  );
  
  // Button component for strategic actions
  const ActionButton = ({ 
    type, 
    isAvailable 
  }: { 
    type: StrategicActionType, 
    isAvailable: boolean 
  }) => {
    const def = actionDefinitions[type];
    const isActive = activeAction === type;
    const affordabilityClass = def.cost > 0 && insight < def.cost ? 'opacity-50' : '';
    
    return (
      <motion.button
        className={`
          w-16 h-16 relative 
          ${def.bgClass} ${def.borderClass}
          border-2 box-content
          flex items-center justify-center
          transition-colors duration-150
          ${isActive ? 'ring-1 ring-white' : ''}
          ${isAvailable ? '' : 'opacity-40'}
          ${affordabilityClass}
          pixel-borders
        `}
        disabled={!isAvailable || (def.cost > 0 && insight < def.cost)}
        onClick={() => isAvailable && onActionActivate && onActionActivate(type)}
        onMouseEnter={() => setHoveredAction(type)}
        onMouseLeave={() => setHoveredAction(null)}
        whileHover={{ y: isAvailable ? -2 : 0 }}
        whileTap={{ y: isAvailable ? 1 : 0 }}
        initial={{ scale: 1 }}
        animate={isActive ? { 
          scale: [1, 1.05, 1],
          transition: { repeat: Infinity, duration: 1.5 }
        } : { scale: 1 }}
      >
        <PixelIcon path={def.iconPath} className="w-8 h-8" />
        
        {/* Cost indicator */}
        {def.cost > 0 && (
          <div className="absolute -bottom-1 -right-1 text-sm bg-black/80 px-1 rounded-sm">
            {def.cost}◆
          </div>
        )}
        
        {/* Active indicator pulse */}
        {isActive && (
          <motion.div 
            className="absolute inset-0 bg-white"
            initial={{ opacity: 0 }}
            animate={{ 
              opacity: [0, 0.3, 0],
              transition: { repeat: Infinity, duration: 2 }
            }}
          />
        )}
        
        {/* Tooltip on hover */}
        <AnimatePresence>
          {hoveredAction === type && !isActive && (
            <motion.div
              className="absolute top-full mt-2 left-1/2 -translate-x-1/2 w-48 z-50
                        bg-gray-900/95 border border-gray-700 pixel-borders-thin shadow-lg"
              initial={{ opacity: 0, y: -5, scale: 0.95 }}
              animate={{ opacity: 1, y: 0, scale: 1 }}
              exit={{ opacity: 0, y: -5, scale: 0.95 }}
              transition={{ duration: 0.15 }}
            >
              <div className="p-3">
                <div className="text-sm font-pixel text-white mb-1">{def.label}</div>
                <div className="text-xs text-gray-300">{def.description}</div>
                {def.cost > 0 ? (
                  <div className={`text-xs mt-1 ${insight >= def.cost ? 'text-blue-300' : 'text-red-300'}`}>
                    Cost: {def.cost} Insight
                  </div>
                ) : (
                  <div className="text-xs mt-1 text-orange-300">
                    Requires max momentum
                  </div>
                )}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.button>
    );
  };
  
  // Render the action buttons with proper spacing
  return (
    <div className={`flex items-center gap-3 ${className}`}>
      {availableActions.reframe && <ActionButton type="reframe" isAvailable={availableActions.reframe} />}
      {availableActions.extrapolate && <ActionButton type="extrapolate" isAvailable={availableActions.extrapolate} />}
      {availableActions.synthesis && <ActionButton type="synthesis" isAvailable={availableActions.synthesis} />}
    </div>
  );
}

/**
 * Container version with expanded state support
 */
export function StrategicActionsContainer(props: StrategicActionsProps) {
  const { activeAction } = useResourceStore();
  
  return (
    <div className="relative">
      <StrategicActions {...props} />
      
      {/* Expanded state panel - shows when an action is active */}
      <AnimatePresence>
        {activeAction && (
          <motion.div
            className="absolute top-full right-0 mt-3 bg-gray-900/90 border border-gray-700 
                      pixel-borders shadow-lg z-50"
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
          >
            <div className="p-3 w-48">
              <PixelText className="text-sm mb-2 text-white">
                {activeAction === 'reframe' && 'Reframing Conversation'}
                {activeAction === 'extrapolate' && 'Extrapolating Connections'}
                {activeAction === 'boast' && 'Challenge Mode Active'}
                {activeAction === 'synthesis' && 'Synthesizing Knowledge'}
              </PixelText>
              
              <div className="text-xs text-gray-300">
                {activeAction === 'reframe' && 'Simpler topics now available.'}
                {activeAction === 'extrapolate' && 'Form connections between concepts.'}
                {activeAction === 'boast' && 'Expert-level questions with higher rewards.'}
                {activeAction === 'synthesis' && 'Discover new knowledge areas.'}
              </div>
              
              {/* Optional cancel button */}
              <button 
                className="mt-2 text-xs text-gray-400 hover:text-white"
                onClick={() => props.onActionCancel && props.onActionCancel(activeAction)}
              >
                Cancel (recover cost)
              </button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
==== END: app/components/gameplay/StrategicActions.tsx ====

==== START: app/components/debug/VerticalSliceDebugPanel.tsx ====
// app/components/debug/VerticalSliceDebugPanel.tsx
'use client';
import { useState, useEffect, useRef } from 'react';
import { useGameStore } from '../../store/gameStore';
import { useDialogueStateMachine } from '../../core/dialogue/DialogueStateMachine';
import { useJournalStore } from '../../store/journalStore';
import { useGameState } from '../../core/statemachine/GameStateMachine';
import { useEventBus } from '../../core/events/CentralEventBus';
import { useKnowledgeStore, KnowledgeDomain } from '../../store/knowledgeStore'; // Import KnowledgeDomain
import { GameEventType } from '../../core/events/EventTypes';
import { getDomainColor } from '../../core/themeConstants'; // Import helper

// Helper to check local storage safely
function checkLocalStorage(key: string): string {
  // Ensure localStorage is available (prevents errors during SSR or in certain environments)
  if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') {
    return 'Unavailable';
  }
  try {
    const item = localStorage.getItem(key);
    // *** FIX: Check if item is not null before accessing .length ***
    if (item !== null) {
      // Calculate size in KB, handle potential large items
      const sizeKB = Math.round(item.length / 1024);
      return `${sizeKB} KB`;
    } else {
      return 'Not found';
    }
  } catch (e) {
    console.error(`Error accessing localStorage key "${key}":`, e);
    return 'Error';
  }
}


/**
 * Enhanced Vertical Slice Debug Panel
 *
 * A powerful debug panel with QoL features for testing and development:
 * - Collapsible sections for better organization
 * - Copy to clipboard functionality for sharing state
 * - Visual timeline of critical events
 * - State visualization with visual indicators of health
 * - Direct state manipulations for faster testing
 */
export default function VerticalSliceDebugPanel() {
  // Panel UI state
  const [isExpanded, setIsExpanded] = useState(true);
  const [activeTab, setActiveTab] = useState<'overview' | 'events' | 'state' | 'tools'>('overview');
  const [copiedFeedback, setCopiedFeedback] = useState(false);
  const [criticalEvents, setCriticalEvents] = useState<Array<{event: string, timestamp: number}>>([]);
  const [consoleOutput, setConsoleOutput] = useState<string[]>([]);

  // Visibility toggles for sections
  const [sections, setSections] = useState({
    criticalPath: true,
    playerState: true,
    journalState: true,
    dialogueState: true,
    events: true,
    tools: true
  });

  // Ref for auto-scrolling event log
  const eventsEndRef = useRef<HTMLDivElement>(null);

  // Game state from core systems
  const gameState = useGameState();
  const dialogueState = useDialogueStateMachine();
  const gameStore = useGameStore();
  const journalStore = useJournalStore();
  const knowledgeStore = useKnowledgeStore();

  // Track critical path events
  useEffect(() => {
    const eventBus = useEventBus.getState();

    // Subscribe to critical events
    const unsubDialogueEvents = eventBus.subscribe(
      GameEventType.DIALOGUE_CRITICAL_PATH,
      (event) => {
        const payload = event.payload as any; // Cast for easier access
        setCriticalEvents(prev => [
          ...prev,
          {
            event: `Critical dialogue: ${payload?.stateId || 'unknown'}`, // Safe access
            timestamp: Date.now()
          }
        ]);
        addConsoleMessage(`🔑 Critical path: ${payload?.stateId || 'unknown'}`);
      }
    );

    const unsubJournalEvents = eventBus.subscribe(
      GameEventType.JOURNAL_ACQUIRED,
      (event) => {
         const payload = event.payload as any; // Cast for easier access
        setCriticalEvents(prev => [
          ...prev,
          {
            event: `Journal acquired: ${payload?.tier || 'unknown'}`, // Safe access
            timestamp: Date.now()
          }
        ]);
        addConsoleMessage(`📓 Journal acquired: ${payload?.tier || 'unknown'} (from ${payload?.character || 'unknown'})`);
      }
    );

    const unsubPhaseEvents = eventBus.subscribe(
      GameEventType.GAME_PHASE_CHANGED,
      (event) => {
         const payload = event.payload as any; // Cast for easier access
        setCriticalEvents(prev => [
          ...prev,
          {
            event: `Phase changed: ${payload?.from || '?'} → ${payload?.to || '?'}`, // Safe access
            timestamp: Date.now()
          }
        ]);
        addConsoleMessage(`🔄 Phase change: ${payload?.from || '?'} → ${payload?.to || '?'}`);
      }
    );

    const unsubKnowledgeEvents = eventBus.subscribe(
      GameEventType.KNOWLEDGE_GAINED,
      (event) => {
        const payload = event.payload as any; // Cast for easier access
        addConsoleMessage(`✨ Knowledge gained: ${payload?.conceptId || '?'} +${payload?.amount || '?'}%`);
      }
    );

    // Clean up subscriptions
    return () => {
      unsubDialogueEvents();
      unsubJournalEvents();
      unsubPhaseEvents();
      unsubKnowledgeEvents();
    };
  }, []); // Empty dependency array ensures this runs only once

  // Auto-scroll event log
  useEffect(() => {
    if (eventsEndRef.current) {
      eventsEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [consoleOutput]);

  // Helper to add console messages
  const addConsoleMessage = (message: string) => {
    const timestamp = new Date().toLocaleTimeString();
    setConsoleOutput(prev => {
      const newOutput = [...prev, `[${timestamp}] ${message}`];
      // Keep only the latest 100 messages
      if (newOutput.length > 100) {
        return newOutput.slice(-100);
      }
      return newOutput;
    });
  };

  // Kapoor Node ID - needed for some debug tools
  // Ideally, this would be dynamically determined or passed in
  const kapoorNodeId = 'calibration_node'; // Assuming this is the ID

  // Critical path steps
  const criticalPathSteps = [
    {
      id: 'game-initialized',
      label: 'Game Initialized',
      isComplete: !!gameStore.map, // Check if map exists in gameStore
      details: gameStore.map ? `Map Seed: ${gameStore.map.seed || 'unknown'}` : 'Not initialized'
    },
    {
      id: 'calibration-node-selected',
      label: 'Calibration Node Selected',
      isComplete: !!gameStore.currentNodeId && gameStore.currentNodeId.includes('calibration'),
      details: gameStore.currentNodeId || 'No node selected'
    },
    {
      id: 'dialogue-started',
      label: 'Dialogue Started',
      isComplete: dialogueState.isActive,
      details: dialogueState.isActive
        ? `Current State: ${dialogueState.currentNodeId || 'unknown'}` // Use state machine's node ID
        : 'Not started'
    },
    {
      id: 'journal-acquired',
      label: 'Journal Acquired',
      isComplete: journalStore.hasJournal,
      details: journalStore.hasJournal
        ? `Journal Tier: ${journalStore.currentUpgrade}`
        : 'Not acquired'
    },
    {
      id: 'night-phase',
      label: 'Night Phase Transition',
      isComplete: gameState.gamePhase === 'night' || gameState.isTransitioning, // Include transition state
      details: `Current Phase: ${gameState.gamePhase}`
    },
    {
      id: 'new-day',
      label: 'New Day Started',
      isComplete: gameState.currentDay > 1,
      details: `Current Day: ${gameState.currentDay}`
    }
  ];

  // Get completion percentage for progress bar
  const completionPercentage = criticalPathSteps.filter(step => step.isComplete).length /
                              criticalPathSteps.length * 100;

  // Only render in development
  if (process.env.NODE_ENV === 'production') return null;

  // Generate state summary for clipboard
  const generateStateSummary = () => {
    const summary = {
      gameState: {
        state: gameState.gameState, // Use state machine state
        phase: gameState.gamePhase,
        day: gameState.currentDay,
        currentNodeId: gameStore.currentNodeId, // Current node from gameStore
        completedNodes: gameState.completedNodeIds, // Completed nodes from state machine
        player: gameStore.player
      },
      journalState: {
        acquired: journalStore.hasJournal,
        tier: journalStore.currentUpgrade,
        entryCount: journalStore.entries?.length || 0 // Safe access
      },
      dialogueState: {
        active: dialogueState.isActive,
        currentNodeId: dialogueState.currentNodeId // Use state machine's node ID
      },
      knowledgeState: {
        totalMastery: knowledgeStore.totalMastery,
        discoveredNodes: knowledgeStore.nodes.filter(n => n.discovered).length,
        totalNodes: knowledgeStore.nodes.length,
        connections: knowledgeStore.connections.length
      },
      criticalPath: {
        progress: `${criticalPathSteps.filter(step => step.isComplete).length}/${criticalPathSteps.length}`,
        percentage: completionPercentage.toFixed(0) + '%',
        missingSteps: criticalPathSteps.filter(step => !step.isComplete).map(step => step.id)
      },
      environment: {
        timestamp: new Date().toISOString(),
        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'server'
      }
    };

    return JSON.stringify(summary, null, 2);
  };

  // Copy state summary to clipboard
  const copyStateSummary = () => {
    const summary = generateStateSummary();
    navigator.clipboard.writeText(summary);
    setCopiedFeedback(true);
    setTimeout(() => setCopiedFeedback(false), 2000);
    addConsoleMessage('📋 Copied state summary to clipboard');
  };

  // Force critical progression (for debugging)
  const forceGiveJournal = () => {
    if (!journalStore.hasJournal) {
      journalStore.initializeJournal('technical');
      addConsoleMessage('🔧 DEBUG: Forced journal acquisition');
    }
  };

  const forceNightPhase = () => {
    if (gameState.gamePhase === 'day') {
      gameState.beginDayCompletion(); // Use the state machine method
      addConsoleMessage('🔧 DEBUG: Initiated day completion');
    }
  };

  const forceNewDay = () => {
    if (gameState.gamePhase === 'night') {
      gameState.beginNightCompletion(); // Use the state machine method
      addConsoleMessage('🔧 DEBUG: Initiated night completion');
    }
  };

  const resetGame = () => {
    try {
      localStorage.removeItem('rogue-resident-game-v2'); // Use updated key
      localStorage.removeItem('rogue-resident-journal');
      localStorage.removeItem('rogue-resident-knowledge');
      // Also reset the state machine
      if ((window as any).__GAME_STATE_MACHINE_DEBUG__) {
          (window as any).__GAME_STATE_MACHINE_DEBUG__.reset();
      }
      window.location.reload();
    } catch (e) {
        console.error("Error resetting game:", e);
        addConsoleMessage('❌ Error resetting game state.');
    }
  };

  const forceKnowledgeGain = () => {
    try {
        // Award some knowledge to radiation-dosimetry concept
        knowledgeStore.updateMastery('radiation-dosimetry', 15);
        knowledgeStore.discoverConcept('radiation-dosimetry');
        addConsoleMessage('🔧 DEBUG: Added 15% mastery to radiation-dosimetry');
    } catch (e) {
        console.error("Error forcing knowledge gain:", e);
        addConsoleMessage('❌ Error adding knowledge.');
    }
  };

  // Toggle section visibility
  const toggleSection = (section: keyof typeof sections) => {
    setSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };

  return (
    <div
      className="fixed top-1/2 right-0 transform -translate-y-1/2 bg-gray-900/90 text-white z-[10000] rounded-l-lg shadow-xl overflow-hidden transition-all duration-300" // Increased z-index
      style={{
        width: isExpanded ? '350px' : '40px',
        height: isExpanded ? '550px' : '160px',
        maxHeight: '80vh'
      }}
    >
      {/* Header with toggle */}
      <div
        className="py-2 px-3 bg-blue-600 flex justify-between items-center cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        {isExpanded ? (
          <>
            <span className="font-semibold">Vertical Slice Debugger</span>
            <span>×</span>
          </>
        ) : (
          <span
            style={{
              writingMode: 'vertical-rl',
              textOrientation: 'mixed',
              transform: 'rotate(180deg)',
              width: '100%',
              textAlign: 'center'
            }}
          >
            VS Debug
          </span>
        )}
      </div>

      {/* Expanded content */}
      {isExpanded && (
        <div className="flex flex-col h-full">
          {/* Tab navigation */}
          <div className="flex border-b border-gray-700">
            <button
              className={`px-4 py-1 ${activeTab === 'overview' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}
              onClick={() => setActiveTab('overview')}
            >
              Overview
            </button>
            <button
              className={`px-4 py-1 ${activeTab === 'events' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}
              onClick={() => setActiveTab('events')}
            >
              Events
            </button>
            <button
              className={`px-4 py-1 ${activeTab === 'state' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}
              onClick={() => setActiveTab('state')}
            >
              State
            </button>
            <button
              className={`px-4 py-1 ${activeTab === 'tools' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}
              onClick={() => setActiveTab('tools')}
            >
              Tools
            </button>
          </div>

          {/* Tab content container */}
          <div className="flex-grow overflow-y-auto">
            {/* OVERVIEW TAB */}
            {activeTab === 'overview' && (
              <div className="p-3">
                {/* Progress overview */}
                <div
                  className="px-3 py-2 bg-gray-800 mb-4 rounded"
                  onClick={() => toggleSection('criticalPath')}
                >
                  <div className="flex justify-between items-center mb-1 cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.criticalPath ? '▼' : '►'}</span>
                      Critical Path Progress
                    </div>
                    <div className="text-xs text-gray-400">
                      {criticalPathSteps.filter(step => step.isComplete).length}/{criticalPathSteps.length}
                    </div>
                  </div>

                  <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
                    <div
                      className="h-full bg-blue-500"
                      style={{ width: `${completionPercentage}%` }}
                    ></div>
                  </div>

                  {/* Critical path steps */}
                  {sections.criticalPath && (
                    <div className="space-y-2 mt-3">
                      {criticalPathSteps.map((step, index) => (
                        <div key={step.id} className="relative">
                          {/* Step connection line */}
                          {index < criticalPathSteps.length - 1 && (
                            <div
                              className="absolute left-[12px] top-[24px] w-[2px] h-[28px]"
                              style={{
                                backgroundColor: step.isComplete ? '#4ade80' : '#6b7280',
                                opacity: step.isComplete ? 1 : 0.5
                              }}
                            ></div>
                          )}

                          {/* Step indicator */}
                          <div className="flex items-start">
                            <div
                              className="w-6 h-6 rounded-full flex items-center justify-center flex-shrink-0 mt-1"
                              style={{
                                backgroundColor: step.isComplete ? '#4ade80' : '#6b7280',
                                opacity: step.isComplete ? 1 : 0.5
                              }}
                            >
                              {step.isComplete ? '✓' : index + 1}
                            </div>
                            <div className="ml-3">
                              <div
                                className="font-medium"
                                style={{
                                  color: step.isComplete ? '#4ade80' : '#d1d5db',
                                  opacity: step.isComplete ? 1 : 0.8
                                }}
                              >
                                {step.label}
                              </div>
                              <div className="text-xs text-gray-400 mt-1">
                                {step.details}
                              </div>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>

                {/* Game state display */}
                <div
                  className="px-3 py-2 bg-gray-800 mb-3 rounded"
                  onClick={() => toggleSection('playerState')}
                >
                  <div className="flex justify-between items-center cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.playerState ? '▼' : '►'}</span>
                      Game State
                    </div>
                    <div className="px-2 py-0.5 text-xs rounded" style={{
                      backgroundColor:
                        gameState.gamePhase === 'day' ? 'rgba(59, 130, 246, 0.5)' :
                        gameState.gamePhase === 'night' ? 'rgba(124, 58, 237, 0.5)' :
                        'rgba(209, 213, 219, 0.2)'
                    }}>
                      {gameState.gamePhase}
                    </div>
                  </div>

                  {sections.playerState && (
                    <div className="mt-2 text-xs space-y-1 bg-gray-900 p-2 rounded">
                       <div className="flex justify-between">
                        <span className="text-gray-400">Game State:</span>
                        <span>{gameState.gameState}</span>
                      </div>
                       <div className="flex justify-between">
                        <span className="text-gray-400">Current Day:</span>
                        <span>{gameState.currentDay}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Player Health:</span>
                        <span>{gameStore.player.health}/{gameStore.player.maxHealth}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Insight:</span>
                        <span>{gameStore.player.insight}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Momentum:</span>
                        <span>{gameStore.player.momentum}/{gameStore.player.maxMomentum}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Selected Node:</span>
                        <span className="truncate max-w-[160px]">{gameStore.currentNodeId || 'none'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Completed Nodes:</span>
                        <span>{gameState.completedNodeIds.length}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Inventory Items:</span>
                        <span>{gameStore.inventory.length}</span>
                      </div>
                    </div>
                  )}
                </div>

                {/* Journal state section */}
                <div
                  className="px-3 py-2 bg-gray-800 mb-3 rounded"
                  onClick={() => toggleSection('journalState')}
                >
                  <div className="flex justify-between items-center cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.journalState ? '▼' : '►'}</span>
                      Journal State
                    </div>
                    <div className="px-2 py-0.5 text-xs rounded" style={{
                      backgroundColor: journalStore.hasJournal ? 'rgba(16, 185, 129, 0.5)' : 'rgba(239, 68, 68, 0.5)'
                    }}>
                      {journalStore.hasJournal ? 'Acquired' : 'Missing'}
                    </div>
                  </div>

                  {sections.journalState && journalStore.hasJournal && (
                    <div className="mt-2 text-xs space-y-1 bg-gray-900 p-2 rounded">
                      <div className="flex justify-between">
                        <span className="text-gray-400">Journal Tier:</span>
                        <span>{journalStore.currentUpgrade}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Entries:</span>
                        <span>{journalStore.entries?.length || 0}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Opened:</span>
                        <span>{journalStore.isOpen ? 'Yes' : 'No'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Current Page:</span>
                        <span>{journalStore.currentPage}</span>
                      </div>
                      {journalStore.hasKapoorReferenceSheets && (
                        <div className="text-green-400">Has Kapoor reference sheets</div>
                      )}
                      {journalStore.hasKapoorAnnotatedNotes && (
                        <div className="text-green-400">Has Kapoor annotated notes</div>
                      )}
                    </div>
                  )}
                </div>

                {/* Knowledge state summary */}
                <div className="px-3 py-2 bg-gray-800 mb-3 rounded">
                  <div className="flex justify-between items-center">
                    <div className="text-sm font-medium">Knowledge State</div>
                    <div className="px-2 py-0.5 text-xs bg-purple-500/50 rounded">
                      {knowledgeStore.totalMastery}% Mastery
                    </div>
                  </div>

                  <div className="mt-2 text-xs space-y-1">
                    <div className="flex justify-between">
                      <span className="text-gray-400">Discovered:</span>
                      <span>{knowledgeStore.nodes.filter(n => n.discovered).length}/{knowledgeStore.nodes.length}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Connections:</span>
                      <span>{knowledgeStore.connections.length}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Newly Discovered:</span>
                      <span>{knowledgeStore.newlyDiscovered.length}</span>
                    </div>
                  </div>
                </div>

                {/* Copy state button */}
                <button
                  className={`w-full py-2 px-3 rounded text-sm font-medium mb-3 ${
                    copiedFeedback
                      ? 'bg-green-500 text-white'
                      : 'bg-blue-600 hover:bg-blue-500 text-white'
                  }`}
                  onClick={copyStateSummary}
                >
                  {copiedFeedback ? 'Copied to Clipboard!' : 'Copy State Summary'}
                </button>
              </div>
            )}

            {/* EVENTS TAB */}
            {activeTab === 'events' && (
              <div className="p-3">
                <div className="flex justify-between items-center mb-3">
                  <div className="text-sm font-medium">Event Console</div>
                  <button
                    className="px-2 py-0.5 bg-gray-700 hover:bg-gray-600 text-xs rounded"
                    onClick={() => setConsoleOutput([])}
                  >
                    Clear
                  </button>
                </div>

                {/* Console output */}
                <div className="bg-gray-900 p-2 rounded text-xs font-mono h-[410px] overflow-y-auto mb-3">
                  {consoleOutput.length === 0 ? (
                    <div className="text-gray-500 italic">No events logged yet</div>
                  ) : (
                    consoleOutput.map((message, idx) => (
                      <div key={idx} className="mb-1 break-all">{message}</div>
                    ))
                  )}
                  <div ref={eventsEndRef} />
                </div>

                <div className="text-xs text-gray-400">
                  Recent critical events are logged here automatically.
                </div>
              </div>
            )}

            {/* STATE TAB */}
            {activeTab === 'state' && (
              <div className="p-3">
                <div className="text-sm font-medium mb-3">State Details</div>

                {/* Dialogue state */}
                <div
                  className="px-3 py-2 bg-gray-800 mb-3 rounded"
                  onClick={() => toggleSection('dialogueState')}
                >
                  <div className="flex justify-between items-center cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.dialogueState ? '▼' : '►'}</span>
                      Dialogue System
                    </div>
                    <div className="px-2 py-0.5 text-xs rounded" style={{
                      backgroundColor: dialogueState.isActive ? 'rgba(16, 185, 129, 0.5)' : 'rgba(209, 213, 219, 0.2)'
                    }}>
                      {dialogueState.isActive ? 'Active' : 'Inactive'}
                    </div>
                  </div>

                  {sections.dialogueState && dialogueState.isActive && (
                    <div className="mt-2 text-xs space-y-1 bg-gray-900 p-2 rounded">
                      <div className="flex justify-between">
                        <span className="text-gray-400">Current State ID:</span>
                        <span className="truncate max-w-[160px]">{dialogueState.currentNodeId || 'unknown'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Flow ID:</span>
                        <span className="truncate max-w-[160px]">
                          {dialogueState.activeFlow?.id || 'unknown'}
                        </span>
                      </div>
                      {dialogueState.selectedOption && (
                        <div className="flex justify-between">
                          <span className="text-gray-400">Selected Option:</span>
                          <span>{dialogueState.selectedOption.id}</span>
                        </div>
                      )}
                      <div className="flex justify-between">
                        <span className="text-gray-400">Showing Response:</span>
                        <span>{dialogueState.showResponse ? 'Yes' : 'No'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Showing Backstory:</span>
                        <span>{dialogueState.showBackstory ? 'Yes' : 'No'}</span>
                      </div>
                    </div>
                  )}
                </div>

                {/* Domain mastery details */}
                <div className="px-3 py-2 bg-gray-800 mb-3 rounded">
                  <div className="flex justify-between items-center mb-2">
                    <div className="text-sm font-medium">Domain Mastery</div>
                    <div className="px-2 py-0.5 text-xs bg-purple-500/50 rounded">
                      {knowledgeStore.totalMastery}%
                    </div>
                  </div>

                  {/* Domain bars */}
                  {Object.entries(knowledgeStore.domainMastery).map(([domain, mastery]) => (
                    <div key={domain} className="mb-2">
                      <div className="flex justify-between text-xs mb-1">
                        <span>{domain}</span>
                        <span>{mastery}%</span>
                      </div>
                      <div className="w-full h-1.5 bg-gray-700 rounded-full overflow-hidden">
                        <div
                          className="h-full rounded-full"
                          style={{
                            width: `${mastery}%`,
                            backgroundColor: getDomainColor(domain as KnowledgeDomain)
                          }}
                        ></div>
                      </div>
                    </div>
                  ))}
                </div>

                {/* Local storage info */}
                <div className="px-3 py-2 bg-gray-800 mb-3 rounded">
                  <div className="text-sm font-medium mb-2">Local Storage</div>
                  <div className="text-xs space-y-1">
                    <div className="flex justify-between">
                      <span className="text-gray-400">Game Store:</span>
                      {/* *** FIX APPLIED HERE *** */}
                      <span>{checkLocalStorage('rogue-resident-game-v2')}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Journal Store:</span>
                      <span>{checkLocalStorage('rogue-resident-journal')}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Knowledge Store:</span>
                      <span>{checkLocalStorage('rogue-resident-knowledge')}</span>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* TOOLS TAB */}
            {activeTab === 'tools' && (
              <div className="p-3">
                <div className="text-sm font-medium mb-3">Debug Tools</div>

                {/* Debug actions */}
                <div
                  className="px-3 py-2 bg-gray-800 mb-3 rounded"
                  onClick={() => toggleSection('tools')}
                >
                  <div className="flex justify-between items-center cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.tools ? '▼' : '►'}</span>
                      Game Actions
                    </div>
                  </div>

                  {sections.tools && (
                    <div className="grid grid-cols-2 gap-2 mt-3">
                      <button
                        className="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-500 disabled:opacity-50"
                        onClick={forceGiveJournal}
                        disabled={journalStore.hasJournal}
                      >
                        Give Journal
                      </button>

                      <button
                        className="px-2 py-1 bg-purple-600 text-white text-xs rounded hover:bg-purple-500 disabled:opacity-50"
                        onClick={forceNightPhase}
                        disabled={gameState.gamePhase !== 'day'}
                      >
                        Night Phase
                      </button>

                      <button
                        className="px-2 py-1 bg-yellow-600 text-white text-xs rounded hover:bg-yellow-500 disabled:opacity-50"
                        onClick={forceNewDay}
                        disabled={gameState.gamePhase !== 'night'}
                      >
                        New Day
                      </button>

                      <button
                        className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-500"
                        onClick={forceKnowledgeGain}
                      >
                        Add Knowledge
                      </button>

                      <button
                        className="px-2 py-1 bg-indigo-600 text-white text-xs rounded hover:bg-indigo-500"
                        onClick={() => gameStore.updateInsight(10)}
                      >
                        +10 Insight
                      </button>

                      <button
                        className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-500"
                        onClick={resetGame}
                      >
                        Reset Game
                      </button>
                    </div>
                  )}
                </div>

                {/* Advanced debugging tools */}
                <div className="px-3 py-2 bg-gray-800 mb-3 rounded">
                  <div className="text-sm font-medium mb-2">Advanced Tools</div>

                  <div className="space-y-2">
                    <button
                      className="w-full px-2 py-1 bg-gray-700 text-white text-xs rounded hover:bg-gray-600 text-left"
                      onClick={() => {
                        // Force a completion of all critical path steps
                        if (!journalStore.hasJournal) {
                          journalStore.initializeJournal('technical');
                        }

                        // Ensure a node is completed
                        if (gameState.completedNodeIds.length === 0 && kapoorNodeId) {
                           gameState.markNodeCompleted(kapoorNodeId); // Use state machine method
                        }

                        addConsoleMessage('🔧 Force-completed critical path steps');
                      }}
                    >
                      Force Critical Path Completion
                    </button>

                    <button
                      className="w-full px-2 py-1 bg-gray-700 text-white text-xs rounded hover:bg-gray-600 text-left"
                      onClick={() => {
                        // Open the browser console
                        console.group('%c🔍 Debug State Dump', 'font-size: 14px; font-weight: bold; color: #3b82f6;');
                        console.log('Game State Machine:', gameState);
                        console.log('Game Store:', gameStore);
                        console.log('Journal Store:', journalStore);
                        console.log('Knowledge Store:', knowledgeStore);
                        console.log('Dialogue State Machine:', dialogueState);
                        console.groupEnd();

                        addConsoleMessage('🔍 Dumped state objects to browser console');
                      }}
                    >
                      Dump State to Console
                    </button>

                     <button
                      className="w-full px-2 py-1 bg-gray-700 text-white text-xs rounded hover:bg-gray-600 text-left"
                      onClick={() => {
                        // Check if recovery functions are available via window object
                         if (typeof window !== 'undefined' && (window as any).__GAME_STATE_MACHINE_DEBUG__) {
                          try {
                            const result = (window as any).__GAME_STATE_MACHINE_DEBUG__.checkForStuckTransitions();
                            addConsoleMessage(`🔧 Stuck transition check: ${result ? 'Recovery attempted' : 'No issues found'}`);
                          } catch (e) {
                            addConsoleMessage(`❌ Error checking for stuck transitions: ${e}`);
                          }
                        } else {
                          addConsoleMessage('❌ State machine debug tools not available');
                        }
                      }}
                    >
                      Check for Stuck Transitions
                    </button>
                  </div>
                </div>

                <div className="text-xs text-gray-400">
                  These tools directly modify game state and may cause unexpected behavior.
                  Use them only for debugging and testing.
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
==== END: app/components/debug/VerticalSliceDebugPanel.tsx ====

==== START: app/components/HillHomeScene.tsx ====
'use client';
import React, { useState, useEffect, useRef } from 'react';
import { useGameStore } from '../store/gameStore';
import { useKnowledgeStore } from '../store/knowledgeStore';
import { PixelText, PixelButton } from './PixelThemeProvider';
import { useGameState } from '../core/statemachine/GameStateMachine';
import ConstellationView from './knowledge/ConstellationView';
import { useEventBus } from '../core/events/CentralEventBus';
import { GameEventType } from '../core/events/EventTypes';


/**
 * HillHomeScene - Simplified night phase component
 * 
 * A more straightforward implementation with better error handling
 * and visual feedback to ensure users can always progress.
 */
export default function HillHomeScene({ onComplete }) {
  // Core game state
  const { player, inventory, currentDay, updateInsight } = useGameStore();
  const { gamePhase } = useGameState();
  
  // Knowledge state
  const { pendingInsights, totalMastery, domainMastery, transferInsights, resetNewlyDiscovered, newlyDiscovered } = useKnowledgeStore();
  
  // Component state
  const [showInventory, setShowInventory] = useState(false);
  const [showConstellation, setShowConstellation] = useState(false);
  const [insightTransferred, setInsightTransferred] = useState(false);
  const [renderCount, setRenderCount] = useState(0);
  const [hasStartedInsightTransfer, setHasStartedInsightTransfer] = useState(false);
  
  // Mount tracking
  const mounted = useRef(true);
  
  // Track renders for debugging
  useEffect(() => {
    setRenderCount(prev => prev + 1);
    console.log(`[HillHomeScene] Render #${renderCount + 1}`);
    
    // Log critical debug info
    console.log('[HillHomeScene] Current game phase:', gamePhase);
    console.log('[HillHomeScene] Has pending insights:', pendingInsights.length);
    console.log('[HillHomeScene] Newly discovered concepts:', newlyDiscovered.length);
  }, [gamePhase, pendingInsights.length, newlyDiscovered.length]);
  
  // Set up mount/unmount tracking
  useEffect(() => {
    // Log when component mounts
    console.log('[HillHomeScene] Component mounted');
    mounted.current = true;
    
    // Notify event system that night phase has started
    try {
      useEventBus.getState().dispatch(
        GameEventType.GAME_PHASE_CHANGED,
        {
          from: 'transition_to_night',
          to: 'night',
          reason: 'hill_home_mounted'
        },
        'HillHomeScene'
      );
    } catch (e) {
      console.warn('[HillHomeScene] Event dispatch failed:', e);
    }
    
    return () => {
      mounted.current = false;
      console.log('[HillHomeScene] Component unmounted');
    };
  }, []);
  
  // Handle insight transfer with improved error handling
  useEffect(() => {
    if (!mounted.current) return;
    
    // Only start transfer if we haven't already and we have insights to transfer
    if (!hasStartedInsightTransfer && !insightTransferred && pendingInsights.length > 0) {
      console.log('[HillHomeScene] Starting insight transfer process');
      setHasStartedInsightTransfer(true);
      
      // Start transfer after a delay
      const timer = setTimeout(() => {
        if (!mounted.current) return;
        
        try {
          console.log('[HillHomeScene] Executing insight transfer');
          
          // Calculate total insight gain
          const totalInsightGain = pendingInsights.reduce((total, insight) => {
            return total + insight.amount;
          }, 0);
          
          // Grant insight points
          updateInsight(totalInsightGain);
          
          // Actually transfer insights in the knowledge store
          transferInsights();
          
          // Update state
          setInsightTransferred(true);
          
          // Log insight transfer for debugging
          console.log('[HillHomeScene] Insight transfer complete:', {
            insightsTransferred: pendingInsights.length,
            totalGain: totalInsightGain
          });
          
          // Automatically open constellation view after a delay
          if (newlyDiscovered.length > 0) {
            setTimeout(() => {
              if (mounted.current) {
                setShowConstellation(true);
              }
            }, 1000);
          }
          
        } catch (error) {
          console.error('[HillHomeScene] Error during insight transfer:', error);
          // Still mark as transferred so player can continue
          setInsightTransferred(true);
        }
      }, 1500); // Reduced delay for better responsiveness
      
      return () => clearTimeout(timer);
    }
  }, [
    hasStartedInsightTransfer, 
    insightTransferred, 
    pendingInsights, 
    updateInsight, 
    transferInsights,
    newlyDiscovered
  ]);
  
  // Handle clean-up of newly discovered state when leaving
  useEffect(() => {
    return () => {
      // Reset newly discovered state when component unmounts
      if (newlyDiscovered.length > 0) {
        try {
          console.log('[HillHomeScene] Resetting newly discovered on unmount');
          resetNewlyDiscovered();
        } catch (e) {
          console.warn('[HillHomeScene] Failed to reset newly discovered:', e);
        }
      }
    };
  }, [newlyDiscovered, resetNewlyDiscovered]);
  
  // Handle starting the next day
  const handleStartDay = () => {
    // Ensure insights are transferred
    if (!insightTransferred && pendingInsights.length > 0) {
      try {
        // Force transfer insights if not done yet
        transferInsights();
        console.log('[HillHomeScene] Forced insight transfer before day start');
      } catch (e) {
        console.warn('[HillHomeScene] Error during forced insight transfer:', e);
      }
    }
    
    // Close constellation if open
    setShowConstellation(false);
    
    // Reset newly discovered
    if (newlyDiscovered.length > 0) {
      resetNewlyDiscovered();
    }
    
    // Log button click
    console.log('[HillHomeScene] Starting next day (Day ' + (currentDay + 1) + ')');
    
    // Complete night phase
    onComplete();
  };
  
  // Get concept color helper
  const getConceptColor = (conceptId) => {
    // Map concept to domain colors
    const conceptDomains = {
      'electron-equilibrium': '#3b82f6', // Blue - radiation physics
      'radiation-dosimetry': '#3b82f6',
      'inverse-square-law': '#3b82f6',
      'output-calibration': '#10b981', // Green - quality assurance
      'tolerance-limits': '#10b981',
      'dosimetry-principles': '#10b981',
      'clinical-dose-significance': '#ec4899', // Pink - clinical practice
      'treatment-planning': '#ec4899',
      'radiation-safety': '#f59e0b', // Amber - radiation protection
      'alara-principle': '#f59e0b',
      'general': '#6b7280', // Gray - general
    };
    
    return conceptDomains[conceptId] || '#8b5cf6'; // Default to purple
  };

  return (
    <div className="fixed inset-0 bg-black p-4 flex flex-col items-center justify-center overflow-auto">
      {/* Starfield background - simplified with inline styles */}
      <div 
        className="fixed inset-0 z-0" 
        style={{
          background: '#000',
          backgroundImage: 'radial-gradient(2px 2px at 20px 30px, #fff, rgba(0,0,0,0)), radial-gradient(2px 2px at 40px 70px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 90px 40px, #fff, rgba(0,0,0,0))',
          backgroundSize: '200px 200px',
          opacity: 0.7
        }}
      />
      
      {/* Emergency night phase indicator - always visible */}
      <div className="fixed top-0 left-0 m-4 bg-purple-800 text-white px-3 py-1 z-50 text-sm rounded">
        Night Phase - Day {currentDay}
      </div>
      
      {/* Emergency continue button - always visible at bottom */}
      <div className="fixed bottom-8 right-8 z-50">
        <button
          className="px-6 py-3 bg-purple-700 hover:bg-purple-600 text-white font-medium rounded-lg shadow-lg"
          onClick={handleStartDay}
        >
          Continue to Day {currentDay + 1} →
        </button>
      </div>
      
      {/* Main content area */}
      <div className="relative z-10 w-full max-w-4xl">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-3xl font-pixel text-white mb-2">Night at Hill Home</h1>
          <p className="text-blue-300 text-lg">Time to reflect on your knowledge</p>
        </div>
        
        {/* Main content grid */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
          {/* Constellation card */}
          <div 
            className="col-span-3 bg-gray-900 border border-purple-800 rounded-lg p-6 flex flex-col items-center justify-center min-h-[180px] hover:bg-gray-800 transition cursor-pointer"
            onClick={() => setShowConstellation(true)}
          >
            <div className="text-4xl mb-3">✨</div>
            <h2 className="text-xl font-pixel text-white mb-1">Knowledge Constellation</h2>
            <p className="text-gray-400 text-sm text-center">
              Explore your growing understanding of medical physics
            </p>
            {newlyDiscovered.length > 0 && (
              <div className="mt-3 px-3 py-1 bg-purple-600 text-white text-sm animate-pulse rounded">
                {newlyDiscovered.length} new concept{newlyDiscovered.length !== 1 ? 's' : ''} discovered!
              </div>
            )}
          </div>
          
          {/* Inventory card */}
          <div 
            className="bg-gray-900 border border-blue-800 rounded-lg p-6 flex flex-col items-center justify-center min-h-[180px] hover:bg-gray-800 transition cursor-pointer"
            onClick={() => setShowInventory(true)}
          >
            <div className="text-4xl mb-3">🎒</div>
            <h2 className="text-lg font-pixel text-white mb-1">Inventory</h2>
            <div className="mt-2 px-3 py-1 bg-gray-700 text-white text-sm">
              {inventory.length} Items
            </div>
          </div>
          
          {/* Return to hospital card */}
          <div 
            className="col-span-2 bg-gray-900 border border-blue-800 rounded-lg p-6 flex flex-col items-center justify-center min-h-[180px] hover:bg-gray-800 transition cursor-pointer"
            onClick={handleStartDay}
          >
            <div className="text-4xl mb-3">🏥</div>
            <h2 className="text-xl font-pixel text-white mb-1">Return to Hospital</h2>
            <div className="mt-2 px-3 py-1 bg-blue-600 text-white text-sm">
              Begin Day {currentDay + 1}
            </div>
          </div>
        </div>
        
        {/* Status area */}
        <div className="bg-gray-900 border border-gray-700 rounded-lg p-4">
          <div className="flex justify-between items-center mb-3">
            <h2 className="text-lg font-pixel text-white">Player Status</h2>
            <div className="flex space-x-3">
              <span className="px-2 py-1 bg-red-600 text-white text-sm rounded">
                Health: {player.health}/{player.maxHealth}
              </span>
              <span className="px-2 py-1 bg-blue-600 text-white text-sm rounded">
                Insight: {player.insight}
              </span>
            </div>
          </div>
          
          <div className="mb-2">
            <div className="text-gray-400 mb-1 text-sm">Knowledge Mastery</div>
            <div className="w-full h-2 bg-gray-800 rounded-full overflow-hidden">
              <div 
                className="h-full bg-purple-600" 
                style={{ width: `${totalMastery}%` }}
              />
            </div>
          </div>
          
          <div className="text-xs text-gray-400 flex justify-between">
            <span>Clinical: {domainMastery['clinical-practice'] || 0}%</span>
            <span>Technical: {domainMastery['quality-assurance'] || 0}%</span>
            <span>Theory: {domainMastery['theoretical'] || 0}%</span>
          </div>
        </div>
      </div>
      
      {/* Insight transfer effect */}
      {hasStartedInsightTransfer && !insightTransferred && pendingInsights.length > 0 && (
        <div className="fixed inset-0 z-20 pointer-events-none">
          <div className="absolute inset-0 bg-purple-900/10 animate-pulse" />
          {pendingInsights.map((insight, index) => (
            <div 
              key={`insight-${index}`}
              className="absolute w-2 h-2 rounded-full animate-float-up"
              style={{
                backgroundColor: getConceptColor(insight.conceptId),
                left: `${20 + Math.random() * 60}%`,
                top: `${70 + Math.random() * 20}%`,
                animationDelay: `${index * 0.2}s`,
                opacity: 0.8
              }}
            />
          ))}
        </div>
      )}
      
      {/* Inventory panel */}
      {showInventory && (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-30">
          <div className="bg-gray-900 border border-blue-700 rounded-lg p-6 max-w-md w-full">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-pixel text-white">Inventory</h2>
              <button 
                className="bg-red-600 hover:bg-red-500 text-white px-3 py-1 rounded"
                onClick={() => setShowInventory(false)}
              >
                Close
              </button>
            </div>
            
            <div className="space-y-3 max-h-80 overflow-y-auto">
              {inventory && inventory.length > 0 ? (
                inventory.map((item, index) => (
                  <div key={index} className="bg-gray-800 p-3 rounded">
                    <div className="flex justify-between">
                      <div className="font-medium text-white">{item.name}</div>
                      <div className="text-sm text-gray-400">{item.rarity}</div>
                    </div>
                    <div className="text-sm text-gray-300 mt-1">{item.description}</div>
                  </div>
                ))
              ) : (
                <div className="text-center py-8 text-gray-400">
                  <p>No items collected yet</p>
                  <p className="text-xs mt-2">Visit storage closets in the hospital to find equipment</p>
                </div>
              )}
            </div>
          </div>
        </div>
      )}
      
      {/* Constellation view */}
      {showConstellation && (
        <div className="fixed inset-0 bg-black/95 z-30">
          <ConstellationView
            nightMode={true}
            showLabels={true}
            interactive={true}
            activeNodes={newlyDiscovered}
            onClose={() => setShowConstellation(false)}
          />
        </div>
      )}
      
      {/* Debug info */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="fixed bottom-0 left-0 bg-black/80 text-white text-xs font-mono z-50 p-2 max-w-xs">
          <div>Phase: {gamePhase}</div>
          <div>Day: {currentDay}</div>
          <div>Insights: {pendingInsights.length}</div>
          <div>Transferred: {insightTransferred ? 'Yes' : 'No'}</div>
          <div>New Concepts: {newlyDiscovered.length}</div>
          <div>Renders: {renderCount}</div>
        </div>
      )}
      
      {/* Required CSS animations */}
      <style jsx>{`
        @keyframes float-up {
          0% { transform: translateY(0); opacity: 0.8; }
          100% { transform: translateY(-50vh); opacity: 0; }
        }
        
        .animate-float-up {
          animation: float-up 3s forwards ease-out;
        }
        
        @keyframes pulse {
          0%, 100% { opacity: 0.5; }
          50% { opacity: 0.8; }
        }
        
        .animate-pulse {
          animation: pulse 2s ease-in-out infinite;
        }
      `}</style>
    </div>
  );
}
==== END: app/components/HillHomeScene.tsx ====

==== START: app/components/PlayerStats.tsx ====
'use client';
import { useEffect, useState } from 'react';
import { useGameStore } from '@/app/store/gameStore';
import { useGameState } from '@/app/core/statemachine/GameStateMachine';
import { useKnowledgeStore } from '@/app/store/knowledgeStore';
import { useJournalStore } from '@/app/store/journalStore';
import InsightMeter from './gameplay/InsightMeter';
import MomentumCounter from './gameplay/MomentumCounter';
import ResidentPortrait from './ResidentPortrait';
import { motion, AnimatePresence } from 'framer-motion';
import { PixelBox, PixelButton } from './PixelThemeProvider';

/**
 * PlayerStats - Enhanced player stats sidebar with character representation
 * 
 * This component creates a cohesive "character sheet" that reinforces the game's
 * knowledge acquisition loop through visual design and clear information hierarchy.
 */
export default function PlayerStats() {
  // Global state
  const { player, currentNodeId } = useGameStore();
  const { gamePhase, dayCount } = useGameState();
  const { totalMastery, newlyDiscovered } = useKnowledgeStore();
  const { hasJournal, currentUpgrade, toggleJournal } = useJournalStore();
  
  // Local state for animations
  const [showInsightAnimation, setShowInsightAnimation] = useState(false);
  const [showJournalButtonAnimation, setShowJournalButtonAnimation] = useState(false);
  
  // Determine when to use full body portrait
  const shouldShowFullBody = 
    gamePhase === 'night' || // Always show full body at night
    (!currentNodeId && gamePhase === 'day'); // Show full body on the map screen
  
  // Animate insight changes
  useEffect(() => {
    if (player.insight > 50 && !showInsightAnimation) {
      setShowInsightAnimation(true);
      
      // Reset animation after delay
      const timer = setTimeout(() => {
        setShowInsightAnimation(false);
      }, 2000);
      
      return () => clearTimeout(timer);
    }
  }, [player.insight, showInsightAnimation]);
  
  // Show journal button animation when journal is first acquired
  useEffect(() => {
    if (hasJournal) {
      setShowJournalButtonAnimation(true);
      const timer = setTimeout(() => {
        setShowJournalButtonAnimation(false);
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [hasJournal]);
  
  // Determine phase color for theming elements
  const getPhaseColor = () => {
    return gamePhase === 'day' ? 'clinical' : 'educational';
  };
  
  return (
    <div className="p-3 h-full flex flex-col space-y-3">
      {/* 1. Character Identity Block - Always visible, defines player identity */}
      <PixelBox className="p-3 flex items-center">
        <ResidentPortrait 
          showFullBody={shouldShowFullBody}
          size="md"
          className="mr-3"
        />
        <div>
          <h2 className="text-lg font-pixel">Medical Physics Resident</h2>
          <div className="flex items-center gap-2 mt-1">
            <div className={`w-2 h-2 rounded-full bg-${getPhaseColor()}-light`}></div>
            <div className="text-sm text-text-secondary font-pixel">
              Day {dayCount} | {gamePhase === 'day' ? 'Hospital' : 'Hill Home'}
            </div>
          </div>
        </div>
      </PixelBox>
      
      {/* 2. Core Resources Block - Tactical resources for challenges */}
      <div className="flex flex-col gap-3">
        {/* Insight meter */}
        <PixelBox 
          className="p-3" 
          variant={gamePhase === 'day' ? 'clinical' : 'default'}
        >
          <InsightMeter showAnimation={showInsightAnimation} />
        </PixelBox>
        
        {/* Momentum counter */}
        <PixelBox 
          className="p-3" 
          variant={player.momentum >= 2 ? 'dark' : 'default'}
        >
          <MomentumCounter 
            level={player.momentum} 
            consecutiveCorrect={player.momentum * 2} // Approximation
            compact={true} 
            className="w-full"
          />
        </PixelBox>
      </div>
      
      {/* 3. Knowledge Progression Block - Strategic long-term resources */}
      <PixelBox 
        className="p-3" 
        variant={newlyDiscovered.length > 0 ? 'educational' : 'default'}
      >
        <div className="text-sm text-text-secondary font-pixel mb-1">Knowledge Mastery</div>
        <div className="flex items-center">
          <div className={`text-${getPhaseColor()}-light text-lg font-pixel`}>
            {totalMastery}%
          </div>
          
          {/* Visual progress bar - pixel style */}
          <div className="ml-2 flex-grow h-2 bg-surface-dark rounded-none overflow-hidden">
            <motion.div 
              className={`h-full bg-${getPhaseColor()}`}
              initial={{ width: 0 }}
              animate={{ 
                width: `${totalMastery}%`,
                transition: { type: 'spring', damping: 15 }
              }}
              style={{
                backgroundImage: `url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='4' height='4' fill='%23${gamePhase === 'day' ? '4f6bbb' : '2c9287'}'/%3E%3Crect width='1' height='1' fill='%23${gamePhase === 'day' ? '2a3a66' : '1f6e66'}'/%3E%3Crect x='2' y='2' width='1' height='1' fill='%23${gamePhase === 'day' ? '2a3a66' : '1f6e66'}'/%3E%3C/svg%3E")`,
                backgroundSize: '4px 4px',
                imageRendering: 'pixelated'
              }}
            />
          </div>
        </div>
        
        {/* Newly discovered animation */}
        <AnimatePresence>
          {newlyDiscovered.length > 0 && (
            <motion.div 
              className="mt-2 text-xs text-educational font-pixel"
              initial={{ opacity: 0, y: -5 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0 }}
            >
              <div className="flex items-center">
                <div className="w-2 h-2 bg-educational-light mr-1 animate-pulse"></div>
                {newlyDiscovered.length} new concept{newlyDiscovered.length !== 1 ? 's' : ''} discovered
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </PixelBox>
      
      {/* 4. Journal Block - The tangible manifestation of knowledge */}
      <PixelBox 
        className={`p-3 ${showJournalButtonAnimation ? 'animate-pulse-subtle' : ''}`}
        variant={hasJournal ? 'clinical' : 'default'}
      >
        <div className="text-sm text-text-secondary font-pixel mb-1">Journal</div>
        {hasJournal ? (
          <div className="flex flex-col">
            <div className="text-clinical-light text-lg font-pixel">
              {currentUpgrade === 'base' && 'Basic Notebook'}
              {currentUpgrade === 'technical' && 'Technical Journal'}
              {currentUpgrade === 'annotated' && 'Annotated Journal'}
              {currentUpgrade === 'indexed' && 'Indexed Compendium'}
              {currentUpgrade === 'integrated' && 'Integrated Codex'}
            </div>
            
            {/* Add journal open button */}
            <button 
              className={`mt-2 px-3 py-1 bg-${getPhaseColor()} text-white text-sm font-pixel
                hover:bg-${getPhaseColor()}-light transition-colors
                ${showJournalButtonAnimation ? 'animate-bounce-subtle' : ''}
                pixel-button
              `}
              onClick={() => toggleJournal()}
            >
              <div className="flex items-center justify-center">
                <span className="mr-1 text-lg">📖</span>
                Open Journal
              </div>
            </button>
          </div>
        ) : (
          <div className="text-warning text-lg font-pixel">
            Not Acquired
          </div>
        )}
      </PixelBox>
      
      {/* 5. Expandable Debug Panel - Only in dev mode */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="mt-auto bg-black/30 p-2 rounded text-xs font-mono">
          <details>
            <summary className="cursor-pointer hover:text-blue-300">Debug Info</summary>
            <div className="pt-1 space-y-1">
              <div>Phase: {gamePhase}</div>
              <div>Day: {dayCount}</div>
              <div>Insight: {player.insight}</div>
              <div>Momentum: {player.momentum}/{player.maxMomentum}</div>
              <div>Node: {currentNodeId ? currentNodeId.substring(0, 8) + '...' : 'none'}</div>
            </div>
          </details>
        </div>
      )}
      
      {/* Custom animations */}
      <style jsx>{`
        @keyframes pulse-subtle {
          0%, 100% { box-shadow: 0 0 0 0 rgba(55, 145, 216, 0.4); }
          50% { box-shadow: 0 0 0 4px rgba(55, 145, 216, 0.4); }
        }
        
        @keyframes bounce-subtle {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-3px); }
        }
        
        .animate-pulse-subtle {
          animation: pulse-subtle 2s infinite;
        }
        
        .animate-bounce-subtle {
          animation: bounce-subtle 2s infinite;
        }
        
        .pixel-button {
          position: relative;
          image-rendering: pixelated;
          border: none;
          border-top: 1px solid rgba(255,255,255,0.3);
          border-left: 1px solid rgba(255,255,255,0.3);
          border-right: 1px solid rgba(0,0,0,0.2);
          border-bottom: 1px solid rgba(0,0,0,0.2);
        }
        
        .pixel-button:active {
          transform: translateY(1px);
          border-top: 1px solid rgba(0,0,0,0.2);
          border-left: 1px solid rgba(0,0,0,0.2);
          border-right: 1px solid rgba(255,255,255,0.3);
          border-bottom: 1px solid rgba(255,255,255,0.3);
        }
      `}</style>
    </div>
  );
}
==== END: app/components/PlayerStats.tsx ====

==== START: app/components/GameContainer.tsx ====
// app/components/GameContainer.tsx
// Refactored GameContainer to rely on state machine events/state
'use client';
import React, { useEffect, useState, useCallback, useRef } from 'react';
import { useGameStore } from '@/app/store/gameStore';
import { useGameState } from '@/app/core/statemachine/GameStateMachine';
import { useEventBus, useEventSubscription } from '@/app/core/events/CentralEventBus'; // Import hook
import { GameEventType } from '@/app/core/events/EventTypes';
import { useCoreInitialization } from '@/app/core/init'; // Corrected path
import SimplifiedKapoorMap from './map/SimplifiedKapoorMap';
import HillHomeScene from './HillHomeScene';
import PlayerStats from './PlayerStats';
import VerticalSliceDebugPanel from './debug/VerticalSliceDebugPanel';
import ChallengeRouter from './challenges/ChallengeRouter';
import DayNightTransition from './DayNightTransition'; // Import the presentation component

// Constants for transition visual timing
const TRANSITION_VISUAL_DURATION = 800; // Duration for the fade effect (ms)

export default function GameContainer() {
  const {
    gamePhase,
    isTransitioning, // Get transition status directly
    beginDayCompletion, // Use new methods to start transitions
    beginNightCompletion, // Use new methods to start transitions
    finalizeDayTransition, // New methods to complete transitions
    finalizeNightTransition, // New methods to complete transitions
  } = useGameState();

  const { currentNodeId, map, resetGame } = useGameStore();
  const { initialized } = useCoreInitialization(); // Only need initialized status
  const [hasError, setHasError] = useState<string | null>(null);
  const componentMountedRef = useRef(true);

  // Simplified error handling
  useEffect(() => {
    if (!initialized && !componentMountedRef.current) {
       setHasError("Core systems failed to initialize.");
    }
  }, [initialized]);

  // Track component mount status
  useEffect(() => {
    componentMountedRef.current = true;
    return () => { componentMountedRef.current = false; };
  }, []);

  // Callbacks to trigger phase transitions initiated from child components
  const handleBeginNight = useCallback(() => {
      console.log("[GameContainer] handleBeginNight called");
      beginDayCompletion(); // Initiate the day completion process
      // The state machine now handles setting the transition phase
  }, [beginDayCompletion]);

  const handleBeginDay = useCallback(() => {
      console.log("[GameContainer] handleBeginDay called");
      beginNightCompletion(); // Initiate the night completion process
      // The state machine now handles setting the transition phase
  }, [beginNightCompletion]);

  // Effect to finalize transitions after visual duration
  // This replaces the complex timeout logic previously in GameStateMachine
  useEffect(() => {
    let finalizeTimer: NodeJS.Timeout | null = null;

    if (gamePhase === 'transition_to_night') {
      console.log("[GameContainer] Scheduling night finalization");
      finalizeTimer = setTimeout(() => {
        if (componentMountedRef.current) {
            console.log("[GameContainer] Finalizing night transition");
            finalizeNightTransition();
        }
      }, TRANSITION_VISUAL_DURATION);
    } else if (gamePhase === 'transition_to_day') {
      console.log("[GameContainer] Scheduling day finalization");
       finalizeTimer = setTimeout(() => {
         if (componentMountedRef.current) {
            console.log("[GameContainer] Finalizing day transition");
            finalizeDayTransition();
         }
      }, TRANSITION_VISUAL_DURATION);
    }

    // Cleanup timer on unmount or phase change
    return () => {
      if (finalizeTimer) {
        clearTimeout(finalizeTimer);
      }
    };
  }, [gamePhase, finalizeDayTransition, finalizeNightTransition]);


  // Render logic based solely on gamePhase from useGameState
  const renderGameContent = () => {
    if (!initialized) {
      return <div className="h-full w-full flex items-center justify-center">Initializing...</div>;
    }
    if (hasError) {
      return <div className="h-full w-full flex items-center justify-center text-red-500">Error: {hasError}</div>;
    }

    // Day phase content
    if (gamePhase === 'day') {
      return currentNodeId ? <ChallengeRouter /> : <SimplifiedKapoorMap />;
    }

    // Night phase content
    if (gamePhase === 'night') {
      // Pass handleBeginDay to trigger the start of the night completion process
      return <HillHomeScene onComplete={handleBeginDay} />;
    }

    // Fallback for unexpected states (or keep transition visuals here if DayNightTransition is simple overlay)
    // If DayNightTransition handles visuals, this might just return null or the previous scene briefly.
    if (gamePhase === 'transition_to_day' || gamePhase === 'transition_to_night') {
       // Optionally show the previous scene dimmed or just rely on the overlay
        if (gamePhase === 'transition_to_night') {
             // Show map dimmed during transition to night
             return <div style={{ opacity: 0.5 }}><SimplifiedKapoorMap /></div>;
        }
         if (gamePhase === 'transition_to_day') {
             // Show hill home dimmed during transition to day
             return <div style={{ opacity: 0.5 }}><HillHomeScene onComplete={() => {}} /></div>; // Dummy onComplete
         }
    }


    return <div className="h-full w-full flex items-center justify-center">Unknown State</div>;
  };

  return (
    <div className="relative h-screen w-full bg-background flex flex-col" data-game-container data-phase={gamePhase}>
      <div className="flex-grow flex overflow-hidden">
        <div className="flex-grow relative overflow-hidden">
          <div className="absolute inset-0 overflow-auto">
            {renderGameContent()}
          </div>
        </div>
        <div className="w-64 flex-shrink-0 border-l border-gray-800 overflow-hidden flex flex-col">
          <div className="flex-1 overflow-y-auto overflow-x-hidden">
            <PlayerStats />
          </div>
        </div>
      </div>

      {/* Purely presentational transition overlay */}
      <DayNightTransition />

      <VerticalSliceDebugPanel />

      {/* Simplified Debug Info */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="fixed bottom-0 left-0 bg-black/80 text-white p-2 text-xs z-50">
          Phase: {gamePhase} | Node: {currentNodeId || 'none'} | Transitioning: {isTransitioning ? 'Yes' : 'No'}
        </div>
      )}
    </div>
  );
}
==== END: app/components/GameContainer.tsx ====

==== START: app/components/ResidentPortrait.tsx ====
'use client';
import { useState, useEffect } from 'react';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameState } from '@/app/core/statemachine/GameStateMachine';
import { useKnowledgeStore } from '@/app/store/knowledgeStore';

interface ResidentPortraitProps {
  showFullBody?: boolean;
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  showMasteryGlow?: boolean;
}

/**
 * ResidentPortrait - Renders the resident character portrait
 * 
 * Dynamically switches between headshot and full-body views based on context
 * and adds visual feedback based on knowledge mastery.
 */
export default function ResidentPortrait({ 
  showFullBody = false,
  className = '',
  size = 'md',
  showMasteryGlow = true
}: ResidentPortraitProps) {
  const { gamePhase } = useGameState();
  const { totalMastery, newlyDiscovered } = useKnowledgeStore();
  
  // Local animation states
  const [pulseEffect, setPulseEffect] = useState(false);
  
  // Apply pulse effect when new knowledge is discovered
  useEffect(() => {
    if (newlyDiscovered.length > 0) {
      setPulseEffect(true);
      
      // Clear effect after animation
      const timer = setTimeout(() => {
        setPulseEffect(false);
      }, 3000);
      
      return () => clearTimeout(timer);
    }
  }, [newlyDiscovered]);
  
  // Size variants for the portrait
  const sizeClasses = {
    sm: 'w-16 h-16',
    md: 'w-24 h-24',
    lg: 'w-32 h-32'
  };
  
  // Determine which portrait to show
  const portraitType = showFullBody ? 'full' : 'portrait';
  
  // Mastery halo color based on total knowledge mastery
  const getHaloColor = () => {
    if (totalMastery >= 75) return 'rgba(34, 197, 94, 0.4)'; // Green for high mastery
    if (totalMastery >= 50) return 'rgba(147, 51, 234, 0.4)'; // Purple for medium mastery
    if (totalMastery >= 25) return 'rgba(37, 99, 235, 0.4)'; // Blue for low mastery
    return 'rgba(37, 99, 235, 0.15)'; // Dim blue for beginning mastery
  };
  
  // Mastery halo intensity based on total knowledge mastery
  const getHaloIntensity = () => {
    if (totalMastery >= 75) return 'lg';
    if (totalMastery >= 50) return 'md';
    if (totalMastery >= 25) return 'sm';
    return 'xs';
  };
  
  return (
    <div className={`relative flex items-center justify-center ${className}`}>
      {/* Knowledge mastery halo */}
      {showMasteryGlow && (
        <div 
          className={`absolute -inset-1 rounded-full blur-${getHaloIntensity()}`}
          style={{ 
            backgroundColor: getHaloColor(),
            opacity: gamePhase === 'night' ? 0.8 : 0.4,
            zIndex: 0
          }}
        />
      )}
      
      {/* Character portrait */}
      <AnimatePresence mode="wait">
        <motion.div
          key={portraitType}
          className={`relative ${sizeClasses[size]} overflow-hidden ${
            portraitType === 'full' ? 'rounded-md' : 'rounded-full'
          }`}
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ 
            opacity: 1, 
            scale: 1,
            transition: { type: 'spring', damping: 15 }
          }}
          exit={{ opacity: 0, scale: 0.9 }}
        >
          <Image
            src={`/images/resident-${portraitType}.png`}
            alt="Medical Physics Resident"
            layout="fill"
            objectFit="cover"
            className="pixel-art"
            style={{ imageRendering: 'pixelated' }}
          />
          
          {/* Pulse effect when new knowledge is gained */}
          {pulseEffect && (
            <motion.div
              className="absolute inset-0 bg-educational"
              initial={{ opacity: 0 }}
              animate={{ 
                opacity: [0, 0.3, 0],
                transition: { repeat: 2, duration: 1 }
              }}
            />
          )}
        </motion.div>
      </AnimatePresence>
      
      {/* Day/night phase indicator */}
      <div 
        className={`absolute -bottom-1 -right-1 w-4 h-4 rounded-full border-2 border-surface
          ${gamePhase === 'day' ? 'bg-clinical' : 'bg-educational'}
        `}
      />
    </div>
  );
}
==== END: app/components/ResidentPortrait.tsx ====

==== START: app/components/map/SimplifiedKapoorMap.tsx ====
/**
 * @file app/components/map/SimplifiedKapoorMap.tsx
 * @description React component for rendering the interactive game map.
 * Includes fixes for hydration errors and potential infinite update loops.
 * (This file is unchanged from the previous version provided)
 */
'use client';

import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { useGameStore } from '@/app/store/gameStore';
import { useJournalStore } from '@/app/store/journalStore';
import { useKnowledgeStore } from '@/app/store/knowledgeStore';
import { Button } from '@/app/components/ui/button'; // Assuming shadcn Button is setup
// Import type definitions - Requires app/types/game.ts to exist
import { MapNode } from '@/app/types/game';
import CentralEventBus from '@/app/core/events/CentralEventBus';
// import { useEventSubscription } from '@/app/core/events/EventSubscriptionHooks'; // Uncomment if needed later
import { THEME_COLORS } from '@/app/core/themeConstants'; // Import theme colors

// Interface for component props
interface SimplifiedKapoorMapProps {
  onNodeSelect?: (nodeId: string) => void; // Optional callback when a node is selected
  autoSelectEnabled?: boolean; // Prop to control if a node should be auto-selected on load
}

/**
 * SimplifiedKapoorMap Component
 *
 * Renders a basic representation of the game map and handles node interactions.
 * Addresses hydration errors and potential update loops.
 */
export function SimplifiedKapoorMap({
  onNodeSelect,
  autoSelectEnabled = true, // Default autoSelect to true if not provided
}: SimplifiedKapoorMapProps) {
  // --- State Hooks ---
  const [isMounted, setIsMounted] = useState(false);
  const [mapReady, setMapReady] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // --- Zustand Store Hooks ---
  const { day, phase, mapData, selectedNodeId, selectNode, initializeMap } = useGameStore(
    useCallback((state) => ({
        day: state.day, phase: state.phase, mapData: state.mapData,
        selectedNodeId: state.selectedNodeId, selectNode: state.selectNode,
        initializeMap: state.initializeMap,
      }), [])
  );
  const hasJournal = useJournalStore(useCallback((state) => state.hasJournal, []));
  const completedNodes = useKnowledgeStore(useCallback((state) => state.completedNodes, []));

  // --- Derived State and Memos ---
  const nodes = useMemo(() => mapData?.nodes ?? [], [mapData]);

  // --- Effects ---

  // Effect 1: Set isMounted flag (for hydration fix)
  useEffect(() => { setIsMounted(true); }, []);

  // Effect 2: Initialize map data if needed
  useEffect(() => {
    if (!mapData) {
      console.log('🗺️ Initializing simplified Kapoor map (useEffect)...');
      initializeMap();
    } else {
      console.log('🗺️ Map data exists, marking as ready.');
      setMapReady(true);
    }
  }, [mapData, initializeMap]);

  // Effect 3: Mark map as ready once data/nodes are present
  useEffect(() => {
    if (mapData && nodes.length > 0) {
      console.log('🗺️ Map data loaded, nodes available. Marking map as ready.');
      setMapReady(true);
    }
  }, [mapData, nodes]);

  // Effect 4: Handle Auto-selection logic (Refined)
  useEffect(() => {
    if (isMounted && mapReady && autoSelectEnabled && !selectedNodeId && nodes.length > 0) {
      const firstAvailableNode = nodes.find(node => !completedNodes.includes(node.id));
      const targetNodeId = firstAvailableNode ? firstAvailableNode.id : nodes[0].id;
      console.log(`[Map] Attempting auto-selection. Target: ${targetNodeId}. Current selection: ${selectedNodeId}`);

      if (targetNodeId !== selectedNodeId) {
         const targetNode = nodes.find(n => n.id === targetNodeId);
         if (!targetNode) { console.warn(`[Map] Auto-select target node ${targetNodeId} not found.`); return; }
         const journalRequired = targetNode.requiresJournal ?? false;
         const requiredPhase = targetNode.phaseSpecific;
         let canSelect = true;
         if (journalRequired && !hasJournal) { console.log(`[Map] Cannot auto-select ${targetNodeId}: Journal required.`); canSelect = false; }
         if (requiredPhase && requiredPhase !== phase) { console.log(`[Map] Cannot auto-select ${targetNodeId}: Requires ${requiredPhase} phase.`); canSelect = false; }
         if(canSelect) {
            console.log(`[Map] Auto-selecting node: ${targetNodeId}`);
            selectNode(targetNodeId);
            if (onNodeSelect) { onNodeSelect(targetNodeId); }
         } else { console.log(`[Map] Auto-selection conditions not met for ${targetNodeId}.`); }
      } else { console.log(`[Map] Auto-selection skipped: Target node ${targetNodeId} is already selected.`); }
    }
  }, [ isMounted, mapReady, autoSelectEnabled, selectedNodeId, nodes, completedNodes, hasJournal, phase, selectNode, onNodeSelect ]);


  // --- Event Handlers ---
  const handleNodeClick = useCallback((nodeId: string, node: MapNode) => {
    console.log(`[Map] Node clicked: ${nodeId}`);
    const journalRequired = node.requiresJournal ?? false;
    const requiredPhase = node.phaseSpecific;
    if (journalRequired && !hasJournal) {
      console.warn(`[Map] Cannot select ${nodeId}: Journal required.`);
      CentralEventBus.emit('ui:show:toast', { message: "Requires Journal", type: "warning" }); return;
    }
    if (requiredPhase && requiredPhase !== phase) {
        console.warn(`[Map] Cannot select ${nodeId}: Only available during ${requiredPhase} phase.`);
        CentralEventBus.emit('ui:show:toast', { message: `Only available at ${requiredPhase}`, type: "warning" }); return;
    }
    if (nodeId !== selectedNodeId) {
      selectNode(nodeId);
      if (onNodeSelect) { onNodeSelect(nodeId); }
      CentralEventBus.emit('ui:button:clicked', { element: 'map_node', nodeId: nodeId });
    } else { console.log(`[Map] Node ${nodeId} is already selected.`); }
  }, [selectNode, onNodeSelect, selectedNodeId, hasJournal, phase]);


  // --- Rendering Logic ---

  // Hydration Fix: Render placeholder until mounted client-side
  if (!isMounted) {
    return ( <div className="h-full w-full flex items-center justify-center" ref={containerRef}> <div className="text-center pixel-font text-lg text-gray-400">Initializing Map...</div> </div> );
  }

  // Loading state (after mount, before map ready)
  if (!mapReady || !mapData) {
    return ( <div className="h-full w-full flex items-center justify-center bg-background" ref={containerRef}> <div className="text-center pixel-font text-lg text-gray-400 animate-pulse">Loading Map Data...</div> </div> );
  }

  // Actual map render
  return (
    <div ref={containerRef} className="relative h-full w-full overflow-hidden bg-gray-800 border-4 border-gray-600 shadow-inner" style={{ backgroundImage: `radial-gradient(${THEME_COLORS.map.gridDot} 1px, transparent 1px)`, backgroundSize: '20px 20px', }} >
      {/* Map Nodes */}
      {nodes.map((node) => {
        const isSelected = node.id === selectedNodeId;
        const isCompleted = completedNodes.includes(node.id);
        const journalRequired = node.requiresJournal ?? false;
        const requiredPhase = node.phaseSpecific;
        let isDisabled = false;
        let titleText = `Location: ${node.name}`;
        if (journalRequired && !hasJournal) { isDisabled = true; titleText += " (Requires Journal)"; }
        if (requiredPhase && requiredPhase !== phase) { isDisabled = true; titleText += ` (Available at ${requiredPhase})`; }
        const left = `${node.x ?? 50}%`; const top = `${node.y ?? 50}%`;
        return (
          <Button key={node.id} variant="ghost"
            className={` absolute transform -translate-x-1/2 -translate-y-1/2 p-2 rounded-full shadow-lg transition-all duration-200 ease-in-out border-2 ${isSelected ? 'ring-4 ring-offset-2 ring-yellow-400 scale-110 z-10' : ''} ${isCompleted ? 'border-green-500 bg-green-900 opacity-70' : 'border-blue-500 bg-blue-900'} ${isDisabled ? 'opacity-50 cursor-not-allowed filter grayscale' : 'hover:scale-105 hover:border-yellow-400 cursor-pointer'} `}
            style={{ left: left, top: top, width: '40px', height: '40px', }}
            onClick={() => !isDisabled && handleNodeClick(node.id, node)}
            disabled={isDisabled} title={titleText} >
            <span className={`block w-3 h-3 rounded-full ${isCompleted ? 'bg-green-400' : 'bg-blue-400'}`}></span>
          </Button>
        );
      })}
      {/* Selected Node Info Overlay */}
      {selectedNodeId && ( <div className="absolute bottom-4 left-4 bg-black bg-opacity-70 text-white p-2 rounded pixel-font border border-gray-500 text-sm"> Selected: {nodes.find(n => n.id === selectedNodeId)?.name ?? 'Unknown'} </div> )}
      {/* Day/Phase Info Overlay */}
      <div className="absolute top-4 right-4 bg-black bg-opacity-70 text-white p-2 rounded pixel-font border border-gray-500 text-sm"> Day: {day} | Phase: {phase} </div>
    </div>
  );
}

==== END: app/components/map/SimplifiedKapoorMap.tsx ====

==== START: app/components/challenges/ChallengeRouter.tsx ====
// app/components/challenges/ChallengeRouter.tsx
'use client';
import { useState, useEffect, useMemo } from 'react';
import { useGameStore } from '@/app/store/gameStore';
import { useJournalStore } from '@/app/store/journalStore';
import { useKnowledgeStore } from '@/app/store/knowledgeStore';
import { useEventBus } from '@/app/core/events/CentralEventBus';
import { GameEventType } from '@/app/core/events/EventTypes';
import ConversationFormat from './formats/ConversationFormat';
import { createKapoorCalibrationFlow } from '@/app/core/dialogue/DialogueStateMachine';
import kapoorCalibrationDialogue from '@/app/data/dialogues/calibrations/kapoor-calibration';

/**
 * Challenge Router - Simplified for Vertical Slice
 * 
 * This version focuses exclusively on the critical path of Dr. Kapoor's
 * calibration conversation and journal acquisition. All other challenge
 * types have been stripped out.
 */
export default function ChallengeRouter() {
  const { currentNodeId, completeNode, updateInsight, setCurrentNode } = useGameStore();
  const { initializeJournal } = useJournalStore();
  const { updateMastery, discoverConcept } = useKnowledgeStore();
  
  // Local state
  const [challengeComplete, setChallengeComplete] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Prepare dialogue content with fallback mechanisms
  const dialogueStages = useMemo(() => {
    try {
      // First attempt: Try to create a flow via the factory
      const flow = createKapoorCalibrationFlow(currentNodeId || 'kapoor-calibration');
      
      // Validate flow structure
      if (flow && flow.stages && Array.isArray(flow.stages) && flow.stages.length > 0) {
        console.log("✅ Generated flow stages successfully:", flow.stages.length);
        return flow.stages;
      }
      
      console.warn("⚠️ Flow factory returned invalid structure, falling back to direct import");
      
      // Fallback: Use directly imported dialogue content
      if (kapoorCalibrationDialogue && Array.isArray(kapoorCalibrationDialogue) && 
          kapoorCalibrationDialogue.length > 0) {
        console.log("✅ Using direct dialogue import:", kapoorCalibrationDialogue.length);
        return kapoorCalibrationDialogue;
      }
      
      // Last resort: Create a minimal dialogue to ensure critical path progression
      console.error("🚨 All dialogue sources failed, using emergency minimal dialogue");
      return [
        {
          id: 'emergency-intro',
          text: "Good morning. I see you've arrived for your first day. Let's get started with the basics of medical physics.",
          contextNote: "Dr. Kapoor adjusts some equipment as you enter.",
          options: [
            { 
              id: "continue",
              text: "I'm ready to learn.", 
              nextStageId: 'emergency-journal',
              insightGain: 10,
              relationshipChange: 1
            }
          ]
        },
        {
          id: 'emergency-journal',
          type: 'critical-moment',
          text: "You'll need this journal to document your observations and track your progress through the residency.",
          contextNote: "Dr. Kapoor hands you a leather-bound journal.",
          isConclusion: true
        }
      ];
    } catch (err) {
      // Capture any unexpected errors
      console.error("Error preparing dialogue content:", err);
      setError(`Failed to prepare dialogue: ${err instanceof Error ? err.message : String(err)}`);
      
      // Return minimal content to avoid breaking the UI
      return [{
        id: 'error-recovery',
        text: "System initializing... please stand by.",
        isConclusion: true
      }];
    }
  }, [currentNodeId]);
  
  // Reset challenge state when node changes
  useEffect(() => {
    setChallengeComplete(false);
    setError(null);
  }, [currentNodeId]);
  
  // Handle conversation completion - CRITICAL PATH
  const handleConversationComplete = (results: any) => {
    try {
      console.log("✅ Conversation complete with results:", results);
      
      // Mark knowledge gain - radiation dosimetry concept for the vertical slice
      updateMastery('radiation-dosimetry', 25);
      discoverConcept('radiation-dosimetry');
      
      // CRITICAL PATH: Journal acquisition
      if (!useJournalStore.getState().hasJournal) {
        try {
          console.log("📓 Initializing journal with tier:", results.journalTier);
          initializeJournal(results.journalTier || 'technical');
          
          // Log journal acquisition
          useEventBus.getState().dispatch(
            GameEventType.JOURNAL_ACQUIRED,
            {
              tier: results.journalTier || 'technical',
              character: 'kapoor',
              source: 'conversation_completion'
            },
            'challengeRouter'
          );
        } catch (journalError) {
          console.error("⚠️ Journal initialization failed:", journalError);
          
          // RESILIENCE: Force journal acquisition as fallback
          setTimeout(() => {
            try {
              if (!useJournalStore.getState().hasJournal) {
                console.warn("⚠️ Emergency journal acquisition fallback");
                initializeJournal('technical');
              }
            } catch (e) {
              console.error("💥 Critical failure in journal acquisition:", e);
            }
          }, 100);
        }
      }
      
      // Award insight points
      updateInsight(results.insightGained || 10);
      
      // Mark node as completed - important for progression
      completeNode(currentNodeId || 'kapoor-calibration');
      setChallengeComplete(true);
      
      // Return to map after a short delay
      setTimeout(() => {
        setCurrentNode(null);
      }, 1500);
    } catch (error) {
      console.error("Error handling conversation completion:", error);
      setError(error instanceof Error ? error.message : String(error));
      
      // RESILIENCE: Still mark node as complete even if something fails
      try {
        completeNode(currentNodeId || 'kapoor-calibration');
        
        // Force journal acquisition as ultimate fallback
        if (!useJournalStore.getState().hasJournal) {
          initializeJournal('technical');
        }
        
        // Return to map
        setTimeout(() => {
          setCurrentNode(null);
        }, 1500);
      } catch (e) {
        console.error("Critical failure in completion handling:", e);
      }
    }
  };
  
  // Handle error state
  if (error) {
    return (
      <div className="p-8 bg-red-900/20 max-w-2xl mx-auto my-12 rounded">
        <h2 className="text-2xl mb-4">Challenge Error</h2>
        <div className="bg-black/30 p-4 rounded mb-4">{error}</div>
        <button
          className="px-4 py-2 bg-blue-600 text-white rounded"
          onClick={() => setCurrentNode(null)}
        >
          Return to Map
        </button>
      </div>
    );
  }
  
  // Handle completed state
  if (challengeComplete) {
    return (
      <div className="p-8 max-w-2xl mx-auto my-12 text-center">
        <h2 className="text-2xl mb-4">Challenge Complete!</h2>
        <div className="animate-pulse text-6xl mb-6">✨</div>
        <p className="mb-6">Returning to map...</p>
      </div>
    );
  }
  
  // For vertical slice, we're hardcoding to a conversation with Dr. Kapoor
  return (
    <div className="p-4 flex justify-center items-center min-h-full bg-background">
      <div className="max-w-3xl w-full">
        <ConversationFormat
          character="kapoor"
          dialogueStages={dialogueStages} // Using our hardened dialogue stages
          dialogueId={currentNodeId || 'kapoor-calibration'}
          onComplete={handleConversationComplete}
          onOptionSelected={(option, stageId) => {
            // Log for analytics
            try {
              useEventBus.getState().dispatch(
                GameEventType.DIALOGUE_OPTION_SELECTED,
                {
                  optionId: option.id,
                  stageId,
                  character: 'kapoor'
                },
                'challengeRouter'
              );
            } catch (e) {
              // Non-critical, continue even if logging fails
              console.debug("Event logging failed:", e);
            }
          }}
          stateMachineEnabled={true}
        />
      </div>
    </div>
  );
}
==== END: app/components/challenges/ChallengeRouter.tsx ====

==== START: app/components/challenges/formats/ConversationFormat.tsx ====
// app/components/challenges/formats/ConversationFormat.tsx
'use client';
import { useState, useEffect, useRef, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameStore } from '../../../store/gameStore';
import { useResourceStore, StrategicActionType } from '../../../store/resourceStore';
import { useDialogueFlow, DialogueStage, DialogueOptionView } from '../../../hooks/useDialogueFlow';
import { useTypewriter } from '../../../hooks/useTypewriter';
import { PixelButton, PixelText, PixelBox } from '../../PixelThemeProvider';
import { useEventBus } from '../../../core/events/CentralEventBus';
import { GameEventType } from '../../../core/events/EventTypes';
import InsightMeter from '../../gameplay/InsightMeter';
import MomentumCounter from '../../gameplay/MomentumCounter';
import { StrategicActionsContainer } from '../../gameplay/StrategicActions';
import { applyStrategicAction, enhanceDialogueOptions } from '../../../core/dialogue/ActionIntegration';

// Results interface for completion
export interface InteractionResults {
  insightGained: number;
  relationshipChange: number;
  knowledgeGained: Record<string, number>;
  journalTier?: 'base' | 'technical' | 'annotated';
  actionsUsed?: StrategicActionType[];
}

// Character portrait data
interface CharacterData {
  name: string;
  title: string;
  sprite: string;
  primaryColor: string;
  textClass: string;
  bgClass: string;
}

interface ConversationFormatProps {
  character: string;
  dialogueStages?: DialogueStage[];
  dialogueId?: string;
  onComplete: (results: InteractionResults) => void;
  onOptionSelected?: (option: DialogueOptionView, stageId: string) => void;
  onStageChange?: (newStageId: string, prevStageId: string) => void;
  stateMachineEnabled?: boolean;
}

/**
 * Enhanced conversation format with Strategic Actions integration & Juice!
 */
export default function ConversationFormat({
  character,
  dialogueStages,
  dialogueId = `${character}-dialogue`,
  onComplete,
  onOptionSelected,
  onStageChange,
  stateMachineEnabled = false
}: ConversationFormatProps) {
  // Core game systems
  const { currentNodeId } = useGameStore();
  const {
    insight,
    momentum,
    activeAction,
    activateAction,
    completeAction,
    cancelAction,
    incrementMomentum,
    resetMomentum,
    updateInsight
  } = useResourceStore();
  // Local state
  const [playerScore, setPlayerScore] = useState(0);
  const [insightGained, setInsightGained] = useState(0);
  const [isInitialized, setIsInitialized] = useState(false);
  const [usedActions, setUsedActions] = useState<StrategicActionType[]>([]);
  const [consecutiveCorrect, setConsecutiveCorrect] = useState(0);
  // UI animation states
  const [showOptionFeedback, setShowOptionFeedback] = useState<'correct' | 'incorrect' | null>(null);
  const [feedbackMessage, setFeedbackMessage] = useState('');
  const [showInsightGain, setShowInsightGain] = useState(false);
  const [lastInsightGain, setLastInsightGain] = useState(0);
  // **NEW**: State for character reaction animation
  const [characterReaction, setCharacterReaction] = useState<'idle' | 'positive' | 'negative' | 'thinking'>('idle');
  // **NEW**: State for screen shake
  const [applyScreenShake, setApplyScreenShake] = useState(false);

  // Character data (memoized to prevent recreation)
  const charData = useMemo(() => getCharacterData(character), [character]);
  // Use dialogue flow hook
  const dialogueState = useDialogueFlow({
    characterId: character,
    nodeId: currentNodeId || undefined,
    dialogueId,
    stages: dialogueStages,
    onOptionSelected,
    onStageChange
  });
  // Extract values from the dialogue state with safe fallbacks
  const currentStage = 'currentStage' in dialogueState ?
  dialogueState.currentStage : {
    id: dialogueState.instanceId || 'loading',
    text: dialogueState.currentText || '',
    options: dialogueState.options || [],
    isConclusion: false,
    contextNote: ''
  };
  const currentStageId = 'currentStageId' in dialogueState ?
    dialogueState.currentStageId :
    (dialogueState.instanceId || currentStage?.id || 'loading');
  const showResponse = dialogueState.showResponse || false;
  const showBackstory = dialogueState.showBackstory || false;
  const backstoryText = dialogueState.backstoryText || '';

  // Local state specifically for selectedOption to use in useEffect dependency array
  const [currentSelectedOption, setCurrentSelectedOption] = useState<DialogueOptionView | null>(null);

  // Safe function references
  const handleOptionSelect = 'handleOptionSelect' in dialogueState ?
  dialogueState.handleOptionSelect :
    ((option: DialogueOptionView) => console.warn('handleOptionSelect not available'));

  const handleContinue = 'handleContinue' in dialogueState ?
  dialogueState.handleContinue :
    (() => console.warn('handleContinue not available'));

  const completeDialogue = 'completeDialogue' in dialogueState ?
  dialogueState.completeDialogue :
    (() => console.warn('completeDialogue not available'));
  // Set initialization flag when dialogue state is ready
  useEffect(() => {
    if (currentStage && 'text' in currentStage && !isInitialized) {
      setIsInitialized(true);
    }
  }, [currentStage, isInitialized]);

  // **CORRECTED**: Character reaction effect based on relationship change
  useEffect(() => {
    // Check if currentSelectedOption exists AND has relationshipChange defined
    if (currentSelectedOption && currentSelectedOption.relationshipChange !== undefined) {
      if (currentSelectedOption.relationshipChange > 0) {
        setCharacterReaction('positive');
      } else if (currentSelectedOption.relationshipChange < 0) {
        setCharacterReaction('negative');
      }
      // Reset after a short delay
      const timer = setTimeout(() => setCharacterReaction('idle'), 800);
      return () => clearTimeout(timer);
    }
    // If no selected option or no relationship change, ensure reaction is idle
    else {
        setCharacterReaction('idle');
    }
  }, [currentSelectedOption]); // Depend on the local state copy

  // **NEW**: Screen shake effect
  useEffect(() => {
    if (applyScreenShake) {
      const timer = setTimeout(() => setApplyScreenShake(false), 300); // Duration of shake
      return () => clearTimeout(timer);
    }
  }, [applyScreenShake]);


  // Function to determine if an option is "correct"
  const isOptionCorrect = (option: DialogueOptionView & {
    relationshipChange?: number;
    approach?: string;
  }) => {
    // Options that improve relationship are considered "correct"
    if (option.relationshipChange && option.relationshipChange > 0) {
      return true;
  }

    // "precision" and "humble" approaches are generally correct
    if (option.approach === 'precision' || option.approach === 'humble') {
      return true;
  }

    // Options with critical path are correct
    if (option.isCriticalPath) {
      return true;
  }

    // Default to neutral (not breaking momentum)
    return true;
  };

  // Handle option selection with resource integration
  const handleOptionSelectWrapper = (option: DialogueOptionView & {
    relationshipChange?: number;
    insightGain?: number;
    approach?: string;
  }) => {
    // **CORRECTION**: Update local state copy for useEffect
    setCurrentSelectedOption(option);

    // Determine if option was "correct" for momentum
    const correct = isOptionCorrect(option);
    // Calculate base insight gain
    let baseInsightGain = option.insightGain || 0;
    // Get any relationship change
    const relationshipChange = option.relationshipChange || 0;
    // Handle momentum changes
    if (correct) {
      // Increment consecutive counter
      setConsecutiveCorrect(prev => prev + 1);
      // Apply to global momentum
      incrementMomentum();
      // Prepare positive feedback
      setShowOptionFeedback('correct');
      setFeedbackMessage(getFeedbackMessage('correct', option.approach));
      // **NEW**: Positive character reaction (useEffect will handle this now)
  } else {
      // Reset momentum
      setConsecutiveCorrect(0);
      resetMomentum();
      // Prepare negative feedback
      setShowOptionFeedback('incorrect');
      setFeedbackMessage(getFeedbackMessage('incorrect', option.approach));
      // **NEW**: Negative character reaction & screen shake (useEffect will handle reaction)
      setApplyScreenShake(true);
  }

    // Apply insight gain with momentum bonus if any
    if (baseInsightGain > 0) {
      // Double insight if boast is active
      if (activeAction === 'boast') {
        baseInsightGain *= 2;
  }

      // Calculate momentum multiplier
      const momentumMultiplier = 1 + (momentum * 0.25);
      // 1.0, 1.25, 1.5, 1.75
      const totalInsight = Math.floor(baseInsightGain * momentumMultiplier);
      // Update global insight
      updateInsight(totalInsight);
      // Update local tracking
      setInsightGained(prev => prev + totalInsight);
      setLastInsightGain(totalInsight);
      setShowInsightGain(true);
      // Clear gain effect after animation
      setTimeout(() => setShowInsightGain(false), 2000);
  }

    // Update player score for relationship
    if (relationshipChange) {
      setPlayerScore(prev => prev + relationshipChange);
  }

    // If an action is active, complete it
    if (activeAction) {
      completeAction(activeAction, correct);
  }

    // Show feedback animation & reset character reaction
    const feedbackTimer = setTimeout(() => {
      setShowOptionFeedback(null);
      // Character reaction reset is now handled by useEffect
    }, 1200); // Slightly shorter feedback display

    // Forward to dialogue handler
    handleOptionSelect(option);
  };
  // Handle strategic action activation
  const handleActionActivate = (actionType: StrategicActionType) => {
    // Add to used actions list
    if (!usedActions.includes(actionType)) {
      setUsedActions(prev => [...prev, actionType]);
  }

    // Apply action to dialogue
    applyStrategicAction(actionType, character, currentStageId);
    setCharacterReaction('thinking'); // **NEW**: Character thinking pose
    setTimeout(() => setCharacterReaction('idle'), 1000);
  };
  // Handle strategic action completion
  const handleActionComplete = (actionType: StrategicActionType, successful: boolean) => {
    // Could add more logic here if needed
  };
  // Handle strategic action cancellation
  const handleActionCancel = (actionType: StrategicActionType) => {
    // Could add more logic here if needed
  };
  // Handle continue button
  const handleContinueWrapper = () => {
    // **CORRECTION**: Clear the selected option when continuing
    setCurrentSelectedOption(null);

    // Check if at conclusion
    if ((currentStage?.isConclusion && !showResponse) ||
        currentStageId === 'journal-presentation') {

      // Complete the dialogue and challenge
      finalizeChallenge();
  return;
    }

    // Forward to dialogue handler
    handleContinue();
  };
  // Finalize the challenge
  const finalizeChallenge = () => {
    // Determine journal tier
    const journalTier = playerScore >= 3 ?
  'annotated' :
                     playerScore >= 0 ?
  'technical' : 'base';

    // Call completion callback
    onComplete({
      insightGained,
      relationshipChange: playerScore,
      knowledgeGained: {},
      journalTier,
      actionsUsed: usedActions
    });
    // Complete state machine flow
    if (stateMachineEnabled) {
      completeDialogue();
    }
  };
  // Initialize typewriter for main text (with safe fallbacks)
  const {
    displayText: displayedText,
    isTyping,
    complete: skipTyping
  } = useTypewriter(currentStage?.text || '', { speed: 20 }); // Faster typing

  // Initialize typewriter for backstory (with safe fallbacks)
  const {
    displayText: displayedBackstoryText,
    isTyping: isTypingBackstory,
    complete: skipBackstoryTyping
  } = useTypewriter(backstoryText || '', { speed: 20 });
  // Enhance options based on active action
  const enhancedOptions = useMemo(() => {
    if (!currentStage?.options) return [];

    // Apply strategic action enhancements
    return enhanceDialogueOptions(currentStage.options, activeAction);
  }, [currentStage?.options, activeAction]);
  // Get a feedback message based on response type
  const getFeedbackMessage = (type: 'correct' | 'incorrect', approach?: string): string => {
    if (type === 'correct') {
      if (approach === 'precision') {
        return 'Your precise approach shows strong technical understanding.';
  } else if (approach === 'humble') {
        return 'Your thoughtful consideration demonstrates professional maturity.';
  } else if (approach === 'confidence') {
        return 'Your confident analysis is well-founded.';
  }
      return 'Good approach to the situation.';
  } else {
      if (approach === 'overconfidence') {
        return 'A more measured approach would be advisable in this context.';
  } else if (approach === 'imprecision') {
        return 'Greater attention to technical details would strengthen your response.';
  }
      return 'Consider a different perspective on this issue.';
    }
  };
  // Render the option for Boast when momentum is maxed
  const renderBoastOption = (option: DialogueOptionView & {
    approach?: string;
    insightGain?: number;
  }) => {
    // Check if option has the 'confidence' approach and momentum is maxed
    if (momentum === 3 && option.approach === 'confidence' && option.insightGain) {
      return (
        <div className="absolute -left-4 top-1/2 transform -translate-y-1/2 bg-orange-600 text-white px-2 py-1 rounded-l text-xs font-pixel">
          CHALLENGE

       </div>
      );
  }

    return null;
  };
  // Loading state while dialogue initializes
  if (!isInitialized) {
    return (
      <div className="p-6 max-w-4xl mx-auto bg-surface pixel-borders">
        <div className="bg-surface-dark p-4 pixel-borders-thin mb-4 min-h-[120px] flex items-center justify-center">
          <PixelText>Initializing dialogue...</PixelText>
        </div>
      </div>
    );
  }

  // Main conversation UI
  return (
    <div className={`p-6 max-w-4xl mx-auto bg-surface pixel-borders relative transition-transform duration-300 ${applyScreenShake ? 'animate-shake-subtle' : ''}`}>
      {/* Character header - Enhanced with more space */}
      <div className="flex justify-between items-start mb-8">
        <div className="flex items-start">
          {/* Character portrait with dedicated space & reaction animation */}
          <motion.div
            className="w-70 h-70 mr-6 relative pixel-borders"
            animate={characterReaction} // Bind animation state
            variants={{
              idle: { scale: 1, rotate: 0 },
              positive: { scale: 1.05, rotate: 2 },
              negative: { x: [-2, 2, -2, 2, 0] }, // Shake animation
              thinking: { scale: 0.98, opacity: 0.8 }
            }}
            transition={{ type: 'spring', stiffness: 300, damping: 10 }}
          >
        <div
              className="absolute inset-0 bg-cover bg-center"
              style={{
                backgroundImage: `url(${charData.sprite})`,
                imageRendering: 'pixelated'
              }}
            ></div>
         <div className={`absolute inset-0 ${charData.bgClass} opacity-20 mix-blend-overlay`}></div>
          </motion.div>

          {/* Character info - now with more space */}
          <div className="mt-4">
            <PixelText className={`text-2xl ${charData.textClass} pixel-glow mb-1`}>
              {charData.name}
   </PixelText>
            <PixelText className="text-lg text-text-secondary">
              {charData.title}
            </PixelText>
          </div>
        </div>

        {/* Empty spacer div to push things to sides */}
        <div className="flex-grow"></div>


        {/* Resource meters - now in header with more space and 200% larger */}
        <div className="flex flex-col gap-5 w-80">
          <InsightMeter size="lg" showValue={true} />
          <div className="flex items-center gap-4">
            <MomentumCounter
              level={momentum}

           consecutiveCorrect={consecutiveCorrect}
              showLabel={true}
            />

            {/* Conditional boast button when momentum is maxed */}
            {momentum === 3 && (
              <motion.div

             className="bg-orange-700 border-orange-800 border-2 w-12 h-12 flex items-center justify-center pixel-borders"
                whileHover={{ y: -2 }}
                whileTap={{ y: 1 }}
                animate={{
                  scale: [1, 1.05, 1],

                 transition: { repeat: Infinity, duration: 1.5 }
                }}
              >
                <PixelText className="text-xs text-white">CHAL</PixelText>
              </motion.div>
            )}
          </div>

       </div>
      </div>

      {/* Strategic actions panel - moved to below the character header */}
      <div className="flex justify-center mb-6">
        <StrategicActionsContainer
          characterId={character}
          stageId={currentStageId}
          onActionActivate={handleActionActivate}
          onActionComplete={handleActionComplete}

     onActionCancel={handleActionCancel}
        />
      </div>

      {/* Dialogue area */}
      <div className="bg-surface-dark p-5 pixel-borders mb-5 min-h-[150px] relative">
        {/* Feedback overlay for correct/incorrect answers */}
        <AnimatePresence>
          {showOptionFeedback && (
            <motion.div

           className={`absolute inset-0 pointer-events-none z-10 ${
                showOptionFeedback === 'correct'
                  ?
  'bg-green-500/10 border border-green-500/30 feedback-correct-border' // **NEW** Class for CSS animation
                  : 'bg-red-500/10 border border-red-500/30 feedback-incorrect-border' // **NEW** Class for CSS animation
              }`}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}

    >
              <motion.div
                className={`absolute top-2 right-2 px-2 py-1 text-xs font-pixel ${
                  showOptionFeedback === 'correct' ?
  'bg-green-700 text-green-100' : 'bg-red-700 text-red-100'
                }`}
                initial={{ x: 20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                exit={{ x: 20, opacity: 0 }}
              >

                 {showOptionFeedback === 'correct' ?
  'Effective Approach' : 'Suboptimal Approach'}
              </motion.div>

              {/* Feedback message */}
              {feedbackMessage && (
                <motion.div
                  className={`absolute

   bottom-2 left-2 right-2 px-3 py-2 text-sm font-pixel ${
                    showOptionFeedback === 'correct' ? 'bg-green-900/70 text-green-100' : 'bg-red-900/70 text-red-100'
                  }`}
                  initial={{ y: 20, opacity: 0 }}
                  animate={{ y: 0, opacity: 1, transition:

  { delay: 0.2 } }}
                  exit={{ y: 20, opacity: 0 }}
                >
                  {feedbackMessage}
                </motion.div>
              )}

              {/* **NEW**: Particle burst effect on correct */}
              {showOptionFeedback === 'correct' && <div className="particle-burst-correct"></div>}

         </motion.div>
          )}
        </AnimatePresence>

        {/* Insight gain animation */}
        <AnimatePresence>
          {showInsightGain && lastInsightGain > 0 && (
            <motion.div
              className="absolute top-0 right-0 mt-2 mr-2 z-20 pointer-events-none"

             initial={{ y: -20, opacity: 0, scale: 0.5 }} // Added scale
              animate={{ y: 0, opacity: 1, scale: 1 }} // Added scale
              exit={{ y: 20, opacity: 0, scale: 0.5 }} // Added scale
            >
              <div className="flex items-center bg-blue-900/80 px-3 py-1 rounded shadow-lg">

           <span className="text-blue-300 font-pixel text-sm mr-1 animate-pulse-fast">+</span> {/* Added animation */}
                <span className="text-blue-200 font-pixel text-sm">{lastInsightGain}</span>
                <span className="text-blue-300 font-pixel text-sm ml-1">Insight</span>
              </div>
            </motion.div>
          )}
        </AnimatePresence>


         {/* Show backstory or main content */}
        {showBackstory ?
  (
          <PixelText className="italic text-xl leading-relaxed">
            {displayedBackstoryText}{isTypingBackstory ? '|' : ''}
          </PixelText>
        ) : (
          <div>
            <PixelText className="text-xl leading-relaxed">
              {displayedText}{isTyping ? '|' : ''}

         </PixelText>

            {/* Context note */}
            {!isTyping && currentStage?.contextNote && (
              <div className="mt-4 pt-2 border-t border-border">
                <PixelText className="text-text-secondary text-sm italic">

                 {currentStage.contextNote}
                </PixelText>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Options or continue button */}
      {showResponse ||
  showBackstory ? (
        <PixelButton
          className={`float-right ${charData.bgClass} text-white hover:opacity-90`}
          onClick={() => { skipTyping(); skipBackstoryTyping(); handleContinueWrapper(); }} // Allow skipping typewriters
        >
          {(isTyping || isTypingBackstory) ? "Skip »" : "Continue →"}
        </PixelButton>
      ) : (
        enhancedOptions && enhancedOptions.length > 0 ? (
          <div className="space-y-3">

           {enhancedOptions.map((option: any, index: number) => ( // Added index
              <motion.button
                key={option.id}
                className={`w-full text-left p-4 bg-surface hover:bg-surface-dark pixel-borders relative
                  ${activeAction === 'boast' ? 'border-orange-500/50' : ''}

                 ${activeAction === 'reframe' ? 'border-blue-500/50' : ''}
                `}
                onClick={() => handleOptionSelectWrapper(option)}
                disabled={isTyping}
                initial={{ opacity: 0, y: 10 }} // **NEW** Animate options in
                animate={{ opacity: 1, y: 0, transition: { delay: index * 0.05 } }} // **NEW** Staggered animation
                whileHover={{ x: 3 }}
                whileTap={{ scale:

   0.99 }}
              >
                {/* Render boast badge if applicable */}
                {renderBoastOption(option)}

                <div className="flex justify-between">

             <PixelText className="text-base">{option.text}</PixelText>

                  {/* Show insight preview */}
                  {option.insightGain && option.insightGain > 0 && (
                    <motion.span


                     className={`ml-2 text-xs ${
                        activeAction === 'boast'
                          ?
  'bg-orange-600 text-white'
                          : 'bg-blue-600 text-white'
                      } px-2 py-1 rounded-sm`}
                      animate={activeAction === 'boast' ?
  { scale: [1, 1.1, 1], transition: { repeat: Infinity, duration: 1.5 } } : {}}
                    >
                      {activeAction === 'boast' ?
  `+${option.insightGain * 2}` : `+${option.insightGain}`}
                    </motion.span>
                  )}

                  {/* Special indicators for strategic options */}

             {activeAction === 'reframe' && (option.approach === 'humble' || option.approach === 'precision') && (
                    <span className="absolute top-1 right-1 w-2 h-2 bg-blue-500 rounded-full"></span>
                  )}

                  {activeAction === 'boast' && (option.approach

   === 'confidence' || option.approach === 'precision') && (
                    <span className="absolute top-1 right-1 w-2 h-2 bg-orange-500 rounded-full"></span>
                  )}
                </div>


                 {/* Approach indicator - visually show player what type of response this is */}
                {option.approach && (
                  <div className="mt-2 text-sm">
                    {option.approach === 'humble' && (
                      <span className="text-blue-400">Humble approach</span>

                    )}
                    {option.approach === 'precision' && (
                      <span className="text-green-400">Precise approach</span>
                    )}

               {option.approach === 'confidence' && (
                      <span className="text-orange-400">Confident approach</span>
                    )}
                  </div>
                )}

           </motion.button>
            ))}
          </div>
        ) : (
          <PixelButton
            className={`float-right ${charData.bgClass} text-white hover:opacity-90`}
            onClick={handleContinueWrapper}
          >
            {isTyping ?
  "Skip »" : "Continue →"}
          </PixelButton>
        )
      )}

      {/* Debug info */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="mt-12 pt-4 border-t border-gray-700 text-xs opacity-50">
          <div>State Machine: {stateMachineEnabled ? 'Yes' : 'No'}</div>
          <div>Current Stage: {currentStageId}</div>

         <div>Player Score: {playerScore}</div>
          <div>Insight: {insight} (Gained: {insightGained})</div>
          <div>Momentum: {momentum} (Consecutive: {consecutiveCorrect})</div>
          <div>Active Action: {activeAction || 'None'}</div>
          <div>Used Actions: {usedActions.join(', ')}</div>
        </div>
      )}
    </div>
  );
 }

// Helper function for character data
function getCharacterData(characterId: string): CharacterData {
  const characterData: Record<string, CharacterData> = {
    'kapoor': {
      name: "Dr. Kapoor",
      title: "Chief Medical Physicist",
      sprite: "/characters/kapoor.png",
      primaryColor: "var(--clinical-color)",
      textClass: "text-clinical-light",
      bgClass: "bg-clinical"
    },
    'jesse': {
      name: "Technician Jesse",
      title: "Equipment Specialist",
      sprite: "/characters/jesse.png",

      primaryColor: "var(--qa-color)",
      textClass: "text-qa-light",
      bgClass: "bg-qa"
    },
    'quinn': {
      name: "Dr. Zephyr Quinn",
      title: "Experimental Researcher",
      sprite: "/characters/quinn.png",
      primaryColor: "var(--educational-color)",
      textClass: "text-educational-light",
      bgClass: "bg-educational"
    },
    'garcia': {
      name: "Dr. Garcia",
      title:
  "Radiation Oncologist",
      sprite: "/characters/garcia.png",
      primaryColor: "var(--clinical-alt-color)",
      textClass: "text-clinical-light",
      bgClass: "bg-clinical"
    }
  };
 return characterData[characterId] || characterData.kapoor;
}
==== END: app/components/challenges/formats/ConversationFormat.tsx ====

==== START: app/components/DayNightTransition.tsx ====
// app/components/DayNightTransition.tsx
// Refactored DayNightTransition - Purely Presentational
import React from 'react';
import { useGameState } from '../core/statemachine/GameStateMachine';

const DayNightTransition: React.FC = () => {
  const { gamePhase } = useGameState();

  // Determine visibility and animation based solely on gamePhase
  const isVisible = gamePhase === 'transition_to_day' || gamePhase === 'transition_to_night';
  const isFadingOut = gamePhase === 'transition_to_night'; // Fading to black for night
  const isFadingIn = gamePhase === 'transition_to_day'; // Fading from black for day

  if (!isVisible) {
    return null;
  }

  // Define transition styles
  const transitionStyle: React.CSSProperties = {
    position: 'fixed',
    inset: 0,
    zIndex: 50,
    backgroundColor: 'black',
    opacity: isFadingOut ? 1 : 0, // Start opaque for fade-out, start transparent for fade-in
    transition: 'opacity 800ms ease-in-out', // Use duration from state machine (or define here)
    pointerEvents: 'none', // Ensure it doesn't block interactions
  };

  // For day transition, we need to simulate the fade *in* (from black to transparent)
  // We achieve this by setting initial opacity to 1 and transitioning to 0
  const dayTransitionStyle: React.CSSProperties = isFadingIn ? {
      ...transitionStyle,
      opacity: 1, // Start opaque
      animation: 'fadeOutEffect 800ms ease-in-out forwards' // Use animation to fade out
  } : transitionStyle;


  // Optional: Add text or simple animation based on phase
  const renderTransitionContent = () => {
    if (gamePhase === 'transition_to_night') {
      return (
        <div style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', color: 'white', textAlign: 'center' }}>
          <p className="animate-pulse">Returning to Hill Home...</p>
          {/* Add simple star/moon visuals if desired */}
        </div>
      );
    } else if (gamePhase === 'transition_to_day') {
      return (
        <div style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', color: 'white', textAlign: 'center' }}>
           <p className="animate-pulse">Heading to the Hospital...</p>
           {/* Add simple sun/sky visuals if desired */}
        </div>
      );
    }
    return null;
  };

  return (
    <>
      <div style={dayTransitionStyle}>
        {renderTransitionContent()}
      </div>
      {/* Add fade-out animation style */}
       <style jsx global>{`
          @keyframes fadeOutEffect {
            from { opacity: 1; }
            to { opacity: 0; }
          }
          @keyframes pulse {
              0%, 100% { opacity: 1; }
              50% { opacity: 0.5; }
          }
          .animate-pulse {
              animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
          }
        `}</style>
    </>
  );
};

export default DayNightTransition;
==== END: app/components/DayNightTransition.tsx ====

==== START: app/layout.tsx ====
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import PixelThemeProvider from "./components/PixelThemeProvider";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
  display: "swap", // Use display swap to prevent FOUT
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
  display: "swap", // Use display swap to prevent FOUT
});

export const metadata: Metadata = {
  title: "Rogue Resident: Medical Physics Residency",
  description: "An educational roguelike game about medical physics",
};

// Static font preloading in the document head
function FontPreloader() {
  return (
    <>
      {/* Font Preloading */}
      <link 
        rel="preload" 
        href="https://fonts.googleapis.com/css2?family=VT323&display=swap" 
        as="style"
        crossOrigin="anonymous"
      />
      <link 
        rel="preload" 
        href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" 
        as="style"
        crossOrigin="anonymous"
      />
      {/* Also preload the actual font files */}
      <link 
        rel="preload" 
        href="https://fonts.gstatic.com/s/vt323/v17/pxiKyp0ihIEF2isfFJU.woff2" 
        as="font"
        type="font/woff2"
        crossOrigin="anonymous"
      />
      <link 
        rel="preload" 
        href="https://fonts.gstatic.com/s/pressstart2p/v15/e3t4euO8T-267oIAQAu6jDQyK3nVivM.woff2" 
        as="font"
        type="font/woff2"
        crossOrigin="anonymous"
      />
      {/* Add stylesheet links to ensure they load immediately */}
      <link 
        rel="stylesheet" 
        href="https://fonts.googleapis.com/css2?family=VT323&display=swap" 
      />
      <link 
        rel="stylesheet" 
        href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" 
      />
    </>
  );
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // Determine if we're in development mode
  const isDevelopment = process.env.NODE_ENV !== 'production';
  
  return (
    <html lang="en">
      <head>
        <FontPreloader />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <PixelThemeProvider>
          {/* Note: Systems initialization happens in the page component */}
          {children}
        </PixelThemeProvider>
      </body>
    </html>
  );
}
==== END: app/layout.tsx ====

