==== START: app/page.tsx ====
'use client';
import { useEffect, useState } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import GameContainer from './components/GameContainer';
import JournalAcquisitionAnimation from './components/journal/JournalAcquisitionAnimation';
import PixelThemeProvider from './components/PixelThemeProvider';
import { useCoreInitialization } from './core/init';

/**
 * Vertical Slice Entry Point
 * 
 * Entry point for the Rogue Resident vertical slice. This component:
 * 1. Initializes core systems (event bus, state machine, progression resolver)
 * 2. Provides error boundary for crash resilience
 * 3. Wraps the game in necessary theme providers
 * 4. Handles journal acquisition animation
 */
export default function VerticalSlicePage() {
  // Initialize core systems
  const { initialized, reinitialize } = useCoreInitialization();
  
  // Track journal animation state
  const [journalAnimationCompleted, setJournalAnimationCompleted] = useState(false);
  
  // Make the reinitialize function available globally for emergency recovery
  useEffect(() => {
    if (typeof window !== 'undefined') {
      (window as any).__FORCE_REINITIALIZE__ = reinitialize;
    }
    
    console.log(`Core systems ${initialized ? 'are initialized' : 'initialization pending'}`);
    
    // Cleanup when component unmounts
    return () => {
      if (typeof window !== 'undefined') {
        delete (window as any).__FORCE_REINITIALIZE__;
      }
    };
  }, [initialized, reinitialize]);

  // Fallback UI for critical errors
  const ErrorFallback = ({ error, resetErrorBoundary }: { 
    error: Error, 
    resetErrorBoundary: () => void 
  }) => (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white p-6">
      <div className="max-w-lg">
        <h1 className="text-2xl font-bold mb-4 text-red-500">Game Error</h1>
        <div className="bg-gray-800 p-4 rounded mb-4 font-mono text-sm overflow-auto max-h-64">
          {error.message}
          {error.stack && (
            <pre className="mt-2 text-xs text-gray-400">
              {error.stack.split('\n').slice(0, 5).join('\n')}
            </pre>
          )}
        </div>
        <button 
          onClick={() => {
            // First reinitialize core systems
            reinitialize();
            console.log('Core systems reinitialized after error');
            // Then reset the error boundary
            resetErrorBoundary();
          }}
          className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded"
        >
          Try Again
        </button>
        <button 
          onClick={() => window.location.reload()}
          className="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded ml-2"
        >
          Reload Page
        </button>
      </div>
    </div>
  );

  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onReset={() => {
        // Core systems will be reinitialized in the ErrorFallback component
        console.log('Error boundary reset');
      }}
    >
      <div className="min-h-screen bg-black text-white">
        <GameContainer />
        {/* Journal acquisition animation overlay */}
        <JournalAcquisitionAnimation 
          onComplete={() => setJournalAnimationCompleted(true)} 
        />
      </div>
    </ErrorBoundary>
  );
}
==== END: app/page.tsx ====

==== START: app/components/PixelThemeProvider.tsx ====
'use client';
import React from 'react';
import { motion } from 'framer-motion';

interface PixelTextProps {
  children: React.ReactNode;
  className?: string;
  pixelated?: boolean;
}

interface PixelButtonProps {
  children: React.ReactNode;
  className?: string;
  onClick?: () => void;
  disabled?: boolean;
  variant?: 'default' | 'primary' | 'clinical' | 'qa' | 'educational' | 'success' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  icon?: React.ReactNode;
}

interface PixelBoxProps {
  children: React.ReactNode;
  className?: string;
  variant?: 'default' | 'dark' | 'light' | 'clinical' | 'qa' | 'educational';
  bordered?: boolean;
}

/**
 * PixelText - Typography component with pixel-perfect rendering
 */
export function PixelText({ 
  children, 
  className = '',
  pixelated = false
}: PixelTextProps) {
  return (
    <div 
      className={`font-pixel ${pixelated ? 'text-rendering-pixelated' : ''} ${className}`}
      style={pixelated ? { imageRendering: 'pixelated' } : undefined}
    >
      {children}
    </div>
  );
}

/**
 * PixelButton - Interactive component with consistent tactile feedback
 */
export function PixelButton({ 
  children, 
  className = '', 
  onClick,
  disabled = false,
  variant = 'default',
  size = 'md',
  icon
}: PixelButtonProps) {
  const variantClasses = {
    default: "bg-gray-800 border-gray-900 hover:bg-gray-700 text-white",
    primary: "bg-blue-700 border-blue-900 hover:bg-blue-600 text-white",
    clinical: "bg-clinical border-clinical-dark hover:bg-clinical-light text-white",
    qa: "bg-qa border-qa-dark hover:bg-qa-light text-white",
    educational: "bg-educational border-educational-dark hover:bg-educational-light text-white",
    success: "bg-green-700 border-green-900 hover:bg-green-600 text-white",
    danger: "bg-red-700 border-red-900 hover:bg-red-600 text-white"
  };
  
  const sizeClasses = {
    sm: "px-2 py-1 text-xs",
    md: "px-4 py-2 text-sm",
    lg: "px-6 py-3 text-base"
  };
  
  return (
    <motion.button
      className={`
        font-pixel border-2 pixel-borders
        ${sizeClasses[size]}
        ${variantClasses[variant]}
        ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
        ${className}
      `}
      onClick={onClick}
      disabled={disabled}
      whileHover={disabled ? {} : { y: -2 }}
      whileTap={disabled ? {} : { y: 1 }}
      style={{ boxShadow: "inset 0 0 0 1px rgba(255,255,255,0.1)" }}
    >
      <div className="flex items-center justify-center">
        {icon && <span className="mr-2">{icon}</span>}
        {children}
      </div>
    </motion.button>
  );
}

/**
 * PixelBox - Container with pixel-perfect borders
 */
export function PixelBox({
  children,
  className = '',
  variant = 'default',
  bordered = true
}: PixelBoxProps) {
  const variantClasses = {
    default: "bg-surface",
    dark: "bg-surface-dark",
    light: "bg-surface-light",
    clinical: "bg-clinical bg-opacity-10",
    qa: "bg-qa bg-opacity-10",
    educational: "bg-educational bg-opacity-10"
  };
  
  return (
    <div 
      className={`
        ${variantClasses[variant]}
        ${bordered ? 'pixel-borders' : ''}
        ${className}
      `}
      style={bordered ? { boxShadow: "inset 0 0 0 1px rgba(255,255,255,0.1)" } : undefined}
    >
      {children}
    </div>
  );
}

/**
 * PixelThemeProvider - Context provider for consistent theming
 */
export default function PixelThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <>
      {children}
      
      {/* Global pixel styles */}
      <style jsx global>{`
        /* Pixel rendering quality */
        .text-rendering-pixelated {
          text-rendering: optimizeSpeed;
          -webkit-font-smoothing: none;
        }
        
        /* Custom pixel borders with inset highlight */
        .pixel-borders {
          position: relative;
          border: 2px solid #0f172a;
          box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
        }
        
        .pixel-borders::after {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 1px;
          height: 1px;
          background-color: rgba(255,255,255,0.2);
        }
        
        .pixel-borders-thin {
          position: relative;
          border: 1px solid #0f172a;
        }
        
        /* Thicker borders for emphasis */
        .pixel-borders-lg {
          position: relative;
          border: 3px solid #0f172a;
          box-shadow: 0 0 0 1px rgba(0,0,0,0.4);
        }
        
        .pixel-borders-lg::after {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 2px;
          height: 2px;
          background-color: rgba(255,255,255,0.2);
        }
        
        /* Glow effects */
        .pixel-glow {
          text-shadow: 0 0 4px currentColor;
        }
        
        /* Font size for tiny text */
        .text-2xs {
          font-size: 0.625rem;
          line-height: 0.75rem;
        }
      `}</style>
    </>
  );
}
==== END: app/components/PixelThemeProvider.tsx ====

==== START: app/components/journal/Journal.tsx ====
'use client';
import { useState, useEffect } from 'react';
import { useJournalStore } from '@/app/store/journalStore';
import { useGameStore } from '@/app/store/gameStore';
import { useEventSubscription } from '@/app/core/events/CentralEventBus';
import { GameEventType } from '@/app/core/events/EventTypes';

// Define valid page types to ensure type safety across the UI
export type JournalPageType = 'knowledge' | 'characters' | 'notes' | 'references';

// Simple placeholder components for the missing journal pages
const JournalKnowledgePage = () => (
  <div className="p-4">
    <h2 className="text-2xl mb-4">Knowledge</h2>
    <p className="text-gray-300">Knowledge entries will appear here as you discover them.</p>
  </div>
);

const JournalCharactersPage = () => (
  <div className="p-4">
    <h2 className="text-2xl mb-4">Characters</h2>
    <p className="text-gray-300">Character information will be recorded here.</p>
  </div>
);

const JournalNotesPage = () => (
  <div className="p-4">
    <h2 className="text-2xl mb-4">Notes</h2>
    <p className="text-gray-300">Your research notes will be collected here.</p>
  </div>
);

const JournalReferencesPage = () => (
  <div className="p-4">
    <h2 className="text-2xl mb-4">References</h2>
    <p className="text-gray-300">Reference materials will be cataloged here.</p>
  </div>
);

// Simple pixel text component 
const PixelText = ({ className = "", children }: { className?: string, children: React.ReactNode }) => (
  <div className={`font-pixel ${className}`}>{children}</div>
);

/**
 * Journal Component - Simplified for prototype
 */
export default function Journal() {
  const { 
    isOpen, 
    currentPage, 
    setCurrentPage, 
    toggleJournal, 
    currentUpgrade,
    hasJournal 
  } = useJournalStore();
  
  const { gamePhase } = useGameStore();
  
  // Animation states
  const [isAnimating, setIsAnimating] = useState(false);
  const [showParticles, setShowParticles] = useState(false);
  const [showFloatingButton, setShowFloatingButton] = useState(false);
  const [journalAnimating, setJournalAnimating] = useState(false);
  
  // Listen for journal acquisition events
  useEventSubscription(
    GameEventType.JOURNAL_ACQUIRED,
    (event) => {
      const payload = event.payload as any;
      if (payload) {
        // Show animation first
        setJournalAnimating(true);
        
        // Show floating button after animation completes
        setTimeout(() => {
          setJournalAnimating(false);
          setShowFloatingButton(true);
        }, 3000);
      }
    },
    []
  );
  
  // Lock body when journal is open
  useEffect(() => {
    if (isOpen) {
      // Store original overflow
      const originalOverflow = document.body.style.overflow;
      
      // Lock the background
      document.body.style.overflow = 'hidden';
      
      // Unlock when closing
      return () => {
        document.body.style.overflow = originalOverflow;
      };
    }
  }, [isOpen]);
  
  // Handle open/close animations
  useEffect(() => {
    if (isOpen) {
      setIsAnimating(true);
      
      // After animation completes
      const timer = setTimeout(() => setIsAnimating(false), 300);
      return () => clearTimeout(timer);
    }
  }, [isOpen]);
  
  // Special effects during night phase
  useEffect(() => {
    if (isOpen && gamePhase === 'night') {
      setShowParticles(true);
      
      const timer = setTimeout(() => setShowParticles(false), 5000);
      return () => clearTimeout(timer);
    }
  }, [isOpen, gamePhase]);
  
  // Floating journal button when closed
  if (hasJournal && !isOpen && showFloatingButton) {
    return (
      <div className="fixed bottom-4 right-4 z-50">
        <button
          className="px-4 py-2 bg-clinical text-white font-pixel hover:bg-clinical-light transition-colors shadow-lg animate-float"
          onClick={() => toggleJournal()}
        >
          Open Journal
        </button>
      </div>
    );
  }
  
  // Don't render anything if player doesn't have journal or it's not open
  if (!hasJournal || !isOpen) return null;
  
  // Determine journal cover style based on upgrade level
  const getJournalCoverStyle = () => {
    switch(currentUpgrade) {
      case 'base': return 'bg-gradient-to-b from-amber-800 to-amber-900';
      case 'technical': return 'bg-gradient-to-b from-clinical-dark to-clinical';
      case 'annotated': return 'bg-gradient-to-b from-clinical-dark to-clinical-light';
      case 'indexed': return 'bg-gradient-to-b from-blue-900 to-blue-700';
      case 'integrated': return 'bg-gradient-to-b from-educational-dark to-educational';
      default: return 'bg-gradient-to-b from-amber-800 to-amber-900';
    }
  };

  return (
    <div 
      className="fixed inset-0 flex items-center justify-center z-[9999] bg-black/70"
      onClick={(e) => {
        e.stopPropagation();
        toggleJournal();
      }}
      style={{ touchAction: 'none' }} // Prevent scroll on mobile
    >
      {/* Main journal container */}
      <div 
        className={`
          journal-container
          relative w-[900px] h-[650px] 
          ${getJournalCoverStyle()}
          pixel-borders
          transform transition-all duration-300
          ${isAnimating ? 'scale-95 opacity-90' : 'scale-100 opacity-100'}
        `}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Journal cover decoration */}
        <div className="absolute inset-2 border border-amber-500/30 pointer-events-none"></div>
        
        {/* Night phase knowledge transfer particles */}
        {showParticles && (
          <div className="absolute inset-0 overflow-hidden pointer-events-none z-50">
            <div className="absolute inset-0 bg-educational/10 animate-pulse"></div>
            <div className="absolute top-0 left-1/2 w-1 h-1 bg-educational rounded-full animate-ping"></div>
            <div className="absolute top-0 left-1/3 w-2 h-2 bg-clinical rounded-full animate-ping" style={{ animationDelay: '100ms' }}></div>
            <div className="absolute top-0 right-1/4 w-1 h-1 bg-qa rounded-full animate-ping" style={{ animationDelay: '300ms' }}></div>
            <div className="absolute top-0 left-2/3 w-2 h-2 bg-educational-light rounded-full animate-ping" style={{ animationDelay: '500ms' }}></div>
            <div className="absolute top-0 right-1/3 w-1 h-1 bg-clinical-light rounded-full animate-ping" style={{ animationDelay: '700ms' }}></div>
          </div>
        )}
        
        {/* Close button */}
        <div
          role="button"
          tabIndex={0}
          className="absolute -top-4 -right-4 w-8 h-8 bg-surface pixel-borders-thin flex items-center justify-center hover:bg-clinical transition-colors z-[100] cursor-pointer"
          onClick={() => toggleJournal()}
          onKeyDown={(e) => {
            if (e.key === 'Enter') {
              e.stopPropagation();
              toggleJournal();
            }
          }}
          aria-label="Close journal"
        >
          <span>✕</span>
        </div>
        
        {/* Journal content */}
        <div className="flex h-full journal-content relative z-10" onClick={(e) => e.stopPropagation()}>
          {/* Tabs sidebar with simplified buttons */}
          <div className="w-[200px] bg-surface-dark border-r border-border relative z-20">
            <div className="p-4">
              <PixelText className="text-xl mb-4 text-center">Journal</PixelText>
              
              <div className="space-y-2">
                {/* Tab buttons */}
                {['knowledge', 'characters', 'notes', 'references'].map((tabId) => (
                  <div 
                    key={tabId}
                    className={`w-full cursor-pointer transition-colors relative z-30 ${currentPage === tabId ? 'bg-clinical text-white' : 'hover:bg-surface'}`}
                    role="button"
                    tabIndex={0}
                    onClick={() => setCurrentPage(tabId as JournalPageType)}
                  >
                    <div className="p-2">
                      <PixelText>{tabId.charAt(0).toUpperCase() + tabId.slice(1)}</PixelText>
                    </div>
                  </div>
                ))}
              </div>
            </div>
            
            {/* Journal quality indicator */}
            <div className="absolute bottom-4 left-4 w-[180px]">
              <div className="p-2 bg-surface-dark/70 text-center">
                <PixelText className="text-xs">
                  {currentUpgrade === 'base' && "Basic Notebook"}
                  {currentUpgrade === 'technical' && "Technical Journal"}
                  {currentUpgrade === 'annotated' && "Annotated Journal"}
                  {currentUpgrade === 'indexed' && "Indexed Compendium"}
                  {currentUpgrade === 'integrated' && "Integrated Codex"}
                </PixelText>
              </div>
            </div>
          </div>
          
          {/* Journal pages */}
          <div 
            className="flex-1 bg-surface overflow-y-auto p-6 relative z-20"
            onClick={(e) => e.stopPropagation()}
          >
            {currentPage === 'knowledge' && <JournalKnowledgePage />}
            {currentPage === 'characters' && <JournalCharactersPage />}
            {currentPage === 'notes' && <JournalNotesPage />}
            {currentPage === 'references' && <JournalReferencesPage />}
          </div>
        </div>
      </div>
      
      {/* CSS Animations */}
      <style jsx>{`
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.7; }
        }
        
        @keyframes ping {
          75%, 100% {
            transform: scale(2);
            opacity: 0;
          }
        }
        
        @keyframes float {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-5px); }
        }
        
        .animate-pulse {
          animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        .animate-ping {
          animation: ping 1.5s cubic-bezier(0, 0, 0.2, 1) infinite;
        }
        
        .animate-float {
          animation: float 3s ease-in-out infinite;
        }
      `}</style>
    </div>
  );
}
==== END: app/components/journal/Journal.tsx ====

==== START: app/components/journal/JournalAcquisitionAnimation.tsx ====
// app/components/journal/JournalAcquisitionAnimation.tsx
import React, { useEffect, useState } from 'react';
import { useJournalStore } from '../../store/journalStore';
import { useEventSubscription } from '../../core/events/CentralEventBus';
import { GameEventType } from '../../core/events/EventTypes';

interface JournalAcquisitionAnimationProps {
  onComplete?: () => void;
}

/**
 * JournalAcquisitionAnimation - Displays an animation when the player
 * acquires a journal, with a button to open it after acquisition
 */
export default function JournalAcquisitionAnimation({ 
  onComplete 
}: JournalAcquisitionAnimationProps) {
  // State for animation phases
  const [show, setShow] = useState(false);
  const [animationPhase, setAnimationPhase] = useState<'fadeIn' | 'display' | 'fadeOut'>('fadeIn');
  const [journalTier, setJournalTier] = useState<'base' | 'technical' | 'annotated'>('base');
  
  // Access journal store
  const { toggleJournal, hasJournal } = useJournalStore();
  
  // Listen for journal acquisition events
  useEventSubscription(
    GameEventType.JOURNAL_ACQUIRED,
    (event) => {
      const payload = event.payload as any;
      if (payload && payload.tier) {
        setJournalTier(payload.tier);
        setShow(true);
        setAnimationPhase('fadeIn');
        
        // Transition to display phase after fade in
        setTimeout(() => {
          setAnimationPhase('display');
        }, 1000);
      }
    },
    []
  );
  
  // Handle animation completion
  const handleClose = () => {
    setAnimationPhase('fadeOut');
    
    // Hide component after fade out
    setTimeout(() => {
      setShow(false);
      if (onComplete) {
        onComplete();
      }
    }, 1000);
  };
  
  // Handle journal open button
  const handleOpenJournal = () => {
    toggleJournal();
    handleClose();
  };
  
  // Don't render if not showing or if player doesn't have journal
  if (!show || !hasJournal) {
    return null;
  }
  
  return (
    <div 
      className={`fixed inset-0 flex items-center justify-center z-[1000] bg-black/80
        ${animationPhase === 'fadeIn' ? 'animate-fadeIn' : ''}
        ${animationPhase === 'fadeOut' ? 'animate-fadeOut' : ''}
      `}
    >
      <div className="max-w-md text-center">
        {/* Journal icon */}
        <div className="w-32 h-40 mx-auto mb-6 relative">
          <div 
            className={`w-full h-full ${
              journalTier === 'base' ? 'bg-amber-800' :
              journalTier === 'technical' ? 'bg-clinical' :
              'bg-clinical-light'
            } shadow-lg rounded-sm animate-float`}
          >
            <div className="absolute inset-2 border border-amber-500/30"></div>
            
            {/* Visual embellishments based on tier */}
            {journalTier === 'technical' && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-16 h-16 border-4 border-amber-500/50 rounded-full"></div>
              </div>
            )}
            
            {journalTier === 'annotated' && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-16 h-16 border-4 border-amber-500/50 rounded-full"></div>
                <div className="absolute inset-0 m-auto w-10 h-10 border-2 border-amber-300/70 transform rotate-45"></div>
              </div>
            )}
            
            {/* Particle effects */}
            <div className="absolute -inset-4 pointer-events-none">
              <div className="absolute top-0 left-1/2 w-1 h-1 bg-clinical rounded-full animate-particle1"></div>
              <div className="absolute top-0 left-1/3 w-2 h-2 bg-educational rounded-full animate-particle2"></div>
              <div className="absolute bottom-0 right-1/4 w-1 h-1 bg-qa rounded-full animate-particle3"></div>
            </div>
          </div>
        </div>
        
        {/* Title */}
        <h2 className="text-2xl font-pixel text-white mb-4 animate-glow">
          Journal Acquired!
        </h2>
        
        {/* Description based on tier */}
        <p className="text-gray-300 mb-6">
          {journalTier === 'base' && "You've received a basic notebook to record your observations."}
          {journalTier === 'technical' && "You've received a technical journal with specialized sections for medical physics notes."}
          {journalTier === 'annotated' && "You've received an annotated journal with expert guidance and reference sections!"}
        </p>
        
        {/* Buttons */}
        <div className="flex justify-center space-x-4">
          <button
            className="px-6 py-2 bg-clinical hover:bg-clinical-light text-white font-pixel transition-colors"
            onClick={handleOpenJournal}
          >
            Open Journal
          </button>
          
          <button
            className="px-6 py-2 bg-surface hover:bg-surface-dark text-white font-pixel transition-colors"
            onClick={handleClose}
          >
            Continue
          </button>
        </div>
      </div>
      
      {/* CSS for animations */}
      <style jsx>{`
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        
        @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
        }
        
        @keyframes float {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-10px); }
        }
        
        @keyframes glow {
          0%, 100% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
          50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8); }
        }
        
        @keyframes particle1 {
          0% { transform: translate(0, 0); opacity: 1; }
          100% { transform: translate(-20px, -50px); opacity: 0; }
        }
        
        @keyframes particle2 {
          0% { transform: translate(0, 0); opacity: 1; }
          100% { transform: translate(30px, -40px); opacity: 0; }
        }
        
        @keyframes particle3 {
          0% { transform: translate(0, 0); opacity: 1; }
          100% { transform: translate(-10px, 60px); opacity: 0; }
        }
        
        .animate-fadeIn {
          animation: fadeIn 1s forwards;
        }
        
        .animate-fadeOut {
          animation: fadeOut 1s forwards;
        }
        
        .animate-float {
          animation: float 3s ease-in-out infinite;
        }
        
        .animate-glow {
          animation: glow 2s ease-in-out infinite;
        }
        
        .animate-particle1 {
          animation: particle1 2s ease-out infinite;
        }
        
        .animate-particle2 {
          animation: particle2 2.5s ease-out infinite;
        }
        
        .animate-particle3 {
          animation: particle3 3s ease-out infinite;
        }
      `}</style>
    </div>
  );
}
==== END: app/components/journal/JournalAcquisitionAnimation.tsx ====

==== START: app/components/knowledge/ConstellationView.tsx ====
// app/components/knowledge/ConstellationView.tsx
'use client';
import { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { PixelText, PixelButton } from '../PixelThemeProvider';
import { useKnowledgeStore, KnowledgeDomain, ConceptNode, ConceptConnection, KNOWLEDGE_DOMAINS } from '../../store/knowledgeStore';

// Re-export KNOWLEDGE_DOMAINS for consistency with imports elsewhere
export { KNOWLEDGE_DOMAINS };

interface ConstellationViewProps {
  nightMode?: boolean;
  showLabels?: boolean;
  interactive?: boolean;
  width?: number;
  height?: number;
  onClose?: () => void;
  activeNodes?: string[]; // IDs of nodes to highlight (newly discovered/updated)
  fullscreen?: boolean; // Control fullscreen mode
  enableJournal?: boolean;
}

// Domain color map for direct use in canvas - avoids CSS variable issues
const DOMAIN_COLORS = {
  'radiation-physics': '#3b82f6', // Blue
  'quality-assurance': '#10b981', // Green
  'clinical-practice': '#ec4899', // Pink
  'radiation-protection': '#f59e0b', // Amber
  'technical': '#6366f1', // Indigo
  'theoretical': '#8b5cf6', // Violet
  'general': '#6b7280', // Gray
};

// Light variant colors for highlights
const DOMAIN_COLORS_LIGHT = {
  'radiation-physics': '#93c5fd', // Light blue
  'quality-assurance': '#5eead4', // Light green
  'clinical-practice': '#fbcfe8', // Light pink
  'radiation-protection': '#fcd34d', // Light amber
  'technical': '#a5b4fc', // Light indigo
  'theoretical': '#c4b5fd', // Light violet
  'general': '#9ca3af', // Light gray
};

/**
 * ConstellationView - The interactive knowledge visualization system for medical physics concepts
 * 
 * This streamlined version removes dependencies on external effect systems
 * and connection suggestions, making it more self-contained and resilient.
 */
export default function ConstellationView({ 
  onClose, 
  width, 
  height, 
  interactive = true,
  enableJournal = true,
  activeNodes = [],
  fullscreen = true, // Default to fullscreen
  nightMode = false,
  showLabels = true
}: ConstellationViewProps) {
  // CORE REFS
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const animationFrameRef = useRef<number | null>(null);
  const isComponentMounted = useRef(true);
  
  // STORE ACCESS - Use stable selectors with useCallback
  const nodes = useKnowledgeStore(useCallback(state => state.nodes, []));
  const connections = useKnowledgeStore(useCallback(state => state.connections, []));
  const totalMastery = useKnowledgeStore(useCallback(state => state.totalMastery, []));
  const domainMastery = useKnowledgeStore(useCallback(state => state.domainMastery, [])); 
  const pendingInsights = useKnowledgeStore(useCallback(state => state.pendingInsights, []));
  const newlyDiscovered = useKnowledgeStore(useCallback(state => state.newlyDiscovered, []));
  const journalEntries = useKnowledgeStore(useCallback(state => state.journalEntries, []));
  const resetNewlyDiscovered = useKnowledgeStore(useCallback(state => state.resetNewlyDiscovered, []));

  // STATE MANAGEMENT
  const [activeNode, setActiveNode] = useState<ConceptNode | null>(null);
  const [selectedNode, setSelectedNode] = useState<ConceptNode | null>(null);
  const [pendingConnection, setPendingConnection] = useState<string | null>(null);
  const [journalVisible, setJournalVisible] = useState(false);
  const [recentInsights, setRecentInsights] = useState<{conceptId: string, amount: number}[]>([]);
  const [showHelp, setShowHelp] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(0.8);
  const [cameraPosition, setCameraPosition] = useState({ x: 0, y: 0 });
  
  // INTERACTION STATE
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [isConnecting, setIsConnecting] = useState(false);
  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });
  
  // VISUAL EFFECTS STATE
  const [particleEffects, setParticleEffects] = useState<Array<{
    id: string,
    x: number,
    y: number, 
    targetX: number,
    targetY: number,
    color: string,
    size: number,
    life: number,
    maxLife: number,
    opacity?: number,
    velocity?: { x: number, y: number }
  }>>([]);
  
  // Initialize dimensions based on window size or provided dimensions
  useEffect(() => {
    if (fullscreen) {
      const updateDimensions = () => {
        // Calculate available space (accounting for margins/padding)
        // Using window.innerWidth and window.innerHeight as fallbacks
        const containerWidth = containerRef.current?.parentElement?.clientWidth || window.innerWidth;
        const containerHeight = containerRef.current?.parentElement?.clientHeight || window.innerHeight;
        
        // Subtract some padding to avoid touching the edge of the screen
        const padding = 24;
        setDimensions({
          width: Math.max(800, containerWidth - padding * 2),
          height: Math.max(600, containerHeight - padding * 2)
        });
      };
      
      // Set initial dimensions
      updateDimensions();
      
      // Update dimensions on window resize
      window.addEventListener('resize', updateDimensions);
      
      return () => {
        window.removeEventListener('resize', updateDimensions);
      };
    } else if (width && height) {
      // Use provided dimensions if not fullscreen
      setDimensions({ width, height });
    }
  }, [fullscreen, width, height]);
  
  // MEMOIZE DATA FOR RENDERING
  // Memoize discovered nodes 
  const discoveredNodes = useMemo(() => 
    nodes.filter(node => node.discovered), 
    [nodes]
  );
  
  // Memoize discovered connections
  const discoveredConnections = useMemo(() => 
    connections.filter(conn => conn.discovered), 
    [connections]
  );
  
  // Create a safer version of resetNewlyDiscovered that won't cause update loops
  const safeResetNewlyDiscovered = useCallback(() => {
    // Only call if there are actually newly discovered nodes to reset
    if (newlyDiscovered.length > 0) {
      resetNewlyDiscovered();
    }
  }, [newlyDiscovered, resetNewlyDiscovered]);

  // Track component mounted state for cleanup
  useEffect(() => {
    isComponentMounted.current = true;
    
    return () => {
      isComponentMounted.current = false;
      
      // Cleanup any active animation frame
      if (animationFrameRef.current !== null) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
    };
  }, []);

  // Focus on active nodes passed from parent
  useEffect(() => {
    if (!isComponentMounted.current || activeNodes.length === 0 || nodes.length === 0) return;
    
    // Find the first active node that exists in our nodes list
    const nodeToFocus = nodes.find(n => activeNodes.includes(n.id));
    if (nodeToFocus) {
      setSelectedNode(nodeToFocus);
      
      // Create particle effects for all active nodes
      const newParticles: typeof particleEffects = [];
      
      activeNodes.forEach(nodeId => {
        const node = nodes.find(n => n.id === nodeId);
        if (node?.position) {
          // Create multiple particles for each active node
          for (let i = 0; i < 15; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 100 + 50;
            
            // Use the direct color map instead of CSS variables
            const color = DOMAIN_COLORS[node.domain] || DOMAIN_COLORS.general;
            
            newParticles.push({
              id: `particle-${nodeId}-${i}-${Date.now()}`,
              x: node.position.x + Math.cos(angle) * distance,
              y: node.position.y + Math.sin(angle) * distance,
              targetX: node.position.x,
              targetY: node.position.y,
              color: color,
              size: Math.random() * 3 + 1,
              life: 100,
              maxLife: 100
            });
          }
        }
      });
      
      if (newParticles.length > 0) {
        setParticleEffects(prev => [...prev, ...newParticles]);
        
        // Play success sound effect - REMOVED DEPENDENCY
        // Simply log for now - we'll handle sound elsewhere in the architecture
        console.log('Would play success sound');
      }
    }
  }, [activeNodes, nodes]);
  
  // Also highlight newly discovered nodes from knowledgeStore
  useEffect(() => {
    if (!isComponentMounted.current || newlyDiscovered.length === 0 || nodes.length === 0) return;
    
    // Create particle effects for newly discovered nodes
    const newParticles: typeof particleEffects = [];
    
    newlyDiscovered.forEach(nodeId => {
      const node = nodes.find(n => n.id === nodeId);
      if (node?.position) {
        // Create multiple particles for each newly discovered node
        for (let i = 0; i < 15; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * 100 + 50;
          
          // Use the direct color map instead of CSS variables
          const color = DOMAIN_COLORS[node.domain] || DOMAIN_COLORS.general;
          
          newParticles.push({
            id: `particle-${nodeId}-${i}-${Date.now()}`,
            x: node.position.x + Math.cos(angle) * distance,
            y: node.position.y + Math.sin(angle) * distance,
            targetX: node.position.x,
            targetY: node.position.y,
            color: color,
            size: Math.random() * 3 + 1,
            life: 100,
            maxLife: 100
          });
        }
      }
    });
    
    if (newParticles.length > 0) {
      setParticleEffects(prev => [...prev, ...newParticles]);
    }
  }, [newlyDiscovered, nodes]);
  
  // Track recent insights for journal
  useEffect(() => {
    if (!isComponentMounted.current) return;
    
    // Extract most recent journal entries for display
    if (journalEntries.length > 0) {
      const recentEntries = journalEntries
        .sort((a, b) => b.timestamp - a.timestamp)
        .slice(0, 5)
        .map(entry => ({
          conceptId: entry.conceptId,
          amount: entry.masteryGained
        }));
        
      setRecentInsights(recentEntries);
    } else {
      // For demonstration, we'll use placeholder data
      setRecentInsights([
        { conceptId: 'electron-equilibrium', amount: 15 },
        { conceptId: 'radiation-safety', amount: 30 }
      ]);
    }
  }, [journalEntries]);

  // ANIMATION LOOP
  // Handle particle animations and movement with proper cleanup
  useEffect(() => {
    if (!isComponentMounted.current || particleEffects.length === 0) return;
    
    let active = true;
    
    const animate = () => {
      if (!active || !isComponentMounted.current) return;
      
      let animating = false;
      
      setParticleEffects(prev => {
        // Skip update if component unmounted during animation frame
        if (!active) return prev;
        
        const updatedParticles = prev.map(particle => {
          // Move particle toward target
          const dx = particle.targetX - particle.x;
          const dy = particle.targetY - particle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 5) {
            // Still moving toward target
            animating = true;
            return {
              ...particle,
              x: particle.x + dx * 0.05,
              y: particle.y + dy * 0.05,
              life: particle.life - 1
            };
          } else {
            // At target, handle differently
            if (particle.velocity) {
              // For particles with velocity, continue moving
              return {
                ...particle,
                x: particle.x + particle.velocity.x,
                y: particle.y + particle.velocity.y,
                life: particle.life - 1
              };
            } else {
              // For targeted particles, decay faster once at destination
              return {
                ...particle,
                life: particle.life - 3
              };
            }
          }
        }).filter(p => p.life > 0); // Remove dead particles
        
        return updatedParticles;
      });
      
      // Continue animation if particles still exist or stop
      if (animating && active && isComponentMounted.current) {
        animationFrameRef.current = requestAnimationFrame(animate);
      } else {
        animationFrameRef.current = null;
      }
    };
    
    // Start animation
    animationFrameRef.current = requestAnimationFrame(animate);
    
    // Cleanup function
    return () => {
      active = false;
      if (animationFrameRef.current !== null) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
    };
  }, [particleEffects.length]); // Only depends on length changing

  // RENDERING FUNCTIONS

  // Draw constellation on canvas
  useEffect(() => {
    if (!canvasRef.current || !isComponentMounted.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Apply zoom and camera position transform
    ctx.save();
    ctx.translate(canvas.width / 2 + cameraPosition.x, canvas.height / 2 + cameraPosition.y);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-canvas.width / 2, -canvas.height / 2);
    
    // Draw deep space background
    drawStarryBackground(ctx, canvas.width, canvas.height);
    
    // Draw connections
    drawConnections(ctx);
    
    // Draw nodes
    drawNodes(ctx);
    
    // Draw connecting line when establishing new connection
    drawPendingConnection(ctx);
    
    // Draw particles
    drawParticles(ctx);
    
    // Restore transform
    ctx.restore();
  }, [
    discoveredNodes, 
    discoveredConnections, 
    activeNode, 
    selectedNode, 
    pendingConnection, 
    activeNodes, 
    newlyDiscovered, 
    particleEffects,
    zoomLevel,
    cameraPosition
  ]);

  // Helper: Draw starry background
  const drawStarryBackground = (ctx: CanvasRenderingContext2D, width: number, height: number) => {
    // Fill with deep space color
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, width, height);
    
    // Create distant stars with various brightness
    for (let i = 0; i < 300; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const radius = Math.random() * 1.2;
      const opacity = Math.random() * 0.3 + 0.1;
      
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.fill();
    }
    
    // Add a subtle nebula effect in the background
    for (let i = 0; i < 5; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const radius = Math.random() * 150 + 100;
      
      // Random domain color for nebula with very low opacity
      const domainKeys = Object.keys(DOMAIN_COLORS);
      const randomDomain = domainKeys[Math.floor(Math.random() * domainKeys.length)] as KnowledgeDomain;
      const color = DOMAIN_COLORS[randomDomain];
      
      // Create radial gradient for nebula - using direct rgba values
      const nebula = ctx.createRadialGradient(
        x, y, 0,
        x, y, radius
      );
      
      // Convert hex to rgba with 0.05 opacity for start
      const colorRgba = hexToRgba(color, 0.05);
      
      nebula.addColorStop(0, colorRgba);
      nebula.addColorStop(1, 'rgba(0,0,0,0)');
      
      ctx.fillStyle = nebula;
      ctx.fillRect(0, 0, width, height);
    }
  };

  // Helper: Convert hex color to rgba
  const hexToRgba = (hex: string, alpha: number = 1) => {
    // Remove # if present
    hex = hex.replace('#', '');
    
    // Parse the hex values
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    // Return rgba string
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  };
  
  // Helper: Draw all connections
  const drawConnections = (ctx: CanvasRenderingContext2D) => {
    discoveredConnections.forEach(connection => {
      const sourceNode = discoveredNodes.find(n => n.id === connection.source);
      const targetNode = discoveredNodes.find(n => n.id === connection.target);
      
      if (sourceNode && targetNode && sourceNode.position && targetNode.position) {
        const isActive = 
          (selectedNode?.id === sourceNode.id || selectedNode?.id === targetNode.id) ||
          (pendingConnection === sourceNode.id || pendingConnection === targetNode.id);
          
        // Connection strength affects width and opacity
        const opacity = connection.strength / 200 + 0.3; // 0.3 - 0.8 range
        const width = connection.strength / 100 * 2 + 1; // 1 - 3 range
        
        // Get domain colors from our direct color map
        const sourceColor = DOMAIN_COLORS[sourceNode.domain];
        const targetColor = DOMAIN_COLORS[targetNode.domain];
        
        // Create gradient between the two domain colors
        const gradient = ctx.createLinearGradient(
          sourceNode.position.x, sourceNode.position.y,
          targetNode.position.x, targetNode.position.y
        );
        gradient.addColorStop(0, sourceColor);
        gradient.addColorStop(1, targetColor);
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(sourceNode.position.x, sourceNode.position.y);
        ctx.lineTo(targetNode.position.x, targetNode.position.y);
        
        // Style based on active state
        if (isActive) {
          ctx.strokeStyle = 'white';
          ctx.lineWidth = width + 1;
          ctx.globalAlpha = opacity + 0.2;
          
          // Add glow for active connections
          ctx.shadowColor = 'white';
          ctx.shadowBlur = 8;
        } else {
          ctx.strokeStyle = gradient;
          ctx.lineWidth = width;
          ctx.globalAlpha = opacity;
          ctx.shadowBlur = 0;
        }
        
        // Draw the line
        ctx.stroke();
        
        // Reset shadow and opacity
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }
    });
  };
  
  // Helper: Draw all nodes
  const drawNodes = (ctx: CanvasRenderingContext2D) => {
    discoveredNodes.forEach(node => {
      if (!node.position) return;
      
      // Get domain colors from our direct color maps
      const domainColor = DOMAIN_COLORS[node.domain];
      const domainLightColor = DOMAIN_COLORS_LIGHT[node.domain];
      
      const isActiveNode = activeNode?.id === node.id;
      const isSelectedNode = selectedNode?.id === node.id;
      const isPendingConnection = pendingConnection === node.id;
      const isHighlighted = activeNodes.includes(node.id) || newlyDiscovered.includes(node.id);
      
      // Calculate node size based on mastery (10-20px range)
      const baseSize = 10 + (node.mastery / 100) * 10;
      
      // Increase size if active/selected/highlighted
      const size = isActiveNode || isSelectedNode || isPendingConnection || isHighlighted
        ? baseSize * 1.3
        : baseSize;
        
      // Draw glow for active/highlighted nodes
      if (isActiveNode || isSelectedNode || isPendingConnection || isHighlighted) {
        ctx.beginPath();
        
        // Extra strong glow for highlighted nodes
        const glowRadius = isHighlighted ? size * 2.5 : size * 1.8;
        ctx.arc(node.position.x, node.position.y, glowRadius, 0, Math.PI * 2);
        
        // Create radial gradient for glow
        const glow = ctx.createRadialGradient(
          node.position.x, node.position.y, size * 0.5,
          node.position.x, node.position.y, glowRadius
        );
        
        // Use domain color for glow (direct color references, not CSS vars)
        const color = isHighlighted ? domainLightColor : domainColor;
        
        glow.addColorStop(0, color);
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        
        ctx.fillStyle = glow;
        ctx.fill();
        
        // Add pulsing animation for highlighted nodes
        if (isHighlighted) {
          // Second larger glow
          ctx.beginPath();
          ctx.arc(node.position.x, node.position.y, glowRadius * 1.5, 0, Math.PI * 2);
          
          const outerGlow = ctx.createRadialGradient(
            node.position.x, node.position.y, glowRadius,
            node.position.x, node.position.y, glowRadius * 1.5
          );
          
          // Use rgba directly for outer glow
          outerGlow.addColorStop(0, hexToRgba(domainColor, 0.3));
          outerGlow.addColorStop(1, 'rgba(0,0,0,0)');
          
          ctx.fillStyle = outerGlow;
          ctx.fill();
          
          // Add extra shadow for highlighted nodes
          ctx.shadowColor = domainColor;
          ctx.shadowBlur = 15;
        }
      }
      
      // Draw primary node
      ctx.beginPath();
      ctx.arc(node.position.x, node.position.y, size, 0, Math.PI * 2);
      
      // Fill based on mastery and domain
      if (isHighlighted) {
        // Brighter color for highlighted nodes
        ctx.fillStyle = domainLightColor;
      } else {
        // Normal fill with domain color
        ctx.fillStyle = domainColor;
      }
      
      ctx.fill();
      ctx.shadowBlur = 0; // Reset shadow
      
      // Add inner highlight
      ctx.beginPath();
      ctx.arc(
        node.position.x - size * 0.3, 
        node.position.y - size * 0.3, 
        size * 0.4, 
        0, Math.PI * 2
      );
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.fill();
      
      // Add mastery indicator ring
      if (node.mastery > 0) {
        ctx.beginPath();
        ctx.arc(
          node.position.x, 
          node.position.y, 
          size + 2, 
          -Math.PI / 2, // Start at top
          (Math.PI * 2) * (node.mastery / 100) - Math.PI / 2 // End based on mastery %
        );
        
        // Get light color for domain
        ctx.strokeStyle = domainLightColor;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // Draw labels for active/selected nodes or when showLabels is true
      if ((isActiveNode || isSelectedNode || isHighlighted || showLabels)) {
        const isTemporaryLabel = isActiveNode && !isSelectedNode && !isHighlighted && !showLabels;
        
        // Text background
        ctx.font = '12px Arial, sans-serif';
        const textWidth = ctx.measureText(node.name).width;
        const padding = 4;
        const rectX = node.position.x - textWidth / 2 - padding;
        const rectY = node.position.y + 15 - padding;
        
        ctx.fillStyle = isTemporaryLabel ? 'rgba(26, 30, 36, 0.6)' : 'rgba(26, 30, 36, 0.8)';
        ctx.fillRect(
          rectX, 
          rectY, 
          textWidth + padding * 2, 
          18
        );
        
        // Text
        ctx.fillStyle = isHighlighted ? '#FFFFFF' : domainColor;
        ctx.textAlign = 'center';
        ctx.fillText(node.name, node.position.x, node.position.y + 28);
        
        // Domain indicator
        ctx.fillStyle = domainColor;
        ctx.fillRect(node.position.x - textWidth / 2 - padding, rectY, 3, 18);
      }
    });
  };
  
  // Helper: Draw pending connection line
  const drawPendingConnection = (ctx: CanvasRenderingContext2D) => {
    if (pendingConnection && activeNode) {
      const sourceNode = discoveredNodes.find(n => n.id === pendingConnection);
      if (sourceNode && sourceNode.position && activeNode.position) {
        ctx.beginPath();
        ctx.moveTo(sourceNode.position.x, sourceNode.position.y);
        ctx.lineTo(activeNode.position.x, activeNode.position.y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]); // Create dashed line
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash
      }
    }
  };
  
  // Helper: Draw particles
  const drawParticles = (ctx: CanvasRenderingContext2D) => {
    particleEffects.forEach(particle => {
      ctx.beginPath();
      
      // Fade particles as they near the end of their life
      const opacity = particle.opacity !== undefined 
        ? particle.opacity 
        : particle.life / particle.maxLife;
      
      // Draw particle
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      
      // Use RGBA directly
      ctx.fillStyle = hexToRgba(particle.color, opacity);
      
      ctx.fill();
    });
  };

  // INTERACTION HANDLERS - With left-click drag panning

  // Handle mouse movement for node hover and dragging
  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current || !interactive || !isComponentMounted.current) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    // Handle dragging to move the camera
    if (isDragging) {
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      
      // Update camera position
      setCameraPosition(prev => ({
        x: prev.x + dx,
        y: prev.y + dy
      }));
      
      // Update drag start position
      setDragStart({
        x: e.clientX,
        y: e.clientY
      });
      
      return;
    }
    
    // Apply inverse transforms to get the correct mouse position in the canvas space
    const canvasX = (e.clientX - rect.left);
    const canvasY = (e.clientY - rect.top);
    
    // Convert to scene coordinates
    const sceneX = (canvasX - (canvas.width / 2 + cameraPosition.x)) / zoomLevel + canvas.width / 2;
    const sceneY = (canvasY - (canvas.height / 2 + cameraPosition.y)) / zoomLevel + canvas.height / 2;
    
    // Check if mouse is over any node
    const hoveredNode = discoveredNodes.find(node => {
      if (!node.position) return false;
      
      const baseSize = 10 + (node.mastery / 100) * 10;
      const distance = Math.sqrt(
        Math.pow(node.position.x - sceneX, 2) + 
        Math.pow(node.position.y - sceneY, 2)
      );
      
      return distance <= baseSize + 5; // Add margin for easier hovering
    });
    
    // Update active node
    setActiveNode(hoveredNode || null);
    
    // Update cursor style based on context
    if (hoveredNode) {
      canvas.style.cursor = 'pointer';
    } else if (isDragging) {
      canvas.style.cursor = 'grabbing';
    } else {
      canvas.style.cursor = 'grab';
    }
  }, [isDragging, dragStart, cameraPosition, zoomLevel, discoveredNodes, interactive]);

  // Handle mouse down for both left-click interactions and dragging
  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current || !interactive || !isComponentMounted.current) return;
    
    // Determine if we're over a node
    const isOverNode = activeNode != null;
    
    // Use left button (0) for both node selection and dragging
    if (e.button === 0) {
      if (!isOverNode) {
        // Start dragging if not over a node
        setIsDragging(true);
        setDragStart({
          x: e.clientX,
          y: e.clientY
        });
        
        if (canvasRef.current) {
          canvasRef.current.style.cursor = 'grabbing';
        }
      } else {
        // Note: We'll handle node selection in the click handler
        // This prevents both dragging and node selection at the same time
        setIsConnecting(true);
      }
    }
    
    // Middle button (1) or right button (2) for panning (keep existing behavior)
    if (e.button === 1 || e.button === 2) {
      e.preventDefault();
      setIsDragging(true);
      setDragStart({
        x: e.clientX,
        y: e.clientY
      });
      
      if (canvasRef.current) {
        canvasRef.current.style.cursor = 'grabbing';
      }
    }
  }, [interactive, activeNode]);
  
  // Handle mouse up to end dragging
  const handleMouseUp = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isComponentMounted.current) return;
    
    // End drag regardless of which button was released
    setIsDragging(false);
    setIsConnecting(false);
    
    if (canvasRef.current) {
      canvasRef.current.style.cursor = activeNode ? 'pointer' : 'grab';
    }
  }, [activeNode]);

  // Handle node click - Modified to work with the improved dragging
  const handleClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current || !activeNode || !interactive || isDragging || !isComponentMounted.current) return;
    
    // Handle node interaction for connection making
    if (pendingConnection) {
      // Complete connection if clicking a different node
      if (pendingConnection !== activeNode.id) {
        const sourceNode = discoveredNodes.find(n => n.id === pendingConnection);
        
        if (sourceNode) {
          // Check if connection already exists
          const existingConnection = discoveredConnections.find(
            conn => (conn.source === pendingConnection && conn.target === activeNode.id) ||
                   (conn.source === activeNode.id && conn.target === pendingConnection)
          );
          
          if (!existingConnection) {
            // Create new connection with satisfying feedback
            // Removed direct sound calls - log instead
            console.log('Would play connection success sound');
            
            // Create new connection in store
            useKnowledgeStore.getState().createConnection(pendingConnection, activeNode.id);
            
            // Grant insights based on nodes' mastery
            const insightGain = Math.floor((sourceNode.mastery + activeNode.mastery) / 10) + 5;
            
            // Boost mastery for both nodes
            useKnowledgeStore.getState().updateMastery(pendingConnection, Math.min(5, 100 - sourceNode.mastery));
            useKnowledgeStore.getState().updateMastery(activeNode.id, Math.min(5, 100 - activeNode.mastery));
            
            // Create visual effect where connection is created
            const midX = ((sourceNode.position?.x || 0) + (activeNode.position?.x || 0)) / 2;
            const midY = ((sourceNode.position?.y || 0) + (activeNode.position?.y || 0)) / 2;
            
            // Create particle burst at connection point
            const newParticles: typeof particleEffects = [];
            
            for (let i = 0; i < 20; i++) {
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * 30;
              const startDistance = 5;
              
              newParticles.push({
                id: `connection-particle-${i}-${Date.now()}`,
                x: midX + Math.cos(angle) * startDistance,
                y: midY + Math.sin(angle) * startDistance,
                targetX: midX + Math.cos(angle) * distance,
                targetY: midY + Math.sin(angle) * distance,
                color: '#FFFFFF',
                size: Math.random() * 3 + 1,
                life: 50,
                maxLife: 50
              });
            }
            
            setParticleEffects(prev => [...prev, ...newParticles]);
          }
        }
        
        // Reset pending connection state
        setPendingConnection(null);
      } else {
        // Cancel if clicking the same node
        setPendingConnection(null);
      }
    } else {
      // Select node or start connection
      if (selectedNode?.id === activeNode.id) {
        // Start connection from selected node
        setPendingConnection(activeNode.id);
        
        // Log click sound - removed direct sound call
        console.log('Would play click sound');
      } else {
        // Select node
        setSelectedNode(activeNode);
        
        // Log click sound - removed direct sound call
        console.log('Would play click sound');
      }
    }
  }, [activeNode, discoveredNodes, discoveredConnections, pendingConnection, selectedNode, isDragging, interactive]);

  // Handle zoom with mouse wheel
  const handleWheel = useCallback((e: React.WheelEvent<HTMLCanvasElement>) => {
    if (!interactive || !isComponentMounted.current) return;
    
    // Prevent default scrolling
    e.preventDefault();
    
    // Calculate new zoom level
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    const newZoom = Math.max(0.5, Math.min(2, zoomLevel + delta));
    
    setZoomLevel(newZoom);
  }, [zoomLevel, interactive]);
  
  // Handle closing the constellation view
  const handleClose = useCallback(() => {
    if (!isComponentMounted.current || !onClose) return;
    
    // Reset selected nodes before closing
    setSelectedNode(null);
    setActiveNode(null);
    setPendingConnection(null);
    
    // Let the parent component handle this reset to avoid
    // causing update loops during unmount
    onClose();
  }, [onClose]);
  
  // A simplified version of connection suggestions specifically for use inside the component
  // This replaces the external ConnectionSuggestions dependency
  const renderConnectionSuggestions = () => {
    if (!selectedNode) return null;
    
    // Find possible connections
    const possibleConnections = discoveredNodes.filter(node => 
      // Must be a different node than selected
      node.id !== selectedNode.id && 
      // Must not already be connected
      !discoveredConnections.some(conn => 
        (conn.source === selectedNode.id && conn.target === node.id) ||
        (conn.target === selectedNode.id && conn.source === node.id)
      )
    );

    // If no suggestions, don't render anything
    if (possibleConnections.length === 0) return null;
    
    // Take up to 3 suggestions
    const suggestions = possibleConnections.slice(0, 3);
    
    return (
      <div className="absolute top-4 right-4 w-64 z-10">
        <div className="bg-surface-dark/80 p-3 pixel-borders-thin">
          <PixelText className="text-text-primary mb-2">Suggested Connections</PixelText>
          <div className="space-y-2">
            {suggestions.map(node => (
              <div 
                key={node.id} 
                className="bg-surface p-2 hover:bg-surface-dark cursor-pointer"
                onClick={() => {
                  setPendingConnection(selectedNode.id);
                  setTimeout(() => {
                    // Simulate clicking the suggested node
                    const sourceNode = discoveredNodes.find(n => n.id === selectedNode.id);
                    if (sourceNode) {
                      useKnowledgeStore.getState().createConnection(selectedNode.id, node.id);
                      
                      // Boost mastery slightly for both nodes
                      useKnowledgeStore.getState().updateMastery(selectedNode.id, 3);
                      useKnowledgeStore.getState().updateMastery(node.id, 3);
                      
                      console.log('Would play connection success sound');
                    }
                  }, 100);
                }}
              >
                <div className="flex items-center">
                  <div 
                    className="w-2 h-2 rounded-full mr-2"
                    style={{ backgroundColor: DOMAIN_COLORS[node.domain] }}
                  ></div>
                  <PixelText className="text-sm">{node.name}</PixelText>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  };
  
  return (
    <div 
      ref={containerRef}
      className="relative bg-black pixel-borders"
      style={{ 
        width: dimensions.width, 
        height: dimensions.height,
        maxWidth: '100%',
        maxHeight: '100%'
      }}
    >
      {/* Main canvas */}
      <canvas
        ref={canvasRef}
        width={dimensions.width}
        height={dimensions.height}
        className="w-full h-full"
        onMouseMove={handleMouseMove}
        onClick={handleClick}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        onMouseLeave={() => {
          setIsDragging(false);
          setIsConnecting(false);
        }}
        onWheel={handleWheel}
        onContextMenu={(e) => e.preventDefault()} // Prevent context menu on right-click
      />
      
      {/* Controls and info panels */}
      <div className="absolute top-4 left-4 z-10">
        <div className="bg-surface-dark/80 p-3 pixel-borders-thin text-sm">
          <PixelText className="text-text-primary mb-1">Knowledge Constellation</PixelText>
          <div className="text-text-secondary">
            <div>Discovered: {discoveredNodes.length}/{nodes.length}</div>
            <div>Connections: {discoveredConnections.length}</div>
            <div>Mastery: {totalMastery}%</div>
          </div>
        </div>
      </div>
      
      {/* Simplified connection suggestions panel - internal implementation */}
      {interactive && selectedNode && renderConnectionSuggestions()}
      
      {/* Domains legend */}
      <div className="absolute bottom-4 left-4 bg-surface-dark/80 p-3 pixel-borders-thin z-10">
        <PixelText className="text-text-primary mb-2">Knowledge Domains</PixelText>
        <div className="space-y-1 text-sm">
          {Object.entries(domainMastery)
            .filter(([_, mastery]) => mastery > 0)
            .map(([key, mastery]) => {
              const domain = KNOWLEDGE_DOMAINS[key as KnowledgeDomain];
              if (!domain) return null;
              
              return (
                <div key={key} className="flex items-center">
                  <div 
                    className="w-3 h-3 mr-2" 
                    style={{ backgroundColor: DOMAIN_COLORS[key as KnowledgeDomain] }}
                  ></div>
                  <PixelText className="text-sm">{domain.name}: {mastery}%</PixelText>
                </div>
              );
            })}
        </div>
      </div>
      
      {/* Zoom and camera controls */}
      <div className="absolute bottom-20 right-4 flex flex-col space-y-2 z-10">
        <PixelButton
          className="w-8 h-8 flex items-center justify-center bg-surface-dark"
          onClick={() => setZoomLevel(Math.min(2, zoomLevel + 0.1))}
        >
          +
        </PixelButton>
        <PixelButton
          className="w-8 h-8 flex items-center justify-center bg-surface-dark"
          onClick={() => setZoomLevel(Math.max(0.5, zoomLevel - 0.1))}
        >
          -
        </PixelButton>
        <PixelButton
          className="w-8 h-8 flex items-center justify-center bg-surface-dark"
          onClick={() => {
            setZoomLevel(0.8); // Reset to initial zoom level
            setCameraPosition({ x: 0, y: 0 }); // Reset camera position
          }}
        >
          ↺
        </PixelButton>
      </div>
      
      {/* Bottom action buttons */}
      <div className="absolute bottom-4 right-4 flex space-x-3 z-10">
        {enableJournal && (
          <PixelButton
            className="bg-surface hover:bg-surface-dark text-text-primary"
            onClick={() => setJournalVisible(true)}
          >
            Journal
          </PixelButton>
        )}
        
        <PixelButton
          className="bg-surface hover:bg-surface-dark text-text-primary"
          onClick={() => setShowHelp(true)}
        >
          Help
        </PixelButton>
        
        {onClose && (
          <PixelButton
            className="bg-surface hover:bg-danger text-text-primary"
            onClick={handleClose}
          >
            Close
          </PixelButton>
        )}
      </div>
      
      {/* Selected node details */}
      {selectedNode && (
        <div className="absolute top-1/2 right-4 transform -translate-y-1/2 max-w-xs bg-surface-dark/90 p-3 pixel-borders z-10">
          <div className="flex justify-between items-start">
            <div>
              <div className="flex items-center mb-1">
                <div 
                  className="w-3 h-3 mr-2" 
                  style={{ backgroundColor: DOMAIN_COLORS[selectedNode.domain] }}
                ></div>
                <PixelText className="text-lg">
                  {selectedNode.name}
                </PixelText>
              </div>
              <PixelText className="text-sm text-text-secondary mb-2">{KNOWLEDGE_DOMAINS[selectedNode.domain].name}</PixelText>
            </div>
            
            <div className="bg-surface px-2 py-1 text-sm">
              <PixelText className="text-text-secondary">Mastery:</PixelText>
              <PixelText>{selectedNode.mastery}%</PixelText>
            </div>
          </div>
          
          <PixelText className="text-sm mb-3">{selectedNode.description}</PixelText>
          
          <div className="flex justify-between items-center">
            <PixelText className="text-text-secondary text-xs">
              {pendingConnection === selectedNode.id 
                ? 'Click another node to form connection' 
                : 'Connections: ' + selectedNode.connections.filter(id => 
                    discoveredNodes.some(n => n.id === id)
                  ).length}
            </PixelText>
            
            {!pendingConnection && (
              <PixelButton
                className="text-xs py-1 bg-blue-600 text-white"
                onClick={() => setPendingConnection(selectedNode.id)}
              >
                Connect
              </PixelButton>
            )}
          </div>
        </div>
      )}
      
      {/* Journal overlay */}
      {journalVisible && (
        <div className="absolute inset-0 bg-black/90 z-20 flex items-center justify-center">
          <div className="bg-surface p-6 max-w-md w-full pixel-borders">
            <div className="flex justify-between items-center mb-4">
              <PixelText className="text-2xl">Research Journal</PixelText>
              <PixelButton 
                className="bg-red-600 hover:bg-red-500 text-white" 
                onClick={() => setJournalVisible(false)}
              >
                Close
              </PixelButton>
            </div>
            
            <div className="mb-4">
              <PixelText className="mb-2">Recent Insights</PixelText>
              <div className="space-y-2">
                {recentInsights.map((insight, index) => {
                  const node = discoveredNodes.find(n => n.id === insight.conceptId);
                  if (!node) return null;
                  
                  return (
                    <div 
                      key={`insight-${index}-${insight.conceptId}`}
                      className="p-3 pixel-borders-thin bg-surface-dark"
                    >
                      <div className="flex justify-between items-start">
                        <div className="flex items-center">
                          <div 
                            className="w-3 h-3 mr-2" 
                            style={{ backgroundColor: DOMAIN_COLORS[node.domain] }}
                          ></div>
                          <PixelText>{node.name}</PixelText>
                        </div>
                        <div className="bg-surface px-2 py-0.5 text-sm">
                          <PixelText>{insight.amount}%</PixelText>
                        </div>
                      </div>
                      <PixelText className="text-sm text-text-secondary mt-1">
                        {KNOWLEDGE_DOMAINS[node.domain].name}
                      </PixelText>
                    </div>
                  );
                })}
              </div>
            </div>
            
            <div className="p-3 bg-surface-dark pixel-borders-thin">
              <PixelText className="text-text-secondary text-sm italic">
                As you learn and apply knowledge through challenges, your insights will be recorded here, then transferred to your constellation during the night phase.
              </PixelText>
            </div>
          </div>
        </div>
      )}
      
      {/* Help overlay */}
      {showHelp && (
        <div className="absolute inset-0 bg-black/90 z-20 flex items-center justify-center">
          <div className="bg-surface p-6 max-w-md w-full pixel-borders">
            <div className="flex justify-between items-center mb-4">
              <PixelText className="text-2xl">Constellation Help</PixelText>
              <PixelButton 
                className="bg-red-600 hover:bg-red-500 text-white" 
                onClick={() => setShowHelp(false)}
              >
                Close
              </PixelButton>
            </div>
            
            <div className="space-y-4 mb-4">
              <div>
                <PixelText className="mb-1" style={{ color: DOMAIN_COLORS.theoretical }}>Viewing Knowledge</PixelText>
                <PixelText className="text-sm text-text-secondary">
                  Your constellation represents your knowledge in different domains of medical physics. 
                  Each star is a concept you've learned, with brighter stars indicating higher mastery.
                </PixelText>
              </div>
              
              <div>
                <PixelText className="mb-1" style={{ color: DOMAIN_COLORS.theoretical }}>Creating Connections</PixelText>
                <PixelText className="text-sm text-text-secondary">
                  1. Click on a concept to select it
                  2. Click the "Connect" button or click the concept again to begin a connection
                  3. Click another concept to form a connection
                </PixelText>
                <PixelText className="text-sm text-text-secondary mt-1">
                  Connecting related concepts deepens your understanding and grants additional insight.
                </PixelText>
              </div>
              
              <div>
                <PixelText className="mb-1" style={{ color: DOMAIN_COLORS.theoretical }}>Knowledge Application</PixelText>
                <PixelText className="text-sm text-text-secondary">
                  Your knowledge unlocks new dialogue options and challenge approaches during gameplay.
                  Higher mastery in relevant domains improves your performance in challenges.
                </PixelText>
              </div>
              
              <div>
                <PixelText className="mb-1" style={{ color: DOMAIN_COLORS.theoretical }}>Navigation Controls</PixelText>
                <PixelText className="text-sm text-text-secondary">
                  • Click and drag anywhere to pan the view
                  • Use the mouse wheel to zoom in and out
                  • Right-click and drag also works for panning
                  • Use the +/- buttons to adjust zoom level
                  • Click the ↺ button to reset zoom and position
                </PixelText>
              </div>
            </div>
            
            <div className="p-3 bg-surface-dark pixel-borders-thin">
              <PixelText className="mb-1" style={{ color: DOMAIN_COLORS['clinical-practice'] }}>Pro Tip</PixelText>
              <PixelText className="text-sm text-text-secondary">
                The most powerful insights come from connecting concepts across different domains.
                Try connecting clinical knowledge with radiation physics principles!
              </PixelText>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
==== END: app/components/knowledge/ConstellationView.tsx ====

==== START: app/components/knowledge/KnowledgeUpdate.tsx ====
'use client';
import { useState, useEffect } from 'react';

// Simple pixel text component to replace PixelThemeProvider
const PixelText = ({ className = "", children }: { className?: string, children: React.ReactNode }) => (
  <div className={`font-pixel ${className}`}>{children}</div>
);

interface KnowledgeUpdateProps {
  conceptName: string;
  domainName: string;
  domainColor: string;
  gainAmount: number;
  onComplete?: () => void;
}

/**
 * Knowledge Update - Notification component for knowledge gains
 * Simplified version without sound effects
 */
export default function KnowledgeUpdate({
  conceptName,
  domainName,
  domainColor,
  gainAmount,
  onComplete
}: KnowledgeUpdateProps) {
  const [visible, setVisible] = useState(true);
  const [animationStage, setAnimationStage] = useState<'enter' | 'active' | 'exit'>('enter');
  
  // Animation sequence
  useEffect(() => {
    // Animation sequence
    const enterTimer = setTimeout(() => {
      setAnimationStage('active');
    }, 500);
    
    const activeTimer = setTimeout(() => {
      setAnimationStage('exit');
    }, 2500);
    
    const exitTimer = setTimeout(() => {
      setVisible(false);
      if (onComplete) onComplete();
    }, 3000);
    
    return () => {
      clearTimeout(enterTimer);
      clearTimeout(activeTimer);
      clearTimeout(exitTimer);
    };
  }, [gainAmount, onComplete]);
  
  if (!visible) return null;
  
  // Style based on gain amount
  const getGainStyle = () => {
    if (gainAmount >= 20) {
      return 'text-2xl font-bold';
    } else if (gainAmount >= 10) {
      return 'text-xl';
    } else {
      return 'text-lg';
    }
  };
  
  // Get animation classes based on stage
  const getAnimationClass = () => {
    switch (animationStage) {
      case 'enter':
        return 'opacity-0 scale-95 translate-y-4';
      case 'active':
        return 'opacity-100 scale-100 translate-y-0';
      case 'exit':
        return 'opacity-0 scale-105 -translate-y-4';
    }
  };
  
  return (
    <div 
      className={`
        fixed top-1/4 left-1/2 transform -translate-x-1/2
        z-50 pointer-events-none
        transition-all duration-500 ease-in-out
        ${getAnimationClass()}
      `}
    >
      <div 
        className="bg-surface/90 backdrop-blur-sm pixel-borders p-4 min-w-[300px] max-w-[400px]"
        style={{ borderColor: domainColor }}
      >
        <div className="text-center mb-2">
          <PixelText className="text-educational-light">Knowledge Updated</PixelText>
        </div>
        
        <div className="flex items-center justify-between mb-3">
          <div>
            <PixelText className="text-md font-medium">{conceptName}</PixelText>
            <PixelText className="text-sm text-text-secondary">{domainName}</PixelText>
          </div>
          
          <div 
            className={`${getGainStyle()} font-pixel`}
            style={{ color: domainColor }}
          >
            +{gainAmount}%
          </div>
        </div>
        
        {/* Progress visualization */}
        <div className="w-full h-2 bg-surface-dark">
          <div 
            className="h-full"
            style={{ 
              width: `${gainAmount}%`,
              backgroundColor: domainColor,
              transition: 'width 1s ease-in-out'
            }}
          ></div>
        </div>
        
        {/* Insight bonus for significant gains */}
        {gainAmount >= 15 && (
          <div className="mt-2 text-center">
            <PixelText className="text-sm text-clinical-light">+{Math.floor(gainAmount / 5)} Insight Bonus</PixelText>
          </div>
        )}
        
        {/* Special indicator for major knowledge updates */}
        {gainAmount >= 25 && (
          <div className="absolute -top-2 -right-2 w-6 h-6 bg-educational rounded-full flex items-center justify-center text-white text-xs">
            ⭐
          </div>
        )}
      </div>
    </div>
  );
}
==== END: app/components/knowledge/KnowledgeUpdate.tsx ====

==== START: app/components/gameplay/MomentumCounter.tsx ====
// app/components/gameplay/MomentumCounter.tsx
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useResourceStore, MAX_MOMENTUM_LEVEL } from '../../store/resourceStore';

interface MomentumCounterProps {
  showLabel?: boolean;
  className?: string;
  compact?: boolean;
  level?: number;
  // Optional override for displaying specific level
  consecutiveCorrect?: number;
  // Optional consecutive counter
}

/**
 * Momentum Counter Component - Enhanced with Juice!
 *
 * Visual representation of player's momentum level, inspired by resource
 * meters in roguelites like Hades.
 * Shows pips that fill up as the player
 * builds momentum with correct answers.
 */
export default function MomentumCounter({
  showLabel = true,
  className = '',
  compact = false,
  level: overrideLevel,
  consecutiveCorrect: overrideConsecutive
}: MomentumCounterProps) {
  // Get resource state, but allow override
  const {
    momentum: storeMomentum,
    consecutiveCorrect: storeConsecutive,
    momentumEffect
  } = useResourceStore();
  // Use override if provided, otherwise use store value
  const momentum = overrideLevel !== undefined ? overrideLevel : storeMomentum;
  const consecutiveCorrect = overrideConsecutive !== undefined ? overrideConsecutive : storeConsecutive;

  // Animation state
  const [pulseEffect, setPulseEffect] = useState(false);
  // **NEW**: State to track momentum changes for animation
  const [momentumChanged, setMomentumChanged] = useState<'gain' | 'loss' | null>(null);
  const [prevMomentum, setPrevMomentum] = useState(momentum);

  // **NEW**: Detect momentum changes for animations
  useEffect(() => {
    if (momentum > prevMomentum) {
      setMomentumChanged('gain');
    } else if (momentum < prevMomentum) {
      setMomentumChanged('loss');
    }
    // Reset after a short delay
    const timer = setTimeout(() => setMomentumChanged(null), 500);
    setPrevMomentum(momentum); // Update previous momentum
    return () => clearTimeout(timer);
  }, [momentum, prevMomentum]);


  // Handle effect animations
  useEffect(() => {
    if (momentumEffect.active) {
      setPulseEffect(true);

      // Clear effect after animation
      const timer = setTimeout(() => {
        setPulseEffect(false);
      }, momentumEffect.duration);

      return () => clearTimeout(timer);
    }
  }, [momentumEffect]);
  // Create array of MAX_MOMENTUM_LEVEL length for rendering pips
  const momentumPips = Array.from({ length: MAX_MOMENTUM_LEVEL }, (_, i) => i < momentum);
  // Calculate progress to next level
  const nextLevelThreshold = momentum < MAX_MOMENTUM_LEVEL ?
  (momentum + 1) * 2 : Infinity;
  const progressToNextLevel = momentum < MAX_MOMENTUM_LEVEL
    ?
  (consecutiveCorrect % 2) / 2 // 0 or 0.5
    : 0;
  // Get color intensity based on momentum level
  const getMomentumColor = (level: number) => {
    if (level === 0) return { bg: 'bg-gray-800', border: 'border-gray-700', pulse: 'rgba(255, 140, 0, 0.3)', text: 'text-gray-400' };
  if (level === 1) return { bg: 'bg-orange-900', border: 'border-orange-800', pulse: 'rgba(255, 140, 0, 0.4)', text: 'text-orange-300' };
  if (level === 2) return { bg: 'bg-orange-700', border: 'border-orange-600', pulse: 'rgba(255, 140, 0, 0.5)', text: 'text-orange-200' };
  return { bg: 'bg-orange-500', border: 'border-orange-400', pulse: 'rgba(255, 140, 0, 0.7)', text: 'text-orange-100' };
  };
  return (
    <div className={`${className}`}>
      <div className="flex items-center justify-between mb-1">
        {showLabel && (
          <div className={`font-pixel ${compact ? 'text-sm' : 'text-base'} text-orange-300`}>
            {compact ? 'MOM' : 'MOMENTUM'} {/* Shorten label in compact */}
          </div>
        )}

        {/* Show consecutive correct count */}
         {!compact && (
          <AnimatePresence mode="wait">
            <motion.div
              key={consecutiveCorrect}
              className="ml-2 font-pixel text-sm text-orange-300/80 tabular-nums"
              initial={{ opacity: 0, y: -5 }}
              animate={{ opacity: 1,
  y: 0 }}
              exit={{ opacity: 0, y: 5 }}
            >
              {consecutiveCorrect > 0 ? `${consecutiveCorrect}×` : ''}
            </motion.div>
          </AnimatePresence>
        )}

        {/*
  "Max" indicator when at max momentum */}
        {momentum === MAX_MOMENTUM_LEVEL && !compact && (
          <motion.div
            className="ml-auto font-pixel text-sm text-orange-300 font-bold animate-pulse-strong" // **NEW**: Added strong pulse animation class
            initial={{ opacity: 0 }}
            animate={{
              opacity: [0.7, 1, 0.7],
         transition: { repeat: Infinity, duration: 1.5 }
            }}
          >
            MAX! {/* **NEW**: Added exclamation */}
          </motion.div>
        )}
      </div>

      {/* Render momentum pips with improved visual design */}
      <div className="flex space-x-2 items-center">
         {momentumPips.map((filled, index) => {
          const colors = getMomentumColor(filled ?
  index + 1 : 0);

          return (
            <motion.div // **NEW**: Wrap pip in motion.div
              key={`pip-${index}`}
              className={`relative ${compact ? 'w-8 h-8' : 'w-10 h-10'} rounded-full
                ${filled ? colors.bg : 'bg-gray-900'}
                border-2 ${filled ? colors.border : 'border-gray-800'}

                 ${filled && index === MAX_MOMENTUM_LEVEL - 1 ? 'animate-pulse' : ''}`}
              style={{
                boxShadow: filled ? `0 0 8px ${colors.pulse}` : 'none',
                transition: 'all 0.3s ease-in-out'
              }}
              // **NEW**: Add animation based on momentum change
              initial={{ scale: 1 }}
              animate={{
                scale: momentumChanged === 'gain' && index === momentum - 1 ? [1, 1.3, 1] : // Scale pulse on gain
                       momentumChanged === 'loss' && index === momentum ? [1, 0.7, 1] : // Scale down on loss
                       1,
              }}
              transition={{ duration: 0.3 }}
           >
              {/* Inner texture for filled pips */}
              {filled && (
                <div
                  className="absolute inset-0 rounded-full opacity-70"

  style={{
                    backgroundImage: index === 2
                      ? `url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='6' height='6' fill='%23c2410c'/%3E%3Crect x='0' y='0' width='2' height='2' fill='%23ea580c'/%3E%3Crect x='4' y='0' width='2' height='2' fill='%23ea580c'/%3E%3Crect x='2' y='2' width='2' height='2' fill='%23ea580c'/%3E%3Crect x='0' y='4' width='2' height='2' fill='%23ea580c'/%3E%3Crect x='4' y='4' width='2' height='2' fill='%23ea580c'/%3E%3C/svg%3E")`

       : index === 1
                      ?

  `url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='4' height='4' fill='%23c2410c'/%3E%3Crect x='0' y='0' width='1' height='1' fill='%23ea580c'/%3E%3Crect x='2' y='2' width='1' height='1' fill='%23ea580c'/%3E%3C/svg%3E")`
                      : `url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='4' height='4' fill='%23ea580c'/%3E%3Crect x='0' y='0' width='1' height='1' fill='%23f97316'/%3E%3Crect x='2' y='2' width='1' height='1' fill='%23f97316'/%3E%3C/svg%3E")`,
                    backgroundSize: index === 2 ?
  '6px 6px' : '4px 4px',
                    imageRendering: 'pixelated'
                  }}
                />
              )}


   {/* Central highlight dot */}
              {filled && (
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-1 h-1 bg-white rounded-full opacity-80"></div>
              )}

              {/* Partial fill for pip in progress */}

              {!filled && index === momentum && progressToNextLevel > 0 && (
                <motion.div
                  className="absolute bottom-0 left-0 right-0 bg-orange-800/60 rounded-b-full"
                  style={{

  height: `${progressToNextLevel * 100}%`,
                    borderBottomLeftRadius: '100%',
                    borderBottomRightRadius: '100%',
                    backgroundImage: `url("data:image/svg+xml,%3Csvg width='2' height='2' viewBox='0 0 2 2' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='2' height='2' fill='%23c2410c'/%3E%3Crect x='0' y='0' width='1' height='1' fill='%23ea580c'/%3E%3C/svg%3E")`,

     backgroundSize: '2px 2px',
                    imageRendering: 'pixelated'
                  }}
                  initial={{ height: 0 }}
                  animate={{

     height: `${progressToNextLevel * 100}%`,
                    transition: { type: 'spring', damping: 15 }
                  }}
                />
              )}


           {/* Pulse effect for active pips */}
              {filled && pulseEffect && (
                <motion.div
                  className="absolute inset-0 rounded-full bg-orange-500"
                  initial={{ opacity: 0, scale: 0.8 }}

             animate={{
                    opacity: [0, 0.8, 0],
                    scale: [0.8, 1.2, 1.5],
                    transition: {

   duration: 0.8,
                      repeat: momentumEffect.intensity === 'high' ?
  2 : 1
                    }
                  }}
                />
              )}

              {/* Level
  indicator */}
              {filled && (
                <div className="absolute inset-0 flex items-center justify-center">
                  <span className={`text-xs font-bold ${colors.text} font-pixel`}> {/* **NEW**: Dynamic text color */}
                    {index + 1}

  </span>
                </div>
              )}
            </motion.div> // End motion.div wrapper
          );
  })}
      </div>

      {/* Status messages below the counter */}
      <AnimatePresence>
        {momentum > 0 && momentum < MAX_MOMENTUM_LEVEL && (
          <motion.div
            className="mt-1 text-xs font-pixel text-orange-300/80"
            initial={{ opacity: 0, height: 0 }}

  animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
          >
            {momentum === 1 && "Building momentum..."}
            {momentum === 2 && "High momentum!"}
          </motion.div>
        )}
      </AnimatePresence>


     {/* Special notification for max momentum */}
      <AnimatePresence>
        {momentum === MAX_MOMENTUM_LEVEL && (
          <motion.div
            className="mt-1 text-xs font-pixel text-orange-300 font-bold"
            initial={{ opacity: 0, y: -5 }}
            animate={{
              opacity: 1,

               y: 0,
              transition: { type: 'spring', damping: 10 }
            }}
            exit={{ opacity: 0, y: 5 }}
          >
            {/* **NEW**: More exciting text */}
            MAX MOMENTUM! EXTRAPOLATE Unlocked!
  </motion.div>
        )}
      </AnimatePresence>

      {/* **NEW**: Momentum break effect overlay */}
      <AnimatePresence>
          {momentumChanged === 'loss' && (
              <motion.div
                  className="absolute inset-0 bg-red-700/30 backdrop-blur-sm z-10 flex items-center justify-center"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: [0, 1, 0], transition: { duration: 0.6 } }}
                  exit={{ opacity: 0 }}
              >
                  <motion.div
                      className="text-red-200 text-2xl font-pixel font-bold animate-shake-strong" // Use strong shake
                      initial={{ scale: 0.5 }}
                      animate={{ scale: [1, 1.1, 1], transition: { duration: 0.4 } }}
                  >
                      MOMENTUM BROKEN!
                  </motion.div>
              </motion.div>
          )}
      </AnimatePresence>
    </div>
  );
 }
==== END: app/components/gameplay/MomentumCounter.tsx ====

==== START: app/components/gameplay/InsightMeter.tsx ====
// app/components/gameplay/InsightMeter.tsx
'use client';
import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useResourceStore, RESOURCE_THRESHOLDS } from '../../store/resourceStore';

interface InsightMeterProps {
  showLabel?: boolean;
  showValue?: boolean;
  className?: string;
  size?: 'sm' | 'md' | 'lg' | 'xl';
  compact?: boolean;
  vertical?: boolean;
  showAnimation?: boolean;
}

/**
 * Insight Meter Component - Enhanced Visual Design
 * 
 * A strategic resource meter inspired by roguelite persistent resources
 * (like Darkness in Hades). Features clear threshold markers and
 * distinctive visual states as player approaches key unlocks.
 */
export default function InsightMeter({
  showLabel = true,
  showValue = true,
  className = '',
  size = 'md',
  compact = false,
  vertical = false,
  showAnimation = false
}: InsightMeterProps) {
  // Get resource state
  const { 
    insight, 
    insightMax, 
    insightEffect,
  } = useResourceStore();
  
  // Refs for tracking previous values
  const prevInsightRef = useRef(insight);
  
  // Local state
  const [insightDelta, setInsightDelta] = useState(0);
  const [pulseEffect, setPulseEffect] = useState(false);
  const [thresholdCrossed, setThresholdCrossed] = useState<number | null>(null);
  const [actionAvailable, setActionAvailable] = useState<string | null>(null);
  
  // Calculate fill percentage
  const fillPercentage = Math.min(100, Math.max(0, (insight / insightMax) * 100));
  
  // Process insight changes and threshold crossings
  useEffect(() => {
    const prevPercentage = (prevInsightRef.current / insightMax) * 100;
    
    // Calculate delta for animation
    const delta = insight - prevInsightRef.current;
    if (delta !== 0) {
      setInsightDelta(delta);
      // Clear delta after animation duration
      const clearTimer = setTimeout(() => setInsightDelta(0), 1500);
      return () => clearTimeout(clearTimer);
    }
    
    // Check if we crossed important thresholds
    const thresholds = [
      { value: 25, name: 'REFRAME' },
      { value: 50, name: 'EXTRAPOLATE' },
      { value: 75, name: 'SYNTHESIS' }
    ];
    
    thresholds.forEach(threshold => {
      if (prevPercentage < threshold.value && fillPercentage >= threshold.value) {
        setThresholdCrossed(threshold.value);
        setActionAvailable(threshold.name);
        setTimeout(() => setThresholdCrossed(null), 2000);
      }
    });
    
    prevInsightRef.current = insight;
  }, [insight, insightMax, fillPercentage]);
  
  // Handle animation from gameplay effect
  useEffect(() => {
    if (insightEffect.active || showAnimation) {
      setPulseEffect(true);
      
      const timer = setTimeout(() => {
        setPulseEffect(false);
      }, insightEffect.duration || 2000);
      
      return () => clearTimeout(timer);
    }
  }, [insightEffect, showAnimation]);
  
  // Size classes based on orientation
  const sizeClasses = vertical 
    ? {
        sm: "w-2 h-32",
        md: "w-4 h-40",
        lg: "w-6 h-48",
        xl: "w-8 h-64"
      }
    : {
        sm: "h-2 w-full",
        md: "h-4 w-full",
        lg: "h-6 w-full",
        xl: "h-8 w-full"
      };
  
  // Get appropriate fill color based on level
  const getFillColor = () => {
    if (fillPercentage >= 75) return '#2dd4bf'; // Teal for highest tier
    if (fillPercentage >= 50) return '#a855f7'; // Purple for medium tier
    if (fillPercentage >= 25) return '#3b82f6'; // Blue for first tier
    return '#1d4ed8'; // Dark blue for starting tier
  };
  
  // Get appropriate shader colors
  const getShaderColors = () => {
    if (fillPercentage >= 75) {
      return {
        darkShade: '#0d9488',
        lightShade: '#5eead4',
        pattern: 'teal',
        glow: 'rgba(45, 212, 191, 0.5)'
      };
    }
    if (fillPercentage >= 50) {
      return {
        darkShade: '#7e22ce',
        lightShade: '#c084fc',
        pattern: 'purple',
        glow: 'rgba(168, 85, 247, 0.5)'
      };
    }
    return {
      darkShade: '#1d4ed8',
      lightShade: '#60a5fa',
      pattern: 'blue',
      glow: 'rgba(59, 130, 246, 0.4)'
    };
  };
  
  // Get pattern SVG for the fill texture
  const getPatternSvg = () => {
    const { darkShade, lightShade } = getShaderColors();
    const darkHex = darkShade.replace('#', '');
    const lightHex = lightShade.replace('#', '');
    
    return `url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='4' height='4' fill='%23${darkHex}'/%3E%3Crect width='1' height='1' fill='%23${lightHex}'/%3E%3Crect x='2' y='2' width='1' height='1' fill='%23${lightHex}'/%3E%3C/svg%3E")`;
  };
  
  // Threshold markers with improved visualization
  const thresholdMarkers = [
    { 
      percent: 25, 
      label: 'R', 
      action: 'REFRAME',
      colorClass: 'blue' 
    },
    { 
      percent: 50, 
      label: 'E', 
      action: 'EXTRAPOLATE',
      colorClass: 'purple' 
    },
    { 
      percent: 75, 
      label: 'S', 
      action: 'SYNTHESIS',
      colorClass: 'teal' 
    }
  ];
  
  return (
    <div className={`${className} ${vertical ? 'flex items-end' : ''}`}>
      {/* Header with label and value display */}
      <div className={`flex items-center justify-between ${vertical ? 'flex-col mr-2' : 'mb-1'}`}>
        {showLabel && (
          <div className={`
            font-pixel 
            text-${fillPercentage >= 75 ? 'teal' : fillPercentage >= 50 ? 'purple' : 'blue'}-300
            ${compact ? 'text-sm' : 'text-base'} tracking-wider
            ${vertical ? 'rotate-90 origin-bottom-right transform translate-y-6' : ''}
          `}>
            INSIGHT
          </div>
        )}
        
        {showValue && (
          <div className={`
            font-pixel text-sm tabular-nums 
            text-${fillPercentage >= 75 ? 'teal' : fillPercentage >= 50 ? 'purple' : 'blue'}-200
            ${vertical ? 'mt-2' : ''}
          `}>
            <AnimatePresence mode="wait">
              <motion.span
                key={insight}
                initial={{ opacity: 0, y: -5 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: 5 }}
                transition={{ duration: 0.2 }}
              >
                {insight}
              </motion.span>
            </AnimatePresence>
            /{insightMax}
          </div>
        )}
      </div>
      
      {/* Main meter container */}
      <div className={`
        relative bg-blue-900/30 ${sizeClasses[size]}
        overflow-hidden
        ${vertical ? 'flex flex-col-reverse' : ''}
      `}
      style={{ 
        imageRendering: 'pixelated',
        borderWidth: '2px',
        borderStyle: 'solid',
        borderImage: 'url("data:image/svg+xml,%3Csvg width=\'3\' height=\'3\' viewBox=\'0 0 3 3\' fill=\'none\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Crect width=\'1\' height=\'1\' fill=\'%231a1f2e\'/%3E%3Crect width=\'3\' height=\'3\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\'/%3E%3C/svg%3E") 2 stretch'
      }}>
        {/* Enhanced pixelated fill with dynamic color and pattern */}
        <motion.div
          className={`absolute ${vertical ? 'inset-x-0 bottom-0' : 'inset-y-0 left-0'}`}
          style={{ 
            backgroundImage: getPatternSvg(),
            backgroundSize: '4px 4px',
            imageRendering: 'pixelated',
            boxShadow: `0 0 8px ${getShaderColors().glow}`,
            [vertical ? 'height' : 'width']: `${fillPercentage}%` 
          }}
          initial={{ [vertical ? 'height' : 'width']: `${fillPercentage}%` }}
          animate={{ 
            [vertical ? 'height' : 'width']: `${fillPercentage}%`,
            transition: { 
              type: 'spring', 
              damping: 30,
              stiffness: 400
            }
          }}
        >
          {/* Scan lines effect */}
          <div 
            className="absolute inset-0 mix-blend-overlay opacity-30"
            style={{
              backgroundImage: `url("data:image/svg+xml,%3Csvg width='2' height='2' viewBox='0 0 2 2' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect y='1' width='2' height='1' fill='%23000000'/%3E%3C/svg%3E")`,
              backgroundSize: '2px 2px',
              imageRendering: 'pixelated'
            }}
          />
          
          {/* Animated scanline */}
          <motion.div 
            className="absolute inset-0 bg-white/10 origin-top"
            style={{ scaleY: 0.05 }}
            animate={{ 
              top: ['-10%', '110%'],
              transition: { 
                repeat: Infinity, 
                duration: 1.5, 
                ease: 'linear',
                repeatDelay: 1
              }
            }}
          />
        </motion.div>
        
        {/* Threshold markers with improved visibility */}
        {thresholdMarkers.map((marker, index) => {
          const isActive = fillPercentage >= marker.percent;
          const isHighlighted = thresholdCrossed === marker.percent;
          const markerColor = marker.colorClass === 'teal' 
            ? (isActive ? 'text-teal-400' : 'text-teal-900') 
            : marker.colorClass === 'purple'
              ? (isActive ? 'text-purple-400' : 'text-purple-900')
              : (isActive ? 'text-blue-400' : 'text-blue-900');
          
          return (
            <div 
              key={`threshold-${index}`} 
              className={`absolute ${vertical ? 'inset-x-0' : 'inset-y-0'}`} 
              style={{ 
                [vertical ? 'bottom' : 'left']: `${marker.percent}%`, 
                zIndex: 2
              }}
            >
              {/* Marker line */}
              <div className={`
                ${vertical ? 'h-1 w-full' : 'w-1 h-full'} 
                ${isActive 
                  ? marker.colorClass === 'teal' 
                    ? 'bg-teal-400' 
                    : marker.colorClass === 'purple' 
                      ? 'bg-purple-400' 
                      : 'bg-blue-400'
                  : 'bg-gray-700'
                }
                ${isHighlighted ? 'animate-pulse' : ''}
              `}></div>
              
              {/* Action label */}
              {!compact && size !== 'sm' && (
                <div className={`
                  absolute 
                  ${vertical 
                    ? 'left-full ml-1 -translate-y-1/2' 
                    : '-top-6 -translate-x-1/2'} 
                  text-xs font-pixel
                  ${markerColor}
                  ${isHighlighted ? 'text-glow-sm animate-pulse' : ''}
                  ${isActive ? 'font-bold' : 'opacity-50'}
                `}
                style={{
                  textShadow: isHighlighted 
                    ? `0 0 6px ${marker.colorClass === 'teal' 
                        ? '#2dd4bf' 
                        : marker.colorClass === 'purple' 
                          ? '#a855f7' 
                          : '#3b82f6'
                      }`
                    : 'none'
                }}>
                  {marker.label}
                </div>
              )}
              
              {/* Threshold crossing animation */}
              {isHighlighted && (
                <motion.div 
                  className={`
                    absolute ${vertical ? 'inset-x-0 h-3' : 'inset-y-0 w-3'} 
                    ${marker.colorClass === 'teal' 
                      ? 'bg-teal-400' 
                      : marker.colorClass === 'purple' 
                        ? 'bg-purple-400' 
                        : 'bg-blue-400'
                    }
                  `}
                  initial={{ opacity: 0.8 }}
                  animate={{ 
                    opacity: [0.8, 0.3, 0],
                    [vertical ? 'height' : 'width']: ['3px', '16px', '24px'],
                    transition: { duration: 0.8 }
                  }}
                />
              )}
            </div>
          );
        })}
        
        {/* Pulse effect animation */}
        <AnimatePresence>
          {pulseEffect && (
            <motion.div
              className="absolute inset-0 bg-white/20"
              initial={{ opacity: 0 }}
              animate={{ 
                opacity: [0, 0.4, 0],
                transition: { 
                  repeat: insightEffect.intensity === 'high' ? 3 : 2,
                  duration: 0.5 
                }
              }}
              exit={{ opacity: 0 }}
            />
          )}
        </AnimatePresence>
        
        {/* Delta indicator */}
        <AnimatePresence>
          {insightDelta !== 0 && (
            <motion.div
              className={`
                absolute ${vertical ? 'right-full mr-1' : 'bottom-full mb-1'} 
                font-pixel text-xs ${insightDelta > 0 ? 'text-green-400' : 'text-red-400'}
              `}
              initial={{ opacity: 0, y: insightDelta > 0 ? 10 : -10 }}
              animate={{ 
                opacity: 1, 
                y: 0,
                transition: { type: 'spring', damping: 15 }
              }}
              exit={{ 
                opacity: 0, 
                y: insightDelta > 0 ? -10 : 10,
                transition: { duration: 0.3 }
              }}
            >
              {insightDelta > 0 ? '+' : ''}{insightDelta}
            </motion.div>
          )}
        </AnimatePresence>
        
        {/* Decorative corners */}
        <div className="absolute top-0 left-0 w-1 h-1 bg-white/50"></div>
        <div className="absolute top-0 right-0 w-1 h-1 bg-white/30"></div>
        <div className="absolute bottom-0 left-0 w-1 h-1 bg-white/20"></div>
        <div className="absolute bottom-0 right-0 w-1 h-1 bg-black/30"></div>
      </div>
      
      {/* Action unlocked notification */}
      <AnimatePresence>
        {actionAvailable && (
          <motion.div
            className={`
              mt-1 text-xs font-pixel 
              ${actionAvailable === 'SYNTHESIS' 
                ? 'text-teal-300' 
                : actionAvailable === 'EXTRAPOLATE' 
                  ? 'text-purple-300' 
                  : 'text-blue-300'
              }
              ${vertical ? 'ml-2' : ''}
            `}
            initial={{ opacity: 0, y: 5 }}
            animate={{ 
              opacity: 1, 
              y: 0, 
              transition: { type: 'spring', damping: 15 }
            }}
            exit={{ opacity: 0, y: -5 }}
          >
            {actionAvailable} unlocked!
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Threshold labels */}
      {size === 'lg' && !compact && !vertical && (
        <div className="flex justify-between text-2xs mt-1 px-1">
          <div className="text-gray-400">0</div>
          <div className={fillPercentage >= 25 ? 'text-blue-400' : 'text-gray-600'}>25◆</div>
          <div className={fillPercentage >= 50 ? 'text-purple-400' : 'text-gray-600'}>50◆</div>
          <div className={fillPercentage >= 75 ? 'text-teal-400' : 'text-gray-600'}>75◆</div>
          <div className="text-gray-400">100</div>
        </div>
      )}
      
      {/* Vertical mode threshold labels */}
      {size === 'lg' && !compact && vertical && (
        <div className="flex flex-col justify-between text-2xs text-gray-400 ml-1 py-1 h-full">
          <div>100</div>
          <div className={fillPercentage >= 75 ? 'text-teal-400' : 'text-gray-600'}>75◆</div>
          <div className={fillPercentage >= 50 ? 'text-purple-400' : 'text-gray-600'}>50◆</div>
          <div className={fillPercentage >= 25 ? 'text-blue-400' : 'text-gray-600'}>25◆</div>
          <div>0</div>
        </div>
      )}
    </div>
  );
}
==== END: app/components/gameplay/InsightMeter.tsx ====

==== START: app/components/gameplay/StrategicActions.tsx ====
// app/components/gameplay/StrategicActions.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useResourceStore } from '../../store/resourceStore';
import { PixelText } from '../PixelThemeProvider';

// Type definitions
type StrategicActionType = 'reframe' | 'extrapolate' | 'boast' | 'synthesis';

interface StrategicActionsProps {
  characterId: string;
  stageId: string;
  className?: string;
  onActionActivate?: (actionType: StrategicActionType) => void;
  onActionComplete?: (actionType: StrategicActionType, successful: boolean) => void;
  onActionCancel?: (actionType: StrategicActionType) => void;
}

/**
 * Strategic Actions Component
 * 
 * Control options that help shape dialogue flow using action icons
 */
export default function StrategicActions({
  characterId,
  stageId,
  className = '',
  onActionActivate,
  onActionComplete,
  onActionCancel
}: StrategicActionsProps) {
  // Track hover and expanded states
  const [hoveredAction, setHoveredAction] = useState<StrategicActionType | null>(null);
  
  // Access resource store for action availability
  const { availableActions, activeAction, insight } = useResourceStore();
  
  // Action definitions with metadata
  const actionDefinitions: Record<StrategicActionType, {
    label: string;
    description: string;
    cost: number;
    bgClass: string;
    borderClass: string;
    iconPath: string;
  }> = {
    reframe: {
      label: 'Reframe',
      description: 'Shift to more approachable topics',
      cost: 25,
      bgClass: 'bg-blue-800',
      borderClass: 'border-blue-900',
      iconPath: "M4,4 H12 M4,8 H12 M4,12 H10" // Simple text-line icon SVG path
    },
    extrapolate: {
      label: 'Extrapolate',
      description: 'Form connections between concepts',
      cost: 50,
      bgClass: 'bg-purple-800',
      borderClass: 'border-purple-900',
      iconPath: "M5,8 L8,5 M9,6 L12,3 M8,9 L11,6" // Connect-the-dots icon
    },
    boast: {
      label: 'Challenge',
      description: 'Demonstrate expert knowledge',
      cost: 0, // Uses momentum instead
      bgClass: 'bg-orange-700',
      borderClass: 'border-orange-800',
      iconPath: "M8,3 L12,7 L8,11 L4,7 Z" // Diamond shape
    },
    synthesis: {
      label: 'Synthesis',
      description: 'Discover new knowledge domains',
      cost: 75,
      bgClass: 'bg-green-700',
      borderClass: 'border-green-900',
      iconPath: "M4,5 H12 M4,8 H10 M4,11 H8" // Narrowing text lines
    }
  };
  
  // SVG icon component for pixel art icons
  const PixelIcon = ({ path, className = '' }: { path: string, className?: string }) => (
    <svg 
      width="16" 
      height="16" 
      viewBox="0 0 16 16" 
      fill="none" 
      className={`stroke-white stroke-[1.5px] ${className}`}
      style={{ imageRendering: 'pixelated' }}
    >
      <path d={path} strokeLinecap="square" />
    </svg>
  );
  
  // Button component for strategic actions
  const ActionButton = ({ 
    type, 
    isAvailable 
  }: { 
    type: StrategicActionType, 
    isAvailable: boolean 
  }) => {
    const def = actionDefinitions[type];
    const isActive = activeAction === type;
    const affordabilityClass = def.cost > 0 && insight < def.cost ? 'opacity-50' : '';
    
    return (
      <motion.button
        className={`
          w-16 h-16 relative 
          ${def.bgClass} ${def.borderClass}
          border-2 box-content
          flex items-center justify-center
          transition-colors duration-150
          ${isActive ? 'ring-1 ring-white' : ''}
          ${isAvailable ? '' : 'opacity-40'}
          ${affordabilityClass}
          pixel-borders
        `}
        disabled={!isAvailable || (def.cost > 0 && insight < def.cost)}
        onClick={() => isAvailable && onActionActivate && onActionActivate(type)}
        onMouseEnter={() => setHoveredAction(type)}
        onMouseLeave={() => setHoveredAction(null)}
        whileHover={{ y: isAvailable ? -2 : 0 }}
        whileTap={{ y: isAvailable ? 1 : 0 }}
        initial={{ scale: 1 }}
        animate={isActive ? { 
          scale: [1, 1.05, 1],
          transition: { repeat: Infinity, duration: 1.5 }
        } : { scale: 1 }}
      >
        <PixelIcon path={def.iconPath} className="w-8 h-8" />
        
        {/* Cost indicator */}
        {def.cost > 0 && (
          <div className="absolute -bottom-1 -right-1 text-sm bg-black/80 px-1 rounded-sm">
            {def.cost}◆
          </div>
        )}
        
        {/* Active indicator pulse */}
        {isActive && (
          <motion.div 
            className="absolute inset-0 bg-white"
            initial={{ opacity: 0 }}
            animate={{ 
              opacity: [0, 0.3, 0],
              transition: { repeat: Infinity, duration: 2 }
            }}
          />
        )}
        
        {/* Tooltip on hover */}
        <AnimatePresence>
          {hoveredAction === type && !isActive && (
            <motion.div
              className="absolute top-full mt-2 left-1/2 -translate-x-1/2 w-48 z-50
                        bg-gray-900/95 border border-gray-700 pixel-borders-thin shadow-lg"
              initial={{ opacity: 0, y: -5, scale: 0.95 }}
              animate={{ opacity: 1, y: 0, scale: 1 }}
              exit={{ opacity: 0, y: -5, scale: 0.95 }}
              transition={{ duration: 0.15 }}
            >
              <div className="p-3">
                <div className="text-sm font-pixel text-white mb-1">{def.label}</div>
                <div className="text-xs text-gray-300">{def.description}</div>
                {def.cost > 0 ? (
                  <div className={`text-xs mt-1 ${insight >= def.cost ? 'text-blue-300' : 'text-red-300'}`}>
                    Cost: {def.cost} Insight
                  </div>
                ) : (
                  <div className="text-xs mt-1 text-orange-300">
                    Requires max momentum
                  </div>
                )}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.button>
    );
  };
  
  // Render the action buttons with proper spacing
  return (
    <div className={`flex items-center gap-3 ${className}`}>
      {availableActions.reframe && <ActionButton type="reframe" isAvailable={availableActions.reframe} />}
      {availableActions.extrapolate && <ActionButton type="extrapolate" isAvailable={availableActions.extrapolate} />}
      {availableActions.synthesis && <ActionButton type="synthesis" isAvailable={availableActions.synthesis} />}
    </div>
  );
}

/**
 * Container version with expanded state support
 */
export function StrategicActionsContainer(props: StrategicActionsProps) {
  const { activeAction } = useResourceStore();
  
  return (
    <div className="relative">
      <StrategicActions {...props} />
      
      {/* Expanded state panel - shows when an action is active */}
      <AnimatePresence>
        {activeAction && (
          <motion.div
            className="absolute top-full right-0 mt-3 bg-gray-900/90 border border-gray-700 
                      pixel-borders shadow-lg z-50"
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
          >
            <div className="p-3 w-48">
              <PixelText className="text-sm mb-2 text-white">
                {activeAction === 'reframe' && 'Reframing Conversation'}
                {activeAction === 'extrapolate' && 'Extrapolating Connections'}
                {activeAction === 'boast' && 'Challenge Mode Active'}
                {activeAction === 'synthesis' && 'Synthesizing Knowledge'}
              </PixelText>
              
              <div className="text-xs text-gray-300">
                {activeAction === 'reframe' && 'Simpler topics now available.'}
                {activeAction === 'extrapolate' && 'Form connections between concepts.'}
                {activeAction === 'boast' && 'Expert-level questions with higher rewards.'}
                {activeAction === 'synthesis' && 'Discover new knowledge areas.'}
              </div>
              
              {/* Optional cancel button */}
              <button 
                className="mt-2 text-xs text-gray-400 hover:text-white"
                onClick={() => props.onActionCancel && props.onActionCancel(activeAction)}
              >
                Cancel (recover cost)
              </button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
==== END: app/components/gameplay/StrategicActions.tsx ====

==== START: app/components/debug/VerticalSliceDebugPanel.tsx ====
// app/components/debug/VerticalSliceDebugPanel.tsx
'use client';
import { useState, useEffect, useRef } from 'react';
import { useGameStore } from '../../store/gameStore';
import { useDialogueStateMachine } from '../../core/dialogue/DialogueStateMachine';
import { useJournalStore } from '../../store/journalStore';
import { useGameState } from '../../core/statemachine/GameStateMachine';
import { useEventBus } from '../../core/events/CentralEventBus';
import { useKnowledgeStore } from '../../store/knowledgeStore';
import { GameEventType } from '../../core/events/EventTypes';

/**
 * Enhanced Vertical Slice Debug Panel
 * 
 * A powerful debug panel with QoL features for testing and development:
 * - Collapsible sections for better organization
 * - Copy to clipboard functionality for sharing state
 * - Visual timeline of critical events
 * - State visualization with visual indicators of health
 * - Direct state manipulations for faster testing
 */
export default function VerticalSliceDebugPanel() {
  // Panel UI state
  const [isExpanded, setIsExpanded] = useState(true);
  const [activeTab, setActiveTab] = useState<'overview' | 'events' | 'state' | 'tools'>('overview');
  const [copiedFeedback, setCopiedFeedback] = useState(false);
  const [criticalEvents, setCriticalEvents] = useState<Array<{event: string, timestamp: number}>>([]);
  const [consoleOutput, setConsoleOutput] = useState<string[]>([]);
  
  // Visibility toggles for sections
  const [sections, setSections] = useState({
    criticalPath: true,
    playerState: true,
    journalState: true, 
    dialogueState: true,
    events: true,
    tools: true
  });
  
  // Ref for auto-scrolling event log
  const eventsEndRef = useRef<HTMLDivElement>(null);
  
  // Game state from core systems
  const gameState = useGameState();
  const dialogueState = useDialogueStateMachine();
  const gameStore = useGameStore();
  const journalStore = useJournalStore();
  const knowledgeStore = useKnowledgeStore();
  
  // Track critical path events
  useEffect(() => {
    const eventBus = useEventBus.getState();
    
    // Subscribe to critical events
    const unsubDialogueEvents = eventBus.subscribe(
      GameEventType.DIALOGUE_CRITICAL_PATH,
      (event) => {
        setCriticalEvents(prev => [
          ...prev, 
          { 
            event: `Critical dialogue: ${event.payload.criticalStateId}`, 
            timestamp: Date.now() 
          }
        ]);
        addConsoleMessage(`🔑 Critical path: ${event.payload.criticalStateId}`);
      }
    );
    
    const unsubJournalEvents = eventBus.subscribe(
      GameEventType.JOURNAL_ACQUIRED,
      (event) => {
        setCriticalEvents(prev => [
          ...prev, 
          { 
            event: `Journal acquired: ${event.payload.tier}`, 
            timestamp: Date.now() 
          }
        ]);
        addConsoleMessage(`📓 Journal acquired: ${event.payload.tier} (from ${event.payload.character})`);
      }
    );
    
    const unsubPhaseEvents = eventBus.subscribe(
      GameEventType.GAME_PHASE_CHANGED,
      (event) => {
        setCriticalEvents(prev => [
          ...prev, 
          { 
            event: `Phase changed: ${event.payload.from} → ${event.payload.to}`, 
            timestamp: Date.now() 
          }
        ]);
        addConsoleMessage(`🔄 Phase change: ${event.payload.from} → ${event.payload.to}`);
      }
    );
    
    const unsubKnowledgeEvents = eventBus.subscribe(
      GameEventType.KNOWLEDGE_GAINED,
      (event) => {
        addConsoleMessage(`✨ Knowledge gained: ${event.payload.conceptId} +${event.payload.amount}%`);
      }
    );
    
    // Clean up subscriptions
    return () => {
      unsubDialogueEvents();
      unsubJournalEvents();
      unsubPhaseEvents();
      unsubKnowledgeEvents();
    };
  }, []);
  
  // Auto-scroll event log
  useEffect(() => {
    if (eventsEndRef.current) {
      eventsEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [consoleOutput]);
  
  // Helper to add console messages
  const addConsoleMessage = (message: string) => {
    const timestamp = new Date().toLocaleTimeString();
    setConsoleOutput(prev => {
      const newOutput = [...prev, `[${timestamp}] ${message}`];
      // Keep only the latest 100 messages
      if (newOutput.length > 100) {
        return newOutput.slice(-100);
      }
      return newOutput;
    });
  };
  
  // Critical path steps
  const criticalPathSteps = [
    {
      id: 'game-initialized',
      label: 'Game Initialized',
      isComplete: !!gameStore.map,
      details: gameStore.map ? `Map ID: ${gameStore.map.seed || 'unknown'}` : 'Not initialized'
    },
    {
      id: 'calibration-node-selected',
      label: 'Calibration Node Selected',
      isComplete: !!gameStore.currentNodeId && (
        gameStore.currentNodeId.includes('kapoor') || 
        gameStore.currentNodeId.includes('calibration')
      ),
      details: gameStore.currentNodeId || 'No node selected'
    },
    {
      id: 'dialogue-started',
      label: 'Dialogue Started',
      isComplete: dialogueState.isActive,
      details: dialogueState.isActive 
        ? `Current node: ${dialogueState.currentNodeId || 'unknown'}` 
        : 'Not started'
    },
    {
      id: 'journal-acquired',
      label: 'Journal Acquired',
      isComplete: journalStore.hasJournal,
      details: journalStore.hasJournal 
        ? `Journal Tier: ${journalStore.currentUpgrade}` 
        : 'Not acquired'
    },
    {
      id: 'night-phase',
      label: 'Night Phase Transition',
      isComplete: gameState.gamePhase === 'night' || gameState.gamePhase === 'transition_to_night',
      details: `Current Phase: ${gameState.gamePhase}`
    },
    {
      id: 'new-day',
      label: 'New Day Started',
      isComplete: gameState.currentDay > 1,
      details: `Current Day: ${gameState.currentDay}`
    }
  ];
  
  // Get completion percentage for progress bar
  const completionPercentage = criticalPathSteps.filter(step => step.isComplete).length / 
                              criticalPathSteps.length * 100;
  
  // Only render in development
  if (process.env.NODE_ENV === 'production') return null;
  
  // Generate state summary for clipboard
  const generateStateSummary = () => {
    const summary = {
      gameState: {
        phase: gameState.gamePhase,
        day: gameState.currentDay,
        currentNodeId: gameStore.currentNodeId,
        completedNodes: gameStore.completedNodeIds,
        player: gameStore.player
      },
      journalState: {
        acquired: journalStore.hasJournal,
        tier: journalStore.currentUpgrade,
        entryCount: journalStore.entries?.length
      },
      dialogueState: {
        active: dialogueState.isActive,
        currentNodeId: dialogueState.currentNodeId
      },
      knowledgeState: {
        totalMastery: knowledgeStore.totalMastery,
        discoveredNodes: knowledgeStore.nodes.filter(n => n.discovered).length,
        totalNodes: knowledgeStore.nodes.length,
        connections: knowledgeStore.connections.length
      },
      criticalPath: {
        progress: `${criticalPathSteps.filter(step => step.isComplete).length}/${criticalPathSteps.length}`,
        percentage: completionPercentage.toFixed(0) + '%',
        missingSteps: criticalPathSteps.filter(step => !step.isComplete).map(step => step.id)
      },
      environment: {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent
      }
    };
    
    return JSON.stringify(summary, null, 2);
  };
  
  // Copy state summary to clipboard
  const copyStateSummary = () => {
    const summary = generateStateSummary();
    navigator.clipboard.writeText(summary);
    setCopiedFeedback(true);
    setTimeout(() => setCopiedFeedback(false), 2000);
    addConsoleMessage('📋 Copied state summary to clipboard');
  };
  
  // Force critical progression (for debugging)
  const forceGiveJournal = () => {
    if (!journalStore.hasJournal) {
      journalStore.initializeJournal('technical');
      
      // Log debug action
      useEventBus.getState().dispatch(
        GameEventType.UI_BUTTON_CLICKED,
        {
          componentId: 'vsDebugPanel',
          action: 'forceJournalAcquisition',
          metadata: { timestamp: Date.now() }
        }
      );
      
      setCriticalEvents(prev => [
        ...prev, 
        { event: 'DEBUG: Forced journal acquisition', timestamp: Date.now() }
      ]);
      
      addConsoleMessage('🔧 DEBUG: Forced journal acquisition');
    }
  };
  
  const forceNightPhase = () => {
    if (gameState.gamePhase === 'day') {
      gameState.completeDay();
      
      // Log debug action
      useEventBus.getState().dispatch(
        GameEventType.UI_BUTTON_CLICKED,
        {
          componentId: 'vsDebugPanel',
          action: 'forceNightPhase',
          metadata: { timestamp: Date.now() }
        }
      );
      
      setCriticalEvents(prev => [
        ...prev, 
        { event: 'DEBUG: Forced night phase', timestamp: Date.now() }
      ]);
      
      addConsoleMessage('🔧 DEBUG: Forced night phase transition');
    }
  };
  
  const forceNewDay = () => {
    if (gameState.gamePhase === 'night') {
      gameState.completeNight();
      
      // Log debug action
      useEventBus.getState().dispatch(
        GameEventType.UI_BUTTON_CLICKED,
        {
          componentId: 'vsDebugPanel',
          action: 'forceNewDay',
          metadata: { timestamp: Date.now() }
        }
      );
      
      setCriticalEvents(prev => [
        ...prev, 
        { event: 'DEBUG: Forced new day', timestamp: Date.now() }
      ]);
      
      addConsoleMessage('🔧 DEBUG: Forced new day transition');
    }
  };
  
  const resetGame = () => {
    localStorage.removeItem('rogue-resident-game');
    localStorage.removeItem('rogue-resident-journal');
    localStorage.removeItem('rogue-resident-knowledge');
    window.location.reload();
  };
  
  const forceKnowledgeGain = () => {
    // Award some knowledge to radiation-dosimetry concept
    knowledgeStore.updateMastery('radiation-dosimetry', 15);
    knowledgeStore.discoverConcept('radiation-dosimetry');
    
    // Log action
    addConsoleMessage('🔧 DEBUG: Added 15% mastery to radiation-dosimetry');
  };
  
  // Toggle section visibility
  const toggleSection = (section: keyof typeof sections) => {
    setSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };
  
  return (
    <div
      className="fixed top-1/2 right-0 transform -translate-y-1/2 bg-gray-900/90 text-white z-50 rounded-l-lg shadow-xl overflow-hidden transition-all duration-300"
      style={{
        width: isExpanded ? '350px' : '40px',
        height: isExpanded ? '550px' : '160px',
        maxHeight: '80vh'
      }}
    >
      {/* Header with toggle */}
      <div 
        className="py-2 px-3 bg-blue-600 flex justify-between items-center cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        {isExpanded ? (
          <>
            <span className="font-semibold">Vertical Slice Debugger</span>
            <span>×</span>
          </>
        ) : (
          <span 
            style={{ 
              writingMode: 'vertical-rl', 
              textOrientation: 'mixed',
              transform: 'rotate(180deg)',
              width: '100%',
              textAlign: 'center' 
            }}
          >
            VS Debug
          </span>
        )}
      </div>
      
      {/* Expanded content */}
      {isExpanded && (
        <div className="flex flex-col h-full">
          {/* Tab navigation */}
          <div className="flex border-b border-gray-700">
            <button 
              className={`px-4 py-1 ${activeTab === 'overview' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}
              onClick={() => setActiveTab('overview')}
            >
              Overview
            </button>
            <button 
              className={`px-4 py-1 ${activeTab === 'events' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}
              onClick={() => setActiveTab('events')}
            >
              Events
            </button>
            <button 
              className={`px-4 py-1 ${activeTab === 'state' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}
              onClick={() => setActiveTab('state')}
            >
              State
            </button>
            <button 
              className={`px-4 py-1 ${activeTab === 'tools' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}
              onClick={() => setActiveTab('tools')}
            >
              Tools
            </button>
          </div>
          
          {/* Tab content container */}
          <div className="flex-grow overflow-y-auto">
            {/* OVERVIEW TAB */}
            {activeTab === 'overview' && (
              <div className="p-3">
                {/* Progress overview */}
                <div 
                  className="px-3 py-2 bg-gray-800 mb-4 rounded"
                  onClick={() => toggleSection('criticalPath')}
                >
                  <div className="flex justify-between items-center mb-1 cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.criticalPath ? '▼' : '►'}</span>
                      Critical Path Progress
                    </div>
                    <div className="text-xs text-gray-400">
                      {criticalPathSteps.filter(step => step.isComplete).length}/{criticalPathSteps.length}
                    </div>
                  </div>
                  
                  <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
                    <div 
                      className="h-full bg-blue-500"
                      style={{ width: `${completionPercentage}%` }}
                    ></div>
                  </div>
                  
                  {/* Critical path steps */}
                  {sections.criticalPath && (
                    <div className="space-y-2 mt-3">
                      {criticalPathSteps.map((step, index) => (
                        <div key={step.id} className="relative">
                          {/* Step connection line */}
                          {index < criticalPathSteps.length - 1 && (
                            <div 
                              className="absolute left-[12px] top-[24px] w-[2px] h-[28px]"
                              style={{ 
                                backgroundColor: step.isComplete ? '#4ade80' : '#6b7280',
                                opacity: step.isComplete ? 1 : 0.5
                              }}
                            ></div>
                          )}
                          
                          {/* Step indicator */}
                          <div className="flex items-start">
                            <div 
                              className="w-6 h-6 rounded-full flex items-center justify-center flex-shrink-0 mt-1"
                              style={{ 
                                backgroundColor: step.isComplete ? '#4ade80' : '#6b7280',
                                opacity: step.isComplete ? 1 : 0.5
                              }}
                            >
                              {step.isComplete ? '✓' : index + 1}
                            </div>
                            <div className="ml-3">
                              <div 
                                className="font-medium" 
                                style={{ 
                                  color: step.isComplete ? '#4ade80' : '#d1d5db',
                                  opacity: step.isComplete ? 1 : 0.8
                                }}
                              >
                                {step.label}
                              </div>
                              <div className="text-xs text-gray-400 mt-1">
                                {step.details}
                              </div>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
                
                {/* Game state display */}
                <div 
                  className="px-3 py-2 bg-gray-800 mb-3 rounded"
                  onClick={() => toggleSection('playerState')}
                >
                  <div className="flex justify-between items-center cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.playerState ? '▼' : '►'}</span>
                      Game State
                    </div>
                    <div className="px-2 py-0.5 text-xs rounded" style={{
                      backgroundColor: 
                        gameState.gamePhase === 'day' ? 'rgba(59, 130, 246, 0.5)' : 
                        gameState.gamePhase === 'night' ? 'rgba(124, 58, 237, 0.5)' :
                        'rgba(209, 213, 219, 0.2)'
                    }}>
                      {gameState.gamePhase}
                    </div>
                  </div>
                  
                  {sections.playerState && (
                    <div className="mt-2 text-xs space-y-1 bg-gray-900 p-2 rounded">
                      <div className="flex justify-between">
                        <span className="text-gray-400">Current Day:</span>
                        <span>{gameState.currentDay}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Player Health:</span>
                        <span>{gameStore.player.health}/{gameStore.player.maxHealth}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Insight:</span>
                        <span>{gameStore.player.insight}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Selected Node:</span>
                        <span className="truncate max-w-[160px]">{gameStore.currentNodeId || 'none'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Completed Nodes:</span>
                        <span>{gameStore.completedNodeIds.length}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Inventory Items:</span>
                        <span>{gameStore.inventory.length}</span>
                      </div>
                    </div>
                  )}
                </div>
                
                {/* Journal state section */}
                <div 
                  className="px-3 py-2 bg-gray-800 mb-3 rounded"
                  onClick={() => toggleSection('journalState')}
                >
                  <div className="flex justify-between items-center cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.journalState ? '▼' : '►'}</span>
                      Journal State
                    </div>
                    <div className="px-2 py-0.5 text-xs rounded" style={{
                      backgroundColor: journalStore.hasJournal ? 'rgba(16, 185, 129, 0.5)' : 'rgba(239, 68, 68, 0.5)'
                    }}>
                      {journalStore.hasJournal ? 'Acquired' : 'Missing'}
                    </div>
                  </div>
                  
                  {sections.journalState && journalStore.hasJournal && (
                    <div className="mt-2 text-xs space-y-1 bg-gray-900 p-2 rounded">
                      <div className="flex justify-between">
                        <span className="text-gray-400">Journal Tier:</span>
                        <span>{journalStore.currentUpgrade}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Entries:</span>
                        <span>{journalStore.entries?.length || 0}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Opened:</span>
                        <span>{journalStore.isOpen ? 'Yes' : 'No'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Current Page:</span>
                        <span>{journalStore.currentPage}</span>
                      </div>
                      {journalStore.hasKapoorReferenceSheets && (
                        <div className="text-green-400">Has Kapoor reference sheets</div>
                      )}
                      {journalStore.hasKapoorAnnotatedNotes && (
                        <div className="text-green-400">Has Kapoor annotated notes</div>
                      )}
                    </div>
                  )}
                </div>
                
                {/* Knowledge state summary */}
                <div className="px-3 py-2 bg-gray-800 mb-3 rounded">
                  <div className="flex justify-between items-center">
                    <div className="text-sm font-medium">Knowledge State</div>
                    <div className="px-2 py-0.5 text-xs bg-purple-500/50 rounded">
                      {knowledgeStore.totalMastery}% Mastery
                    </div>
                  </div>
                  
                  <div className="mt-2 text-xs space-y-1">
                    <div className="flex justify-between">
                      <span className="text-gray-400">Discovered:</span>
                      <span>{knowledgeStore.nodes.filter(n => n.discovered).length}/{knowledgeStore.nodes.length}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Connections:</span>
                      <span>{knowledgeStore.connections.length}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Newly Discovered:</span>
                      <span>{knowledgeStore.newlyDiscovered.length}</span>
                    </div>
                  </div>
                </div>
                
                {/* Copy state button */}
                <button
                  className={`w-full py-2 px-3 rounded text-sm font-medium mb-3 ${
                    copiedFeedback 
                      ? 'bg-green-500 text-white' 
                      : 'bg-blue-600 hover:bg-blue-500 text-white'
                  }`}
                  onClick={copyStateSummary}
                >
                  {copiedFeedback ? 'Copied to Clipboard!' : 'Copy State Summary'}
                </button>
              </div>
            )}
            
            {/* EVENTS TAB */}
            {activeTab === 'events' && (
              <div className="p-3">
                <div className="flex justify-between items-center mb-3">
                  <div className="text-sm font-medium">Event Console</div>
                  <button 
                    className="px-2 py-0.5 bg-gray-700 hover:bg-gray-600 text-xs rounded"
                    onClick={() => setConsoleOutput([])}
                  >
                    Clear
                  </button>
                </div>
                
                {/* Console output */}
                <div className="bg-gray-900 p-2 rounded text-xs font-mono h-[410px] overflow-y-auto mb-3">
                  {consoleOutput.length === 0 ? (
                    <div className="text-gray-500 italic">No events logged yet</div>
                  ) : (
                    consoleOutput.map((message, idx) => (
                      <div key={idx} className="mb-1 break-all">{message}</div>
                    ))
                  )}
                  <div ref={eventsEndRef} />
                </div>
                
                <div className="text-xs text-gray-400">
                  Recent critical events are logged here automatically.
                </div>
              </div>
            )}
            
            {/* STATE TAB */}
            {activeTab === 'state' && (
              <div className="p-3">
                <div className="text-sm font-medium mb-3">State Details</div>
                
                {/* Dialogue state */}
                <div 
                  className="px-3 py-2 bg-gray-800 mb-3 rounded"
                  onClick={() => toggleSection('dialogueState')}
                >
                  <div className="flex justify-between items-center cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.dialogueState ? '▼' : '►'}</span>
                      Dialogue System
                    </div>
                    <div className="px-2 py-0.5 text-xs rounded" style={{
                      backgroundColor: dialogueState.isActive ? 'rgba(16, 185, 129, 0.5)' : 'rgba(209, 213, 219, 0.2)'
                    }}>
                      {dialogueState.isActive ? 'Active' : 'Inactive'}
                    </div>
                  </div>
                  
                  {sections.dialogueState && dialogueState.isActive && (
                    <div className="mt-2 text-xs space-y-1 bg-gray-900 p-2 rounded">
                      <div className="flex justify-between">
                        <span className="text-gray-400">Current Node:</span>
                        <span className="truncate max-w-[160px]">{dialogueState.currentNodeId || 'unknown'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Flow ID:</span>
                        <span className="truncate max-w-[160px]">
                          {dialogueState.activeFlow?.id || 'unknown'}
                        </span>
                      </div>
                      {dialogueState.selectedOption && (
                        <div className="flex justify-between">
                          <span className="text-gray-400">Selected Option:</span>
                          <span>{dialogueState.selectedOption.id}</span>
                        </div>
                      )}
                      <div className="flex justify-between">
                        <span className="text-gray-400">Showing Response:</span>
                        <span>{dialogueState.showResponse ? 'Yes' : 'No'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Showing Backstory:</span>
                        <span>{dialogueState.showBackstory ? 'Yes' : 'No'}</span>
                      </div>
                    </div>
                  )}
                </div>
                
                {/* Domain mastery details */}
                <div className="px-3 py-2 bg-gray-800 mb-3 rounded">
                  <div className="flex justify-between items-center mb-2">
                    <div className="text-sm font-medium">Domain Mastery</div>
                    <div className="px-2 py-0.5 text-xs bg-purple-500/50 rounded">
                      {knowledgeStore.totalMastery}%
                    </div>
                  </div>
                  
                  {/* Domain bars */}
                  {Object.entries(knowledgeStore.domainMastery).map(([domain, mastery]) => (
                    <div key={domain} className="mb-2">
                      <div className="flex justify-between text-xs mb-1">
                        <span>{domain}</span>
                        <span>{mastery}%</span>
                      </div>
                      <div className="w-full h-1.5 bg-gray-700 rounded-full overflow-hidden">
                        <div 
                          className="h-full rounded-full"
                          style={{ 
                            width: `${mastery}%`,
                            backgroundColor: getDomainColor(domain as KnowledgeDomain)
                          }}
                        ></div>
                      </div>
                    </div>
                  ))}
                </div>
                
                {/* Local storage info */}
                <div className="px-3 py-2 bg-gray-800 mb-3 rounded">
                  <div className="text-sm font-medium mb-2">Local Storage</div>
                  <div className="text-xs space-y-1">
                    <div className="flex justify-between">
                      <span className="text-gray-400">Game Store:</span>
                      <span>{checkLocalStorage('rogue-resident-game')}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Journal Store:</span>
                      <span>{checkLocalStorage('rogue-resident-journal')}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Knowledge Store:</span>
                      <span>{checkLocalStorage('rogue-resident-knowledge')}</span>
                    </div>
                  </div>
                </div>
              </div>
            )}
            
            {/* TOOLS TAB */}
            {activeTab === 'tools' && (
              <div className="p-3">
                <div className="text-sm font-medium mb-3">Debug Tools</div>
                
                {/* Debug actions */}
                <div 
                  className="px-3 py-2 bg-gray-800 mb-3 rounded"
                  onClick={() => toggleSection('tools')}
                >
                  <div className="flex justify-between items-center cursor-pointer">
                    <div className="text-sm font-medium flex items-center">
                      <span className="mr-1">{sections.tools ? '▼' : '►'}</span>
                      Game Actions
                    </div>
                  </div>
                  
                  {sections.tools && (
                    <div className="grid grid-cols-2 gap-2 mt-3">
                      <button 
                        className="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-500"
                        onClick={forceGiveJournal}
                        disabled={journalStore.hasJournal}
                      >
                        Give Journal
                      </button>
                      
                      <button 
                        className="px-2 py-1 bg-purple-600 text-white text-xs rounded hover:bg-purple-500"
                        onClick={forceNightPhase}
                        disabled={gameState.gamePhase !== 'day'}
                      >
                        Night Phase
                      </button>
                      
                      <button 
                        className="px-2 py-1 bg-yellow-600 text-white text-xs rounded hover:bg-yellow-500"
                        onClick={forceNewDay}
                        disabled={gameState.gamePhase !== 'night'}
                      >
                        New Day
                      </button>
                      
                      <button 
                        className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-500"
                        onClick={forceKnowledgeGain}
                      >
                        Add Knowledge
                      </button>
                      
                      <button 
                        className="px-2 py-1 bg-indigo-600 text-white text-xs rounded hover:bg-indigo-500"
                        onClick={() => gameStore.updateInsight(10)}
                      >
                        +10 Insight
                      </button>
                      
                      <button 
                        className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-500"
                        onClick={resetGame}
                      >
                        Reset Game
                      </button>
                    </div>
                  )}
                </div>
                
                {/* Advanced debugging tools */}
                <div className="px-3 py-2 bg-gray-800 mb-3 rounded">
                  <div className="text-sm font-medium mb-2">Advanced Tools</div>
                  
                  <div className="space-y-2">
                    <button 
                      className="w-full px-2 py-1 bg-gray-700 text-white text-xs rounded hover:bg-gray-600 text-left"
                      onClick={() => {
                        // Force a completion of all critical path steps
                        if (!journalStore.hasJournal) {
                          journalStore.initializeJournal('technical');
                        }
                        
                        // Ensure a node is completed
                        if (gameStore.completedNodeIds.length === 0 && kapoorNodeId) {
                          gameStore.completeNode(kapoorNodeId);
                        }
                        
                        addConsoleMessage('🔧 Force-completed critical path steps');
                      }}
                    >
                      Force Critical Path Completion
                    </button>
                    
                    <button 
                      className="w-full px-2 py-1 bg-gray-700 text-white text-xs rounded hover:bg-gray-600 text-left"
                      onClick={() => {
                        // Open the browser console
                        console.log('%c🔍 Debug Tools', 'font-size: 14px; font-weight: bold; color: #3b82f6;');
                        console.log('Game State:', gameStore);
                        console.log('Journal State:', journalStore);
                        console.log('Knowledge State:', knowledgeStore);
                        console.log('Dialogue State:', dialogueState);
                        
                        addConsoleMessage('🔍 Dumped state objects to browser console');
                      }}
                    >
                      Dump State to Console
                    </button>
                    
                    <button 
                      className="w-full px-2 py-1 bg-gray-700 text-white text-xs rounded hover:bg-gray-600 text-left"
                      onClick={() => {
                        // Check if recovery functions are available
                        if (typeof window.__PROGRESSION_RESOLVER__ !== 'undefined') {
                          try {
                            const result = window.__PROGRESSION_RESOLVER__.validateDayToNightTransition();
                            addConsoleMessage(`🔧 Progression validation: ${result ? 'Passed' : 'Failed'}`);
                          } catch (e) {
                            addConsoleMessage(`❌ Error in progression validation: ${e}`);
                          }
                        } else {
                          addConsoleMessage('❌ Progression resolver not available');
                        }
                      }}
                    >
                      Validate Progression State
                    </button>
                  </div>
                </div>
                
                <div className="text-xs text-gray-400">
                  These tools directly modify game state and may cause unexpected behavior.
                  Use them only for debugging and testing.
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

// Helper function to determine domain color
function getDomainColor(domain: string): string {
  const domainColors: Record<string, string> = {
    'radiation-physics': '#3b82f6', // blue
    'quality-assurance': '#10b981', // green
    'clinical-practice': '#ec4899', // pink
    'radiation-protection': '#f59e0b', // amber
    'technical': '#6366f1', // indigo
    'theoretical': '#8b5cf6', // violet
    'general': '#6b7280', // gray
  };
  
  return domainColors[domain] || '#6b7280';
}

// Helper to check if a specific item exists in localStorage
function checkLocalStorage(key: string): string {
  try {
    const item = localStorage.getItem(key);
    return item ? `${Math.round(item.length / 1024)}KB` : 'Not found';
  } catch (e) {
    return 'Error';
  }
}

// Type definition for KnowledgeDomain
type KnowledgeDomain = 
  | 'radiation-physics'
  | 'quality-assurance'
  | 'clinical-practice'
  | 'radiation-protection'
  | 'technical'
  | 'theoretical'
  | 'general';
==== END: app/components/debug/VerticalSliceDebugPanel.tsx ====

==== START: app/components/HillHomeScene.tsx ====
'use client';
import React, { useState, useEffect, useRef } from 'react';
import { useGameStore } from '../store/gameStore';
import { useKnowledgeStore } from '../store/knowledgeStore';
import { PixelText, PixelButton } from './PixelThemeProvider';
import { useGameState } from '../core/statemachine/GameStateMachine';
import ConstellationView from './knowledge/ConstellationView';
import { useEventBus } from '../core/events/CentralEventBus';
import { GameEventType } from '../core/events/EventTypes';


/**
 * HillHomeScene - Simplified night phase component
 * 
 * A more straightforward implementation with better error handling
 * and visual feedback to ensure users can always progress.
 */
export default function HillHomeScene({ onComplete }) {
  // Core game state
  const { player, inventory, currentDay, updateInsight } = useGameStore();
  const { gamePhase } = useGameState();
  
  // Knowledge state
  const { pendingInsights, totalMastery, domainMastery, transferInsights, resetNewlyDiscovered, newlyDiscovered } = useKnowledgeStore();
  
  // Component state
  const [showInventory, setShowInventory] = useState(false);
  const [showConstellation, setShowConstellation] = useState(false);
  const [insightTransferred, setInsightTransferred] = useState(false);
  const [renderCount, setRenderCount] = useState(0);
  const [hasStartedInsightTransfer, setHasStartedInsightTransfer] = useState(false);
  
  // Mount tracking
  const mounted = useRef(true);
  
  // Track renders for debugging
  useEffect(() => {
    setRenderCount(prev => prev + 1);
    console.log(`[HillHomeScene] Render #${renderCount + 1}`);
    
    // Log critical debug info
    console.log('[HillHomeScene] Current game phase:', gamePhase);
    console.log('[HillHomeScene] Has pending insights:', pendingInsights.length);
    console.log('[HillHomeScene] Newly discovered concepts:', newlyDiscovered.length);
  }, [gamePhase, pendingInsights.length, newlyDiscovered.length]);
  
  // Set up mount/unmount tracking
  useEffect(() => {
    // Log when component mounts
    console.log('[HillHomeScene] Component mounted');
    mounted.current = true;
    
    // Notify event system that night phase has started
    try {
      useEventBus.getState().dispatch(
        GameEventType.GAME_PHASE_CHANGED,
        {
          from: 'transition_to_night',
          to: 'night',
          reason: 'hill_home_mounted'
        },
        'HillHomeScene'
      );
    } catch (e) {
      console.warn('[HillHomeScene] Event dispatch failed:', e);
    }
    
    return () => {
      mounted.current = false;
      console.log('[HillHomeScene] Component unmounted');
    };
  }, []);
  
  // Handle insight transfer with improved error handling
  useEffect(() => {
    if (!mounted.current) return;
    
    // Only start transfer if we haven't already and we have insights to transfer
    if (!hasStartedInsightTransfer && !insightTransferred && pendingInsights.length > 0) {
      console.log('[HillHomeScene] Starting insight transfer process');
      setHasStartedInsightTransfer(true);
      
      // Start transfer after a delay
      const timer = setTimeout(() => {
        if (!mounted.current) return;
        
        try {
          console.log('[HillHomeScene] Executing insight transfer');
          
          // Calculate total insight gain
          const totalInsightGain = pendingInsights.reduce((total, insight) => {
            return total + insight.amount;
          }, 0);
          
          // Grant insight points
          updateInsight(totalInsightGain);
          
          // Actually transfer insights in the knowledge store
          transferInsights();
          
          // Update state
          setInsightTransferred(true);
          
          // Log insight transfer for debugging
          console.log('[HillHomeScene] Insight transfer complete:', {
            insightsTransferred: pendingInsights.length,
            totalGain: totalInsightGain
          });
          
          // Automatically open constellation view after a delay
          if (newlyDiscovered.length > 0) {
            setTimeout(() => {
              if (mounted.current) {
                setShowConstellation(true);
              }
            }, 1000);
          }
          
        } catch (error) {
          console.error('[HillHomeScene] Error during insight transfer:', error);
          // Still mark as transferred so player can continue
          setInsightTransferred(true);
        }
      }, 1500); // Reduced delay for better responsiveness
      
      return () => clearTimeout(timer);
    }
  }, [
    hasStartedInsightTransfer, 
    insightTransferred, 
    pendingInsights, 
    updateInsight, 
    transferInsights,
    newlyDiscovered
  ]);
  
  // Handle clean-up of newly discovered state when leaving
  useEffect(() => {
    return () => {
      // Reset newly discovered state when component unmounts
      if (newlyDiscovered.length > 0) {
        try {
          console.log('[HillHomeScene] Resetting newly discovered on unmount');
          resetNewlyDiscovered();
        } catch (e) {
          console.warn('[HillHomeScene] Failed to reset newly discovered:', e);
        }
      }
    };
  }, [newlyDiscovered, resetNewlyDiscovered]);
  
  // Handle starting the next day
  const handleStartDay = () => {
    // Ensure insights are transferred
    if (!insightTransferred && pendingInsights.length > 0) {
      try {
        // Force transfer insights if not done yet
        transferInsights();
        console.log('[HillHomeScene] Forced insight transfer before day start');
      } catch (e) {
        console.warn('[HillHomeScene] Error during forced insight transfer:', e);
      }
    }
    
    // Close constellation if open
    setShowConstellation(false);
    
    // Reset newly discovered
    if (newlyDiscovered.length > 0) {
      resetNewlyDiscovered();
    }
    
    // Log button click
    console.log('[HillHomeScene] Starting next day (Day ' + (currentDay + 1) + ')');
    
    // Complete night phase
    onComplete();
  };
  
  // Get concept color helper
  const getConceptColor = (conceptId) => {
    // Map concept to domain colors
    const conceptDomains = {
      'electron-equilibrium': '#3b82f6', // Blue - radiation physics
      'radiation-dosimetry': '#3b82f6',
      'inverse-square-law': '#3b82f6',
      'output-calibration': '#10b981', // Green - quality assurance
      'tolerance-limits': '#10b981',
      'dosimetry-principles': '#10b981',
      'clinical-dose-significance': '#ec4899', // Pink - clinical practice
      'treatment-planning': '#ec4899',
      'radiation-safety': '#f59e0b', // Amber - radiation protection
      'alara-principle': '#f59e0b',
      'general': '#6b7280', // Gray - general
    };
    
    return conceptDomains[conceptId] || '#8b5cf6'; // Default to purple
  };

  return (
    <div className="fixed inset-0 bg-black p-4 flex flex-col items-center justify-center overflow-auto">
      {/* Starfield background - simplified with inline styles */}
      <div 
        className="fixed inset-0 z-0" 
        style={{
          background: '#000',
          backgroundImage: 'radial-gradient(2px 2px at 20px 30px, #fff, rgba(0,0,0,0)), radial-gradient(2px 2px at 40px 70px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 90px 40px, #fff, rgba(0,0,0,0))',
          backgroundSize: '200px 200px',
          opacity: 0.7
        }}
      />
      
      {/* Emergency night phase indicator - always visible */}
      <div className="fixed top-0 left-0 m-4 bg-purple-800 text-white px-3 py-1 z-50 text-sm rounded">
        Night Phase - Day {currentDay}
      </div>
      
      {/* Emergency continue button - always visible at bottom */}
      <div className="fixed bottom-8 right-8 z-50">
        <button
          className="px-6 py-3 bg-purple-700 hover:bg-purple-600 text-white font-medium rounded-lg shadow-lg"
          onClick={handleStartDay}
        >
          Continue to Day {currentDay + 1} →
        </button>
      </div>
      
      {/* Main content area */}
      <div className="relative z-10 w-full max-w-4xl">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-3xl font-pixel text-white mb-2">Night at Hill Home</h1>
          <p className="text-blue-300 text-lg">Time to reflect on your knowledge</p>
        </div>
        
        {/* Main content grid */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
          {/* Constellation card */}
          <div 
            className="col-span-3 bg-gray-900 border border-purple-800 rounded-lg p-6 flex flex-col items-center justify-center min-h-[180px] hover:bg-gray-800 transition cursor-pointer"
            onClick={() => setShowConstellation(true)}
          >
            <div className="text-4xl mb-3">✨</div>
            <h2 className="text-xl font-pixel text-white mb-1">Knowledge Constellation</h2>
            <p className="text-gray-400 text-sm text-center">
              Explore your growing understanding of medical physics
            </p>
            {newlyDiscovered.length > 0 && (
              <div className="mt-3 px-3 py-1 bg-purple-600 text-white text-sm animate-pulse rounded">
                {newlyDiscovered.length} new concept{newlyDiscovered.length !== 1 ? 's' : ''} discovered!
              </div>
            )}
          </div>
          
          {/* Inventory card */}
          <div 
            className="bg-gray-900 border border-blue-800 rounded-lg p-6 flex flex-col items-center justify-center min-h-[180px] hover:bg-gray-800 transition cursor-pointer"
            onClick={() => setShowInventory(true)}
          >
            <div className="text-4xl mb-3">🎒</div>
            <h2 className="text-lg font-pixel text-white mb-1">Inventory</h2>
            <div className="mt-2 px-3 py-1 bg-gray-700 text-white text-sm">
              {inventory.length} Items
            </div>
          </div>
          
          {/* Return to hospital card */}
          <div 
            className="col-span-2 bg-gray-900 border border-blue-800 rounded-lg p-6 flex flex-col items-center justify-center min-h-[180px] hover:bg-gray-800 transition cursor-pointer"
            onClick={handleStartDay}
          >
            <div className="text-4xl mb-3">🏥</div>
            <h2 className="text-xl font-pixel text-white mb-1">Return to Hospital</h2>
            <div className="mt-2 px-3 py-1 bg-blue-600 text-white text-sm">
              Begin Day {currentDay + 1}
            </div>
          </div>
        </div>
        
        {/* Status area */}
        <div className="bg-gray-900 border border-gray-700 rounded-lg p-4">
          <div className="flex justify-between items-center mb-3">
            <h2 className="text-lg font-pixel text-white">Player Status</h2>
            <div className="flex space-x-3">
              <span className="px-2 py-1 bg-red-600 text-white text-sm rounded">
                Health: {player.health}/{player.maxHealth}
              </span>
              <span className="px-2 py-1 bg-blue-600 text-white text-sm rounded">
                Insight: {player.insight}
              </span>
            </div>
          </div>
          
          <div className="mb-2">
            <div className="text-gray-400 mb-1 text-sm">Knowledge Mastery</div>
            <div className="w-full h-2 bg-gray-800 rounded-full overflow-hidden">
              <div 
                className="h-full bg-purple-600" 
                style={{ width: `${totalMastery}%` }}
              />
            </div>
          </div>
          
          <div className="text-xs text-gray-400 flex justify-between">
            <span>Clinical: {domainMastery['clinical-practice'] || 0}%</span>
            <span>Technical: {domainMastery['quality-assurance'] || 0}%</span>
            <span>Theory: {domainMastery['theoretical'] || 0}%</span>
          </div>
        </div>
      </div>
      
      {/* Insight transfer effect */}
      {hasStartedInsightTransfer && !insightTransferred && pendingInsights.length > 0 && (
        <div className="fixed inset-0 z-20 pointer-events-none">
          <div className="absolute inset-0 bg-purple-900/10 animate-pulse" />
          {pendingInsights.map((insight, index) => (
            <div 
              key={`insight-${index}`}
              className="absolute w-2 h-2 rounded-full animate-float-up"
              style={{
                backgroundColor: getConceptColor(insight.conceptId),
                left: `${20 + Math.random() * 60}%`,
                top: `${70 + Math.random() * 20}%`,
                animationDelay: `${index * 0.2}s`,
                opacity: 0.8
              }}
            />
          ))}
        </div>
      )}
      
      {/* Inventory panel */}
      {showInventory && (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-30">
          <div className="bg-gray-900 border border-blue-700 rounded-lg p-6 max-w-md w-full">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-pixel text-white">Inventory</h2>
              <button 
                className="bg-red-600 hover:bg-red-500 text-white px-3 py-1 rounded"
                onClick={() => setShowInventory(false)}
              >
                Close
              </button>
            </div>
            
            <div className="space-y-3 max-h-80 overflow-y-auto">
              {inventory && inventory.length > 0 ? (
                inventory.map((item, index) => (
                  <div key={index} className="bg-gray-800 p-3 rounded">
                    <div className="flex justify-between">
                      <div className="font-medium text-white">{item.name}</div>
                      <div className="text-sm text-gray-400">{item.rarity}</div>
                    </div>
                    <div className="text-sm text-gray-300 mt-1">{item.description}</div>
                  </div>
                ))
              ) : (
                <div className="text-center py-8 text-gray-400">
                  <p>No items collected yet</p>
                  <p className="text-xs mt-2">Visit storage closets in the hospital to find equipment</p>
                </div>
              )}
            </div>
          </div>
        </div>
      )}
      
      {/* Constellation view */}
      {showConstellation && (
        <div className="fixed inset-0 bg-black/95 z-30">
          <ConstellationView
            nightMode={true}
            showLabels={true}
            interactive={true}
            activeNodes={newlyDiscovered}
            onClose={() => setShowConstellation(false)}
          />
        </div>
      )}
      
      {/* Debug info */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="fixed bottom-0 left-0 bg-black/80 text-white text-xs font-mono z-50 p-2 max-w-xs">
          <div>Phase: {gamePhase}</div>
          <div>Day: {currentDay}</div>
          <div>Insights: {pendingInsights.length}</div>
          <div>Transferred: {insightTransferred ? 'Yes' : 'No'}</div>
          <div>New Concepts: {newlyDiscovered.length}</div>
          <div>Renders: {renderCount}</div>
        </div>
      )}
      
      {/* Required CSS animations */}
      <style jsx>{`
        @keyframes float-up {
          0% { transform: translateY(0); opacity: 0.8; }
          100% { transform: translateY(-50vh); opacity: 0; }
        }
        
        .animate-float-up {
          animation: float-up 3s forwards ease-out;
        }
        
        @keyframes pulse {
          0%, 100% { opacity: 0.5; }
          50% { opacity: 0.8; }
        }
        
        .animate-pulse {
          animation: pulse 2s ease-in-out infinite;
        }
      `}</style>
    </div>
  );
}
==== END: app/components/HillHomeScene.tsx ====

==== START: app/components/vs/SimplifiedKapoorMap.tsx ====
// app/components/vs/SimplifiedKapoorMap.tsx
'use client';
import { useEffect, useState, useRef } from 'react';
import { useGameStore } from '@/app/store/gameStore';
import { useEventBus } from '@/app/core/events/CentralEventBus';
import { GameEventType } from '@/app/core/events/EventTypes';
import { useGameState } from '@/app/core/statemachine/GameStateMachine';
import { useJournalStore } from '@/app/store/journalStore';

/**
 * Safe event dispatch helper - minimizes crashes from event system issues
 */
function safeEventDispatch(eventType: GameEventType, payload: any, source?: string) {
  try {
    useEventBus.getState().dispatch(eventType, payload, source || 'simplifiedKapoorMap');
  } catch (error) {
    console.error(`[SafeEventDispatch] Error dispatching ${eventType}:`, error);
  }
}

/**
 * SimplifiedKapoorMap
 * 
 * A focused map component that strips away complexity to spotlight the
 * critical path through Dr. Kapoor's calibration node. Designed specifically
 * for the vertical slice to validate the core gameplay loop.
 */
export default function SimplifiedKapoorMap() {
  const { 
    map, 
    currentNodeId, 
    setCurrentNode, 
    completedNodeIds, 
    startGame,
    currentDay 
  } = useGameStore();
  
  const { completeDay, gamePhase } = useGameState();
  const journalStore = useJournalStore();
  
  const [kapoorNodeId, setKapoorNodeId] = useState<string | null>(null);
  const [isMapReady, setIsMapReady] = useState(false);
  const [autoSelectDisabled, setAutoSelectDisabled] = useState(false);
  const [revealEffectPlayed, setRevealEffectPlayed] = useState(false);
  
  // FIXED: Track transition state to prevent multiple clicks
  const [isEndDayProcessing, setIsEndDayProcessing] = useState(false);
  
  const mapContainerRef = useRef<HTMLDivElement>(null);
  const nodeRef = useRef<HTMLDivElement>(null);
  const instanceId = useRef(`vs-map-${Date.now()}`).current;
  
  // Initialize map if needed
  useEffect(() => {
    if (!map) {
      console.log('🗺️ Initializing simplified Kapoor map...');
      
      try {
        startGame({ 
          seed: 'vs-kapoor-calibration',
          forceVerticalSlice: true
        });
        
        // Log map initialization
        try {
          safeEventDispatch(
            GameEventType.UI_BUTTON_CLICKED,
            {
              componentId: 'simplifiedKapoorMap',
              action: 'initializeMap',
              metadata: { 
                instanceId,
                timestamp: Date.now() 
              }
            },
            'SimplifiedKapoorMap.init'
          );
        } catch (eventError) {
          console.warn('[Map] Initialize event failed, continuing anyway:', eventError);
        }
      } catch (error) {
        console.error('Error initializing map:', error);
      }
    } else {
      // Map exists, wait a bit then mark as ready
      const timer = setTimeout(() => {
        setIsMapReady(true);
        
        // Log map ready state
        console.log('🗺️ Map ready, nodes:', map.nodes.length);
        console.log('Seed:', map.seed);
        console.log('Start node:', map.startNodeId);
      }, 300);
      
      return () => clearTimeout(timer);
    }
  }, [map, startGame, instanceId]);
  
  // Find and set the Kapoor calibration node
  useEffect(() => {
    if (map && map.nodes && !kapoorNodeId) {
      try {
        // Look for the Kapoor calibration node
        const kapoorNode = map.nodes.find(node => 
          node.type === 'kapoorCalibration' || 
          (node.character === 'kapoor' && 
           (node.challengeContent === 'calibration' || node.type.includes('calibration')))
        );
        
        if (kapoorNode) {
          console.log('🔍 Found Kapoor calibration node:', kapoorNode.id);
          setKapoorNodeId(kapoorNode.id);
          
          // Log event
          try {
            safeEventDispatch(
              GameEventType.UI_BUTTON_CLICKED,
              {
                componentId: 'simplifiedKapoorMap',
                action: 'foundKapoorNode',
                metadata: { 
                  nodeId: kapoorNode.id,
                  nodeType: kapoorNode.type,
                  timestamp: Date.now() 
                }
              },
              'SimplifiedKapoorMap.findNode'
            );
          } catch (eventError) {
            console.warn('[Map] Found node event failed, continuing anyway:', eventError);
          }
        } else {
          console.warn('⚠️ Could not find Kapoor calibration node in map');
          
          // Try to find any usable node as fallback
          const fallbackNode = map.nodes.find(n => 
            n.character === 'kapoor' || n.type === 'entrance' || n.type === 'start'
          );
          
          if (fallbackNode) {
            console.log('🔄 Using fallback node:', fallbackNode.id);
            setKapoorNodeId(fallbackNode.id);
          } else if (map.nodes.length > 0) {
            // Last resort - use first node
            console.warn('⚠️ Using first available node as fallback');
            setKapoorNodeId(map.nodes[0].id);
          }
        }
      } catch (error) {
        console.error('Error finding Kapoor node:', error);
      }
    }
  }, [map, kapoorNodeId]);
  
  // Check if we should disable auto-select based on completion state or day
  useEffect(() => {
    // Don't auto-select if:
    // 1. The node has already been completed
    // 2. We're past day 1 (returning to map after night phase)
    if (
      (kapoorNodeId && completedNodeIds.includes(kapoorNodeId)) || 
      currentDay > 1 || 
      journalStore.hasJournal
    ) {
      setAutoSelectDisabled(true);
    }
  }, [kapoorNodeId, completedNodeIds, currentDay, journalStore.hasJournal]);
  
  // Modified auto-select logic - Only for first-time experience
  useEffect(() => {
    // Only auto-select if all conditions are met AND auto-select isn't disabled
    if (isMapReady && kapoorNodeId && !currentNodeId && !autoSelectDisabled) {
      // Add slight delay for visual impact
      const timer = setTimeout(() => {
        try {
          console.log('🎯 Auto-selecting Kapoor node:', kapoorNodeId);
          setCurrentNode(kapoorNodeId);
          setAutoSelectDisabled(true); // Disable after first use
          
          // Log event
          try {
            safeEventDispatch(
              GameEventType.UI_BUTTON_CLICKED,
              {
                componentId: 'simplifiedKapoorMap',
                action: 'autoSelectNode',
                metadata: { 
                  nodeId: kapoorNodeId,
                  timestamp: Date.now() 
                }
              },
              'SimplifiedKapoorMap.autoSelect'
            );
          } catch (eventError) {
            console.warn('[Map] Auto-select event failed, continuing anyway:', eventError);
          }
        } catch (error) {
          console.error('Error auto-selecting node:', error);
        }
      }, 1200);
      
      return () => clearTimeout(timer);
    }
  }, [isMapReady, kapoorNodeId, currentNodeId, autoSelectDisabled, setCurrentNode]);
  
  // Handle node click
  const handleNodeClick = () => {
    if (kapoorNodeId) {
      try {
        // Don't do anything if already selected
        if (currentNodeId === kapoorNodeId) return;
        
        // Update game state
        setCurrentNode(kapoorNodeId);
        
        // Log event
        try {
          safeEventDispatch(
            GameEventType.UI_BUTTON_CLICKED,
            {
              componentId: 'simplifiedKapoorMap',
              action: 'nodeClicked',
              metadata: { 
                nodeId: kapoorNodeId,
                timestamp: Date.now() 
              }
            },
            'SimplifiedKapoorMap.nodeClick'
          );
        } catch (eventError) {
          console.warn('[Map] Node click event failed, continuing anyway:', eventError);
        }
      } catch (error) {
        console.error('Error handling node click:', error);
      }
    }
  };
  
  // Emergency journal acquisition function
  const forceJournalAcquisition = () => {
    if (!journalStore.hasJournal) {
      try {
        console.log('⚠️ Forcing emergency journal acquisition');
        journalStore.initializeJournal('technical');
        
        // Log event
        try {
          safeEventDispatch(
            GameEventType.JOURNAL_ACQUIRED,
            {
              tier: 'technical',
              character: 'kapoor', 
              source: 'emergency_fallback',
              forced: true
            },
            'SimplifiedKapoorMap.emergencyJournal'
          );
        } catch (e) {
          console.error('Error logging emergency journal acquisition:', e);
        }
        
        return true;
      } catch (error) {
        console.error('Failed to force journal acquisition:', error);
        return false;
      }
    }
    return false; // No action needed
  };
  
  // FIXED: Handle end day button with critical path protection and debouncing
  const handleEndDay = () => {
    // FIXED: Prevent multiple clicks
    if (isEndDayProcessing || gamePhase !== 'day') {
      console.log('[Map] End day already processing or not in day phase, ignoring click');
      return;
    }
    
    try {
      // Set processing flag first to prevent multiple calls
      setIsEndDayProcessing(true);
      
      if (completedNodeIds.length > 0) {
        // Check if the journal was acquired and force if needed
        const journalSuccess = forceJournalAcquisition();
        if (journalSuccess) {
          console.log('🔄 Successfully forced journal acquisition before night phase');
        }
        
        // Log event before triggering transition
        try {
          safeEventDispatch(
            GameEventType.UI_BUTTON_CLICKED,
            {
              componentId: 'dayCompleteButton',
              action: 'click',
              metadata: { timestamp: Date.now() }
            },
            'SimplifiedKapoorMap.endDay'
          );
        } catch (eventError) {
          console.warn('[Map] End day event failed, continuing anyway:', eventError);
        }
        
        // Trigger night phase transition
        const success = completeDay();
        
        // FIXED: If we failed to transition, reset processing state
        if (!success) {
          console.warn('Failed to complete day, resetting processing state');
          setIsEndDayProcessing(false);
        }
        
        // FIXED: Add safety timeout to reset the flag if stuck
        setTimeout(() => {
          setIsEndDayProcessing(false);
        }, 5000); // 5 second safety timeout
      } else {
        // Indicate that node completion is required
        setIsEndDayProcessing(false); // Reset immediately since we're not transitioning
        
        // Visual feedback on button
        const button = document.querySelector('.end-day-button');
        if (button instanceof HTMLElement) {
          button.animate([
            { transform: 'translateX(-3px)' },
            { transform: 'translateX(3px)' },
            { transform: 'translateX(-3px)' },
            { transform: 'translateX(0)' }
          ], {
            duration: 300,
            easing: 'ease-in-out'
          });
        }
      }
    } catch (error) {
      console.error('Error handling end day:', error);
      
      // Reset processing state on error
      setIsEndDayProcessing(false);
      
      // Resilient recovery - force day completion anyway
      try {
        console.warn('🔄 Attempting emergency day completion despite error');
        completeDay();
        
        // FIXED: Add safety timeout even in error case
        setTimeout(() => {
          setIsEndDayProcessing(false);
        }, 5000);
      } catch (fallbackError) {
        console.error('Critical fallback also failed:', fallbackError);
        setIsEndDayProcessing(false);
      }
    }
  };
  
  // Show a loading state while map initializes
  if (!isMapReady || !map) {
    return (
      <div className="h-full w-full flex items-center justify-center bg-background">
        <div className="text-center">
          <h1 className="text-2xl text-blue-300 mb-4">Initializing Calibration Session...</h1>
          <div className="w-48 h-2 bg-gray-800 mx-auto overflow-hidden rounded-full">
            <div className="h-full bg-blue-600 animate-pulse" style={{ width: '60%' }}></div>
          </div>
        </div>
      </div>
    );
  }

  // Get node completion state for styling
  const isNodeCompleted = kapoorNodeId && completedNodeIds.includes(kapoorNodeId);
  
  return (
    <div 
      ref={mapContainerRef}
      className="h-full w-full p-8 flex flex-col items-center justify-center bg-background starfield-bg relative"
      data-component="simplified-kapoor-map"
      data-instance-id={instanceId}
    >
      {/* Header */}
      <div className="text-center mb-12">
        <h1 className="text-4xl text-white font-bold mb-4 glow-text-blue">
          LINAC Calibration Session
        </h1>
        <p className="text-xl text-blue-200">
          Begin your medical physics journey with Dr. Kapoor
        </p>
      </div>
      
      {/* Node visualization */}
      <div className="relative w-full max-w-md h-64 flex items-center justify-center">
        <div 
          ref={nodeRef}
          className={`w-80 h-36 relative cursor-pointer transition-all duration-300 transform hover:scale-105 
            ${currentNodeId ? 'opacity-75' : isNodeCompleted ? 'opacity-80' : 'animate-pulse-slow'}`}
          onClick={handleNodeClick}
          style={{
            perspective: '800px'
          }}
        >
          {/* Node container with 3D effect */}
          <div className="absolute inset-0 overflow-hidden" 
            style={{ 
              background: 'rgba(10, 12, 16, 0.92)',
              borderLeft: '3px solid #3b82f6', // Blue border
              boxShadow: '0 0 20px rgba(59, 130, 246, 0.3)',
              transform: 'rotateY(-5deg)'
            }}
          >
            {/* Highlight effect */}
            <div 
              className="absolute inset-0"
              style={{ 
                background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, transparent 50%, rgba(59, 130, 246, 0.05) 100%)',
                opacity: currentNodeId ? 0.5 : isNodeCompleted ? 0.4 : 0.8
              }}
            ></div>
          </div>
          
          {/* Character portrait */}
          <div 
            className="absolute left-0 bottom-0 transform -translate-x-1/4 translate-y-1/4 z-10"
            style={{ 
              width: '80px',
              height: '80px'
            }}
          >
            <div 
              className="w-full h-full rounded-full overflow-hidden border-2 border-blue-500 shadow-glow-blue"
            >
              <img 
                src="/characters/kapoor.png" 
                alt="Dr. Kapoor" 
                className="w-full h-full object-cover"
              />
            </div>
          </div>
          
          {/* Content */}
          <div className="absolute inset-0 flex flex-col justify-center pl-20 pr-4">
            <h3 className="text-xl text-white font-medium mb-1">Dr. Kapoor</h3>
            <p className="text-sm text-gray-300 mb-2">Calibration Challenge</p>
            <div className="flex items-center text-xs">
              <div className="w-2 h-2 rounded-full bg-blue-500 mr-2"></div>
              <span className="text-gray-400">Clinical Training</span>
              {isNodeCompleted ? (
                <span className="ml-auto text-green-400">Completed</span>
              ) : (
                <span className="ml-auto text-blue-400">+10 Insight</span>
              )}
            </div>
          </div>
          
          {/* Pulse indicator - only show if not completed */}
          {!isNodeCompleted && (
            <div className="absolute -top-1 -right-1 w-3 h-3 rounded-full bg-blue-500 animate-ping"></div>
          )}
          
          {/* Completion indicator */}
          {isNodeCompleted && (
            <div className="absolute -top-1 -right-1 w-4 h-4 rounded-full bg-green-500 flex items-center justify-center text-xs text-white">
              ✓
            </div>
          )}
        </div>
      </div>
      
      {/* Emergency Journal Button */}
      {completedNodeIds.length > 0 && !journalStore.hasJournal && (
        <div className="mt-4">
          <button
            className="px-4 py-2 bg-green-600 text-white text-sm rounded animate-pulse"
            onClick={forceJournalAcquisition}
            title="Use only if journal acquisition failed during dialogue"
          >
            Acquire Journal (Emergency)
          </button>
        </div>
      )}
      
      {/* Complete Day Button */}
      <div className="mt-12">
        <button
          className={`end-day-button px-6 py-3 rounded-lg transition-all duration-300 
            ${
              // FIXED: Apply additional disabled styling when processing
              isEndDayProcessing
                ? 'bg-gray-600 text-gray-400 cursor-not-allowed opacity-70'
                : completedNodeIds.length > 0 
                  ? 'bg-blue-600 hover:bg-blue-500 text-white' 
                  : 'bg-gray-700 text-gray-400 cursor-not-allowed'
            }`}
          onClick={handleEndDay}
          disabled={completedNodeIds.length === 0 || isEndDayProcessing}
          style={{
            boxShadow: completedNodeIds.length > 0 && !isEndDayProcessing
              ? '0 0 15px rgba(59, 130, 246, 0.4)' 
              : 'none'
          }}
        >
          {isEndDayProcessing ? (
            <>
              <span className="relative z-10 font-medium">Transitioning...</span>
              <span className="ml-2 inline-block w-4 h-4 border-2 border-gray-300 border-t-blue-500 rounded-full animate-spin"></span>
            </>
          ) : (
            <span className="relative z-10 font-medium">Return to Hill Home</span>
          )}
        </button>
        {completedNodeIds.length === 0 && !isEndDayProcessing && (
          <p className="text-center text-yellow-500 text-sm mt-2">
            Complete the calibration challenge first
          </p>
        )}
      </div>
      
      {/* Day indicator */}
      <div className="absolute top-4 left-4 bg-blue-600/70 text-white px-3 py-1 text-sm rounded-md">
        Day {currentDay}
      </div>
      
      {/* Vertical slice indicator */}
      <div className="absolute top-4 right-4 bg-blue-600 text-white px-3 py-1 text-sm rounded-md z-40">
        Vertical Slice Mode
      </div>
      
      {/* Debug info in development */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="fixed bottom-4 left-4 bg-black/70 text-white p-2 text-xs font-mono z-40 rounded">
          <div>Instance: {instanceId.slice(-6)}</div>
          <div>Map Nodes: {map?.nodes?.length || 0}</div>
          <div>Kapoor Node: {kapoorNodeId ? kapoorNodeId.slice(0, 10) + '...' : 'none'}</div>
          <div>Current Node: {currentNodeId ? currentNodeId.slice(0, 10) + '...' : 'none'}</div>
          <div>Completed: {completedNodeIds.length}</div>
          <div>Journal: {journalStore.hasJournal ? `${journalStore.currentUpgrade}` : 'none'}</div>
          <div>Auto-Select: {autoSelectDisabled ? 'Disabled' : 'Enabled'}</div>
          <div>Phase: {gamePhase}</div>
          <div>Processing: {isEndDayProcessing ? 'Yes' : 'No'}</div>
        </div>
      )}
      
      {/* Add styles for effects */}
      <style jsx>{`
        .glow-text-blue {
          text-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
        }
        
        .shadow-glow-blue {
          box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }
        
        @keyframes pulseSlow {
          0% { transform: scale(1); }
          50% { transform: scale(1.02); }
          100% { transform: scale(1); }
        }
        
        .animate-pulse-slow {
          animation: pulseSlow 3s infinite ease-in-out;
        }
      `}</style>
    </div>
  );
}
==== END: app/components/vs/SimplifiedKapoorMap.tsx ====

==== START: app/components/PlayerStats.tsx ====
'use client';
import { useEffect, useState } from 'react';
import { useGameStore } from '@/app/store/gameStore';
import { useGameState } from '@/app/core/statemachine/GameStateMachine';
import { useKnowledgeStore } from '@/app/store/knowledgeStore';
import { useJournalStore } from '@/app/store/journalStore';
import InsightMeter from './gameplay/InsightMeter';
import MomentumCounter from './gameplay/MomentumCounter';
import ResidentPortrait from './ResidentPortrait';
import { motion, AnimatePresence } from 'framer-motion';
import { PixelBox, PixelButton } from './PixelThemeProvider';

/**
 * PlayerStats - Enhanced player stats sidebar with character representation
 * 
 * This component creates a cohesive "character sheet" that reinforces the game's
 * knowledge acquisition loop through visual design and clear information hierarchy.
 */
export default function PlayerStats() {
  // Global state
  const { player, currentNodeId } = useGameStore();
  const { gamePhase, dayCount } = useGameState();
  const { totalMastery, newlyDiscovered } = useKnowledgeStore();
  const { hasJournal, currentUpgrade, toggleJournal } = useJournalStore();
  
  // Local state for animations
  const [showInsightAnimation, setShowInsightAnimation] = useState(false);
  const [showJournalButtonAnimation, setShowJournalButtonAnimation] = useState(false);
  
  // Determine when to use full body portrait
  const shouldShowFullBody = 
    gamePhase === 'night' || // Always show full body at night
    (!currentNodeId && gamePhase === 'day'); // Show full body on the map screen
  
  // Animate insight changes
  useEffect(() => {
    if (player.insight > 50 && !showInsightAnimation) {
      setShowInsightAnimation(true);
      
      // Reset animation after delay
      const timer = setTimeout(() => {
        setShowInsightAnimation(false);
      }, 2000);
      
      return () => clearTimeout(timer);
    }
  }, [player.insight, showInsightAnimation]);
  
  // Show journal button animation when journal is first acquired
  useEffect(() => {
    if (hasJournal) {
      setShowJournalButtonAnimation(true);
      const timer = setTimeout(() => {
        setShowJournalButtonAnimation(false);
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [hasJournal]);
  
  // Determine phase color for theming elements
  const getPhaseColor = () => {
    return gamePhase === 'day' ? 'clinical' : 'educational';
  };
  
  return (
    <div className="p-3 h-full flex flex-col space-y-3">
      {/* 1. Character Identity Block - Always visible, defines player identity */}
      <PixelBox className="p-3 flex items-center">
        <ResidentPortrait 
          showFullBody={shouldShowFullBody}
          size="md"
          className="mr-3"
        />
        <div>
          <h2 className="text-lg font-pixel">Medical Physics Resident</h2>
          <div className="flex items-center gap-2 mt-1">
            <div className={`w-2 h-2 rounded-full bg-${getPhaseColor()}-light`}></div>
            <div className="text-sm text-text-secondary font-pixel">
              Day {dayCount} | {gamePhase === 'day' ? 'Hospital' : 'Hill Home'}
            </div>
          </div>
        </div>
      </PixelBox>
      
      {/* 2. Core Resources Block - Tactical resources for challenges */}
      <div className="flex flex-col gap-3">
        {/* Insight meter */}
        <PixelBox 
          className="p-3" 
          variant={gamePhase === 'day' ? 'clinical' : 'default'}
        >
          <InsightMeter showAnimation={showInsightAnimation} />
        </PixelBox>
        
        {/* Momentum counter */}
        <PixelBox 
          className="p-3" 
          variant={player.momentum >= 2 ? 'dark' : 'default'}
        >
          <MomentumCounter 
            level={player.momentum} 
            consecutiveCorrect={player.momentum * 2} // Approximation
            compact={true} 
            className="w-full"
          />
        </PixelBox>
      </div>
      
      {/* 3. Knowledge Progression Block - Strategic long-term resources */}
      <PixelBox 
        className="p-3" 
        variant={newlyDiscovered.length > 0 ? 'educational' : 'default'}
      >
        <div className="text-sm text-text-secondary font-pixel mb-1">Knowledge Mastery</div>
        <div className="flex items-center">
          <div className={`text-${getPhaseColor()}-light text-lg font-pixel`}>
            {totalMastery}%
          </div>
          
          {/* Visual progress bar - pixel style */}
          <div className="ml-2 flex-grow h-2 bg-surface-dark rounded-none overflow-hidden">
            <motion.div 
              className={`h-full bg-${getPhaseColor()}`}
              initial={{ width: 0 }}
              animate={{ 
                width: `${totalMastery}%`,
                transition: { type: 'spring', damping: 15 }
              }}
              style={{
                backgroundImage: `url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='4' height='4' fill='%23${gamePhase === 'day' ? '4f6bbb' : '2c9287'}'/%3E%3Crect width='1' height='1' fill='%23${gamePhase === 'day' ? '2a3a66' : '1f6e66'}'/%3E%3Crect x='2' y='2' width='1' height='1' fill='%23${gamePhase === 'day' ? '2a3a66' : '1f6e66'}'/%3E%3C/svg%3E")`,
                backgroundSize: '4px 4px',
                imageRendering: 'pixelated'
              }}
            />
          </div>
        </div>
        
        {/* Newly discovered animation */}
        <AnimatePresence>
          {newlyDiscovered.length > 0 && (
            <motion.div 
              className="mt-2 text-xs text-educational font-pixel"
              initial={{ opacity: 0, y: -5 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0 }}
            >
              <div className="flex items-center">
                <div className="w-2 h-2 bg-educational-light mr-1 animate-pulse"></div>
                {newlyDiscovered.length} new concept{newlyDiscovered.length !== 1 ? 's' : ''} discovered
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </PixelBox>
      
      {/* 4. Journal Block - The tangible manifestation of knowledge */}
      <PixelBox 
        className={`p-3 ${showJournalButtonAnimation ? 'animate-pulse-subtle' : ''}`}
        variant={hasJournal ? 'clinical' : 'default'}
      >
        <div className="text-sm text-text-secondary font-pixel mb-1">Journal</div>
        {hasJournal ? (
          <div className="flex flex-col">
            <div className="text-clinical-light text-lg font-pixel">
              {currentUpgrade === 'base' && 'Basic Notebook'}
              {currentUpgrade === 'technical' && 'Technical Journal'}
              {currentUpgrade === 'annotated' && 'Annotated Journal'}
              {currentUpgrade === 'indexed' && 'Indexed Compendium'}
              {currentUpgrade === 'integrated' && 'Integrated Codex'}
            </div>
            
            {/* Add journal open button */}
            <button 
              className={`mt-2 px-3 py-1 bg-${getPhaseColor()} text-white text-sm font-pixel
                hover:bg-${getPhaseColor()}-light transition-colors
                ${showJournalButtonAnimation ? 'animate-bounce-subtle' : ''}
                pixel-button
              `}
              onClick={() => toggleJournal()}
            >
              <div className="flex items-center justify-center">
                <span className="mr-1 text-lg">📖</span>
                Open Journal
              </div>
            </button>
          </div>
        ) : (
          <div className="text-warning text-lg font-pixel">
            Not Acquired
          </div>
        )}
      </PixelBox>
      
      {/* 5. Expandable Debug Panel - Only in dev mode */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="mt-auto bg-black/30 p-2 rounded text-xs font-mono">
          <details>
            <summary className="cursor-pointer hover:text-blue-300">Debug Info</summary>
            <div className="pt-1 space-y-1">
              <div>Phase: {gamePhase}</div>
              <div>Day: {dayCount}</div>
              <div>Insight: {player.insight}</div>
              <div>Momentum: {player.momentum}/{player.maxMomentum}</div>
              <div>Node: {currentNodeId ? currentNodeId.substring(0, 8) + '...' : 'none'}</div>
            </div>
          </details>
        </div>
      )}
      
      {/* Custom animations */}
      <style jsx>{`
        @keyframes pulse-subtle {
          0%, 100% { box-shadow: 0 0 0 0 rgba(55, 145, 216, 0.4); }
          50% { box-shadow: 0 0 0 4px rgba(55, 145, 216, 0.4); }
        }
        
        @keyframes bounce-subtle {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-3px); }
        }
        
        .animate-pulse-subtle {
          animation: pulse-subtle 2s infinite;
        }
        
        .animate-bounce-subtle {
          animation: bounce-subtle 2s infinite;
        }
        
        .pixel-button {
          position: relative;
          image-rendering: pixelated;
          border: none;
          border-top: 1px solid rgba(255,255,255,0.3);
          border-left: 1px solid rgba(255,255,255,0.3);
          border-right: 1px solid rgba(0,0,0,0.2);
          border-bottom: 1px solid rgba(0,0,0,0.2);
        }
        
        .pixel-button:active {
          transform: translateY(1px);
          border-top: 1px solid rgba(0,0,0,0.2);
          border-left: 1px solid rgba(0,0,0,0.2);
          border-right: 1px solid rgba(255,255,255,0.3);
          border-bottom: 1px solid rgba(255,255,255,0.3);
        }
      `}</style>
    </div>
  );
}
==== END: app/components/PlayerStats.tsx ====

==== START: app/components/GameContainer.tsx ====
// app/components/GameContainer.tsx
'use client';
import { useEffect, useState, useRef, useCallback } from 'react';
import { useGameStore } from '@/app/store/gameStore';
import { useGameState } from '@/app/core/statemachine/GameStateMachine';
import { useEventBus } from '@/app/core/events/CentralEventBus';
import { GameEventType } from '@/app/core/events/EventTypes';
import { initializeSystems } from '@/app/core/init';
import SimplifiedKapoorMap from './vs/SimplifiedKapoorMap';
import HillHomeScene from './HillHomeScene';
import PlayerStats from './PlayerStats';
import VerticalSliceDebugPanel from './debug/VerticalSliceDebugPanel';
import ChallengeRouter from './challenges/ChallengeRouter';

// Constants for transition timing - these create the rhythm of the experience
const TRANSITION_FADE_DURATION = 700;      // Time to fade to black (ms)
const TRANSITION_TOTAL_DURATION = 1500;    // Total visual transition time (ms)
const EMERGENCY_TIMEOUT_DURATION = 5000;   // Emergency recovery timeout (ms)

/**
 * GameContainer - Core scene router and system initializer
 * 
 * Acts as the primary orchestrator for the game's day/night rhythm, maintaining
 * the critical narrative flow between challenge (day) and reflection (night).
 */
export default function GameContainer() {
  // Game phase state with proper derivation
  const { 
    gamePhase, 
    completeNight,
    completeDay,
    transitionToPhase
  } = useGameState();
  
  // Game store access for node tracking
  const { 
    currentNodeId, 
    map,
    startGame,
    resetGame
  } = useGameStore();
  
  // Component state
  const [isInitialized, setIsInitialized] = useState(false);
  const [hasError, setHasError] = useState<string | null>(null);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [fadeState, setFadeState] = useState<'none' | 'fading-in' | 'fading-out'>('none');
  
  // Refs for state tracking across render cycles
  const initRef = useRef(false);
  const componentMountedRef = useRef(true);
  const emergencyTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  const eventBus = useEventBus.getState();
  
  // Initialize systems only once
  useEffect(() => {
    // Skip if already initialized
    if (initRef.current) return;
    initRef.current = true;
    
    console.log("🎮 Initializing Vertical Slice systems...");
    
    try {
      // Initialize core systems
      const cleanup = initializeSystems();
      
      // Start game with vertical slice configuration
      if (!map) {
        startGame({ 
          seed: 42, 
          mapType: 'tutorial',
          forceVerticalSlice: true
        });
      }
      
      // Mark as initialized
      setIsInitialized(true);
      
      // Log initialization
      try {
        eventBus.dispatch(
          GameEventType.SESSION_STARTED, 
          { mode: 'vertical_slice', timestamp: Date.now() },
          'gameContainer'
        );
      } catch (error) {
        console.warn("Event dispatch error, continuing anyway:", error);
      }
      
      // Return cleanup function
      return () => {
        componentMountedRef.current = false;
        
        // Clear any active timers
        if (emergencyTimerRef.current) {
          clearTimeout(emergencyTimerRef.current);
          emergencyTimerRef.current = null;
        }
        
        if (cleanup) cleanup();
      };
    } catch (error) {
      console.error("Initialization failed:", error);
      setHasError(error instanceof Error ? error.message : String(error));
    }
  }, [map, startGame, eventBus]);
  
  // Emergency timer safety mechanism
  useEffect(() => {
    console.log(`%c[PHASE] ${gamePhase}`, 'color: orange; font-weight: bold');
    
    // Clear any stuck transitions after defined timeout as an absolute last resort
    if (gamePhase === 'transition_to_night' || gamePhase === 'transition_to_day') {
      // Set up new emergency timer 
      emergencyTimerRef.current = setTimeout(() => {
        if ((gamePhase === 'transition_to_night' || gamePhase === 'transition_to_day') && 
            componentMountedRef.current) {
          // Log emergency recovery
          console.error(`%c[EMERGENCY] Forcing phase completion after ${EMERGENCY_TIMEOUT_DURATION}ms`, 
                        'color: red; font-weight: bold');
          
          // Force appropriate phase
          const targetPhase = gamePhase === 'transition_to_night' ? 'night' : 'day';
          
          // Direct phase change with specific emergency reason
          transitionToPhase(targetPhase, 'emergency_recovery_timeout');
          
          // Log for diagnostics
          try {
            eventBus.dispatch(
              GameEventType.TRANSITION_RECOVERY,
              {
                type: 'transition',
                source: 'emergency_timer',
                previousState: gamePhase,
                targetState: targetPhase,
                metadata: {
                  timeoutDuration: EMERGENCY_TIMEOUT_DURATION
                },
                successful: true,
                timestamp: Date.now()
              },
              'gameContainer:emergencyTimeout'
            );
          } catch (error) {
            console.error('[GameContainer] Failed to dispatch recovery event:', error);
          }
        }
      }, EMERGENCY_TIMEOUT_DURATION);
      
      return () => {
        if (emergencyTimerRef.current) {
          clearTimeout(emergencyTimerRef.current);
          emergencyTimerRef.current = null;
        }
      };
    }
  }, [gamePhase, transitionToPhase, eventBus]);
  
  // Memoized callback for night phase completion
  const handleCompleteNight = useCallback(() => {
    try {
      // Check if we're already transitioning
      if (gamePhase === 'transition_to_day' || gamePhase === 'day') {
        console.log('[GameContainer] Already transitioning to day, ignoring duplicate completion request');
        return;
      }
      
      console.log('%c[GameContainer] Completing night phase', 'color: purple; font-weight: bold');
      
      // Dispatch event first
      try {
        eventBus.dispatch(
          GameEventType.UI_BUTTON_CLICKED,
          {
            componentId: 'nightCompleteButton',
            action: 'click',
            metadata: { timestamp: Date.now() }
          },
          'gameContainer'
        );
      } catch (error) {
        console.warn('[GameContainer] Event dispatch error, continuing with night completion:', error);
      }
      
      // Then complete the night phase
      completeNight();
    } catch (error) {
      console.error("[GameContainer] Error transitioning from night:", error);
      // Force transition as fallback
      try {
        transitionToPhase('transition_to_day', 'error_recovery');
      } catch (fallbackError) {
        console.error("[GameContainer] Critical error in fallback transition:", fallbackError);
      }
    }
  }, [gamePhase, completeNight, transitionToPhase, eventBus]);

  /**
   * SIMPLIFIED RENDER GAME CONTENT
   */
  const renderGameContent = () => {
    console.log(`[RENDERING] Current phase: ${gamePhase}, Node: ${currentNodeId}, Transitioning: ${isTransitioning}`);
    
    // 1. Handle loading/error states first
    if (!isInitialized) {
      return (
        <div className="h-full w-full flex items-center justify-center bg-background">
          <div className="text-center p-4">
            <h2 className="text-xl mb-2">Initializing Medical Physics Department...</h2>
            <div className="w-64 h-2 bg-gray-700 rounded-full mx-auto overflow-hidden">
              <div className="h-full bg-blue-500 animate-pulse" style={{width: '60%'}}></div>
            </div>
          </div>
        </div>
      );
    }
    
    if (hasError) {
      return (
        <div className="h-full w-full flex items-center justify-center bg-background">
          <div className="text-center p-4 max-w-md">
            <h2 className="text-xl mb-2 text-red-500">Initialization Error</h2>
            <div className="bg-red-900/20 p-4 rounded mb-4 text-sm">
              {hasError}
            </div>
            <button
              className="px-4 py-2 bg-blue-600 text-white rounded"
              onClick={() => {
                resetGame();
                window.location.reload();
              }}
            >
              Reset & Reload
            </button>
          </div>
        </div>
      );
    }
    
    // 2. DIRECT PHASE RENDERING
    
    // Night phase - direct render
    if (gamePhase === 'night') {
      return (
        <div className="w-full h-full">
          <HillHomeScene onComplete={handleCompleteNight} />
        </div>
      );
    }
    
    // Day phase - map view
    if (gamePhase === 'day' && !currentNodeId) {
      return <SimplifiedKapoorMap />;
    }
    
    // Challenge view
    if (gamePhase === 'day' && currentNodeId) {
      return <ChallengeRouter />;
    }
    
    // 3. Transition state
    if (gamePhase === 'transition_to_night' || gamePhase === 'transition_to_day' || isTransitioning) {
      return (
        <div className="h-full w-full flex items-center justify-center bg-black">
          <div className="text-center">
            <h2 className="text-xl mb-4 text-blue-300 animate-pulse">
              {gamePhase === 'transition_to_night' 
                ? 'Returning to hill home...' 
                : 'Heading to the hospital...'}
            </h2>
            <div className="w-48 h-2 bg-gray-900 rounded-full mx-auto overflow-hidden">
              <div className="h-full bg-blue-500 animate-pulse-flow"></div>
            </div>
            
            {/* Emergency manual transition button - appears after 2 seconds */}
            {(Date.now() - (gamePhase.startsWith('transition_to_') ? Date.now() - 3000 : 0) > 2000) && (
              <button 
                className="mt-6 px-4 py-2 bg-red-600 hover:bg-red-500 text-white text-sm rounded"
                onClick={() => {
                  const targetPhase = gamePhase === 'transition_to_night' ? 'night' : 'day';
                  console.warn(`[GameContainer] Manual transition override to ${targetPhase}`);
                  
                  // Force phase change
                  transitionToPhase(targetPhase, 'manual_override');
                }}
              >
                Force Complete Transition
              </button>
            )}
          </div>
        </div>
      );
    }
    
    // 4. Fallback - should never reach this
    return (
      <div className="h-full w-full flex items-center justify-center bg-red-900/20">
        <div className="text-center p-4">
          <h2 className="text-xl mb-2 text-yellow-500">Unexpected Game State</h2>
          <div className="bg-gray-900/50 p-4 rounded mb-4">
            <p>Current phase: <span className="font-bold">{gamePhase}</span></p>
            <p>Current node: <span className="font-bold">{currentNodeId || 'none'}</span></p>
            <p className="text-gray-400 text-sm mt-2">The game has encountered an unusual state.</p>
          </div>
          <div className="flex space-x-4 justify-center">
            <button
              className="px-4 py-2 bg-blue-600 text-white rounded"
              onClick={() => {
                // Force day phase as recovery
                transitionToPhase('day', 'user_recovery');
              }}
            >
              Return to Day Phase
            </button>
            <button
              className="px-4 py-2 bg-purple-600 text-white rounded"
              onClick={() => {
                // Force night phase as recovery
                transitionToPhase('night', 'user_recovery');
              }}
            >
              Return to Night Phase
            </button>
          </div>
        </div>
      </div>
    );
  };
  
  // Track component mounted state
  useEffect(() => {
    componentMountedRef.current = true;
    return () => {
      componentMountedRef.current = false;
    };
  }, []);
  
  // Main render
  return (
    <div 
      className="relative h-screen w-full bg-background flex flex-col" 
      data-game-container
      data-phase={gamePhase}
    >
      {/* Main content layout with RIGHT sidebar (modified from original) */}
      <div className="flex-grow flex overflow-hidden">
        {/* Main gameplay area */}
        <div className="flex-grow relative overflow-hidden">
          <div className="absolute inset-0 overflow-auto">
            {renderGameContent()}
          </div>
        </div>
        
        {/* Right sidebar - moved from left to right */}
        <div className="w-64 flex-shrink-0 border-l border-gray-800 overflow-hidden flex flex-col">
          <div className="flex-1 overflow-y-auto overflow-x-hidden">
            <PlayerStats />
          </div>
        </div>
      </div>
      
      {/* Transition overlay */}
      {(fadeState !== 'none' || isTransitioning) && (
        <div 
          className={`fixed inset-0 z-[9999] bg-black pointer-events-none transition-opacity duration-700
            ${fadeState === 'fading-in' ? 'opacity-100' : 
              fadeState === 'fading-out' ? 'opacity-0' : 
              isTransitioning ? 'opacity-100' : 'opacity-0'}`}
        />
      )}
      
      {/* Debug panel for vertical slice mode */}
      <VerticalSliceDebugPanel />
      
      {/* Debug overlay - essential for diagnosing transition issues */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="fixed bottom-0 left-0 bg-black/80 text-white p-2 text-xs z-50">
          Phase: {gamePhase} | Node: {currentNodeId || 'none'}
        </div>
      )}
      
      {/* CSS for transition animations */}
      <style jsx>{`
        @keyframes pulseFlow {
          0% { width: 0%; }
          50% { width: 100%; }
          100% { width: 0%; }
        }
        
        .animate-pulse-flow {
          animation: pulseFlow 2s ease-in-out infinite;
        }
        
        .transition-opacity {
          transition: opacity 700ms ease-in-out;
        }
      `}</style>
    </div>
  );
}
==== END: app/components/GameContainer.tsx ====

==== START: app/components/ResidentPortrait.tsx ====
'use client';
import { useState, useEffect } from 'react';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameState } from '@/app/core/statemachine/GameStateMachine';
import { useKnowledgeStore } from '@/app/store/knowledgeStore';

interface ResidentPortraitProps {
  showFullBody?: boolean;
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  showMasteryGlow?: boolean;
}

/**
 * ResidentPortrait - Renders the resident character portrait
 * 
 * Dynamically switches between headshot and full-body views based on context
 * and adds visual feedback based on knowledge mastery.
 */
export default function ResidentPortrait({ 
  showFullBody = false,
  className = '',
  size = 'md',
  showMasteryGlow = true
}: ResidentPortraitProps) {
  const { gamePhase } = useGameState();
  const { totalMastery, newlyDiscovered } = useKnowledgeStore();
  
  // Local animation states
  const [pulseEffect, setPulseEffect] = useState(false);
  
  // Apply pulse effect when new knowledge is discovered
  useEffect(() => {
    if (newlyDiscovered.length > 0) {
      setPulseEffect(true);
      
      // Clear effect after animation
      const timer = setTimeout(() => {
        setPulseEffect(false);
      }, 3000);
      
      return () => clearTimeout(timer);
    }
  }, [newlyDiscovered]);
  
  // Size variants for the portrait
  const sizeClasses = {
    sm: 'w-16 h-16',
    md: 'w-24 h-24',
    lg: 'w-32 h-32'
  };
  
  // Determine which portrait to show
  const portraitType = showFullBody ? 'full' : 'portrait';
  
  // Mastery halo color based on total knowledge mastery
  const getHaloColor = () => {
    if (totalMastery >= 75) return 'rgba(34, 197, 94, 0.4)'; // Green for high mastery
    if (totalMastery >= 50) return 'rgba(147, 51, 234, 0.4)'; // Purple for medium mastery
    if (totalMastery >= 25) return 'rgba(37, 99, 235, 0.4)'; // Blue for low mastery
    return 'rgba(37, 99, 235, 0.15)'; // Dim blue for beginning mastery
  };
  
  // Mastery halo intensity based on total knowledge mastery
  const getHaloIntensity = () => {
    if (totalMastery >= 75) return 'lg';
    if (totalMastery >= 50) return 'md';
    if (totalMastery >= 25) return 'sm';
    return 'xs';
  };
  
  return (
    <div className={`relative flex items-center justify-center ${className}`}>
      {/* Knowledge mastery halo */}
      {showMasteryGlow && (
        <div 
          className={`absolute -inset-1 rounded-full blur-${getHaloIntensity()}`}
          style={{ 
            backgroundColor: getHaloColor(),
            opacity: gamePhase === 'night' ? 0.8 : 0.4,
            zIndex: 0
          }}
        />
      )}
      
      {/* Character portrait */}
      <AnimatePresence mode="wait">
        <motion.div
          key={portraitType}
          className={`relative ${sizeClasses[size]} overflow-hidden ${
            portraitType === 'full' ? 'rounded-md' : 'rounded-full'
          }`}
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ 
            opacity: 1, 
            scale: 1,
            transition: { type: 'spring', damping: 15 }
          }}
          exit={{ opacity: 0, scale: 0.9 }}
        >
          <Image
            src={`/images/resident-${portraitType}.png`}
            alt="Medical Physics Resident"
            layout="fill"
            objectFit="cover"
            className="pixel-art"
            style={{ imageRendering: 'pixelated' }}
          />
          
          {/* Pulse effect when new knowledge is gained */}
          {pulseEffect && (
            <motion.div
              className="absolute inset-0 bg-educational"
              initial={{ opacity: 0 }}
              animate={{ 
                opacity: [0, 0.3, 0],
                transition: { repeat: 2, duration: 1 }
              }}
            />
          )}
        </motion.div>
      </AnimatePresence>
      
      {/* Day/night phase indicator */}
      <div 
        className={`absolute -bottom-1 -right-1 w-4 h-4 rounded-full border-2 border-surface
          ${gamePhase === 'day' ? 'bg-clinical' : 'bg-educational'}
        `}
      />
    </div>
  );
}
==== END: app/components/ResidentPortrait.tsx ====

==== START: app/components/challenges/ChallengeRouter.tsx ====
// app/components/challenges/ChallengeRouter.tsx
'use client';
import { useState, useEffect, useMemo } from 'react';
import { useGameStore } from '@/app/store/gameStore';
import { useJournalStore } from '@/app/store/journalStore';
import { useKnowledgeStore } from '@/app/store/knowledgeStore';
import { useEventBus } from '@/app/core/events/CentralEventBus';
import { GameEventType } from '@/app/core/events/EventTypes';
import ConversationFormat from './formats/ConversationFormat';
import { createKapoorCalibrationFlow } from '@/app/core/dialogue/DialogueStateMachine';
import kapoorCalibrationDialogue from '@/app/data/dialogues/calibrations/kapoor-calibration';

/**
 * Challenge Router - Simplified for Vertical Slice
 * 
 * This version focuses exclusively on the critical path of Dr. Kapoor's
 * calibration conversation and journal acquisition. All other challenge
 * types have been stripped out.
 */
export default function ChallengeRouter() {
  const { currentNodeId, completeNode, updateInsight, setCurrentNode } = useGameStore();
  const { initializeJournal } = useJournalStore();
  const { updateMastery, discoverConcept } = useKnowledgeStore();
  
  // Local state
  const [challengeComplete, setChallengeComplete] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Prepare dialogue content with fallback mechanisms
  const dialogueStages = useMemo(() => {
    try {
      // First attempt: Try to create a flow via the factory
      const flow = createKapoorCalibrationFlow(currentNodeId || 'kapoor-calibration');
      
      // Validate flow structure
      if (flow && flow.stages && Array.isArray(flow.stages) && flow.stages.length > 0) {
        console.log("✅ Generated flow stages successfully:", flow.stages.length);
        return flow.stages;
      }
      
      console.warn("⚠️ Flow factory returned invalid structure, falling back to direct import");
      
      // Fallback: Use directly imported dialogue content
      if (kapoorCalibrationDialogue && Array.isArray(kapoorCalibrationDialogue) && 
          kapoorCalibrationDialogue.length > 0) {
        console.log("✅ Using direct dialogue import:", kapoorCalibrationDialogue.length);
        return kapoorCalibrationDialogue;
      }
      
      // Last resort: Create a minimal dialogue to ensure critical path progression
      console.error("🚨 All dialogue sources failed, using emergency minimal dialogue");
      return [
        {
          id: 'emergency-intro',
          text: "Good morning. I see you've arrived for your first day. Let's get started with the basics of medical physics.",
          contextNote: "Dr. Kapoor adjusts some equipment as you enter.",
          options: [
            { 
              id: "continue",
              text: "I'm ready to learn.", 
              nextStageId: 'emergency-journal',
              insightGain: 10,
              relationshipChange: 1
            }
          ]
        },
        {
          id: 'emergency-journal',
          type: 'critical-moment',
          text: "You'll need this journal to document your observations and track your progress through the residency.",
          contextNote: "Dr. Kapoor hands you a leather-bound journal.",
          isConclusion: true
        }
      ];
    } catch (err) {
      // Capture any unexpected errors
      console.error("Error preparing dialogue content:", err);
      setError(`Failed to prepare dialogue: ${err instanceof Error ? err.message : String(err)}`);
      
      // Return minimal content to avoid breaking the UI
      return [{
        id: 'error-recovery',
        text: "System initializing... please stand by.",
        isConclusion: true
      }];
    }
  }, [currentNodeId]);
  
  // Reset challenge state when node changes
  useEffect(() => {
    setChallengeComplete(false);
    setError(null);
  }, [currentNodeId]);
  
  // Handle conversation completion - CRITICAL PATH
  const handleConversationComplete = (results: any) => {
    try {
      console.log("✅ Conversation complete with results:", results);
      
      // Mark knowledge gain - radiation dosimetry concept for the vertical slice
      updateMastery('radiation-dosimetry', 25);
      discoverConcept('radiation-dosimetry');
      
      // CRITICAL PATH: Journal acquisition
      if (!useJournalStore.getState().hasJournal) {
        try {
          console.log("📓 Initializing journal with tier:", results.journalTier);
          initializeJournal(results.journalTier || 'technical');
          
          // Log journal acquisition
          useEventBus.getState().dispatch(
            GameEventType.JOURNAL_ACQUIRED,
            {
              tier: results.journalTier || 'technical',
              character: 'kapoor',
              source: 'conversation_completion'
            },
            'challengeRouter'
          );
        } catch (journalError) {
          console.error("⚠️ Journal initialization failed:", journalError);
          
          // RESILIENCE: Force journal acquisition as fallback
          setTimeout(() => {
            try {
              if (!useJournalStore.getState().hasJournal) {
                console.warn("⚠️ Emergency journal acquisition fallback");
                initializeJournal('technical');
              }
            } catch (e) {
              console.error("💥 Critical failure in journal acquisition:", e);
            }
          }, 100);
        }
      }
      
      // Award insight points
      updateInsight(results.insightGained || 10);
      
      // Mark node as completed - important for progression
      completeNode(currentNodeId || 'kapoor-calibration');
      setChallengeComplete(true);
      
      // Return to map after a short delay
      setTimeout(() => {
        setCurrentNode(null);
      }, 1500);
    } catch (error) {
      console.error("Error handling conversation completion:", error);
      setError(error instanceof Error ? error.message : String(error));
      
      // RESILIENCE: Still mark node as complete even if something fails
      try {
        completeNode(currentNodeId || 'kapoor-calibration');
        
        // Force journal acquisition as ultimate fallback
        if (!useJournalStore.getState().hasJournal) {
          initializeJournal('technical');
        }
        
        // Return to map
        setTimeout(() => {
          setCurrentNode(null);
        }, 1500);
      } catch (e) {
        console.error("Critical failure in completion handling:", e);
      }
    }
  };
  
  // Handle error state
  if (error) {
    return (
      <div className="p-8 bg-red-900/20 max-w-2xl mx-auto my-12 rounded">
        <h2 className="text-2xl mb-4">Challenge Error</h2>
        <div className="bg-black/30 p-4 rounded mb-4">{error}</div>
        <button
          className="px-4 py-2 bg-blue-600 text-white rounded"
          onClick={() => setCurrentNode(null)}
        >
          Return to Map
        </button>
      </div>
    );
  }
  
  // Handle completed state
  if (challengeComplete) {
    return (
      <div className="p-8 max-w-2xl mx-auto my-12 text-center">
        <h2 className="text-2xl mb-4">Challenge Complete!</h2>
        <div className="animate-pulse text-6xl mb-6">✨</div>
        <p className="mb-6">Returning to map...</p>
      </div>
    );
  }
  
  // For vertical slice, we're hardcoding to a conversation with Dr. Kapoor
  return (
    <div className="p-4 flex justify-center items-center min-h-full bg-background">
      <div className="max-w-3xl w-full">
        <ConversationFormat
          character="kapoor"
          dialogueStages={dialogueStages} // Using our hardened dialogue stages
          dialogueId={currentNodeId || 'kapoor-calibration'}
          onComplete={handleConversationComplete}
          onOptionSelected={(option, stageId) => {
            // Log for analytics
            try {
              useEventBus.getState().dispatch(
                GameEventType.DIALOGUE_OPTION_SELECTED,
                {
                  optionId: option.id,
                  stageId,
                  character: 'kapoor'
                },
                'challengeRouter'
              );
            } catch (e) {
              // Non-critical, continue even if logging fails
              console.debug("Event logging failed:", e);
            }
          }}
          stateMachineEnabled={true}
        />
      </div>
    </div>
  );
}
==== END: app/components/challenges/ChallengeRouter.tsx ====

==== START: app/components/challenges/formats/ConversationFormat.tsx ====
// app/components/challenges/formats/ConversationFormat.tsx
'use client';
import { useState, useEffect, useRef, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameStore } from '../../../store/gameStore';
import { useResourceStore, StrategicActionType } from '../../../store/resourceStore';
import { useDialogueFlow, DialogueStage, DialogueOptionView } from '../../../hooks/useDialogueFlow';
import { useTypewriter } from '../../../hooks/useTypewriter';
import { PixelButton, PixelText, PixelBox } from '../../PixelThemeProvider';
import { useEventBus } from '../../../core/events/CentralEventBus';
import { GameEventType } from '../../../core/events/EventTypes';
import InsightMeter from '../../gameplay/InsightMeter';
import MomentumCounter from '../../gameplay/MomentumCounter';
import { StrategicActionsContainer } from '../../gameplay/StrategicActions';
import { applyStrategicAction, enhanceDialogueOptions } from '../../../core/dialogue/ActionIntegration';

// Results interface for completion
export interface InteractionResults {
  insightGained: number;
  relationshipChange: number;
  knowledgeGained: Record<string, number>;
  journalTier?: 'base' | 'technical' | 'annotated';
  actionsUsed?: StrategicActionType[];
}

// Character portrait data
interface CharacterData {
  name: string;
  title: string;
  sprite: string;
  primaryColor: string;
  textClass: string;
  bgClass: string;
}

interface ConversationFormatProps {
  character: string;
  dialogueStages?: DialogueStage[];
  dialogueId?: string;
  onComplete: (results: InteractionResults) => void;
  onOptionSelected?: (option: DialogueOptionView, stageId: string) => void;
  onStageChange?: (newStageId: string, prevStageId: string) => void;
  stateMachineEnabled?: boolean;
}

/**
 * Enhanced conversation format with Strategic Actions integration & Juice!
 */
export default function ConversationFormat({
  character,
  dialogueStages,
  dialogueId = `${character}-dialogue`,
  onComplete,
  onOptionSelected,
  onStageChange,
  stateMachineEnabled = false
}: ConversationFormatProps) {
  // Core game systems
  const { currentNodeId } = useGameStore();
  const {
    insight,
    momentum,
    activeAction,
    activateAction,
    completeAction,
    cancelAction,
    incrementMomentum,
    resetMomentum,
    updateInsight
  } = useResourceStore();
  // Local state
  const [playerScore, setPlayerScore] = useState(0);
  const [insightGained, setInsightGained] = useState(0);
  const [isInitialized, setIsInitialized] = useState(false);
  const [usedActions, setUsedActions] = useState<StrategicActionType[]>([]);
  const [consecutiveCorrect, setConsecutiveCorrect] = useState(0);
  // UI animation states
  const [showOptionFeedback, setShowOptionFeedback] = useState<'correct' | 'incorrect' | null>(null);
  const [feedbackMessage, setFeedbackMessage] = useState('');
  const [showInsightGain, setShowInsightGain] = useState(false);
  const [lastInsightGain, setLastInsightGain] = useState(0);
  // **NEW**: State for character reaction animation
  const [characterReaction, setCharacterReaction] = useState<'idle' | 'positive' | 'negative' | 'thinking'>('idle');
  // **NEW**: State for screen shake
  const [applyScreenShake, setApplyScreenShake] = useState(false);

  // Character data (memoized to prevent recreation)
  const charData = useMemo(() => getCharacterData(character), [character]);
  // Use dialogue flow hook
  const dialogueState = useDialogueFlow({
    characterId: character,
    nodeId: currentNodeId || undefined,
    dialogueId,
    stages: dialogueStages,
    onOptionSelected,
    onStageChange
  });
  // Extract values from the dialogue state with safe fallbacks
  const currentStage = 'currentStage' in dialogueState ?
  dialogueState.currentStage : {
    id: dialogueState.instanceId || 'loading',
    text: dialogueState.currentText || '',
    options: dialogueState.options || [],
    isConclusion: false,
    contextNote: ''
  };
  const currentStageId = 'currentStageId' in dialogueState ?
    dialogueState.currentStageId :
    (dialogueState.instanceId || currentStage?.id || 'loading');
  const showResponse = dialogueState.showResponse || false;
  const showBackstory = dialogueState.showBackstory || false;
  const backstoryText = dialogueState.backstoryText || '';

  // Local state specifically for selectedOption to use in useEffect dependency array
  const [currentSelectedOption, setCurrentSelectedOption] = useState<DialogueOptionView | null>(null);

  // Safe function references
  const handleOptionSelect = 'handleOptionSelect' in dialogueState ?
  dialogueState.handleOptionSelect :
    ((option: DialogueOptionView) => console.warn('handleOptionSelect not available'));

  const handleContinue = 'handleContinue' in dialogueState ?
  dialogueState.handleContinue :
    (() => console.warn('handleContinue not available'));

  const completeDialogue = 'completeDialogue' in dialogueState ?
  dialogueState.completeDialogue :
    (() => console.warn('completeDialogue not available'));
  // Set initialization flag when dialogue state is ready
  useEffect(() => {
    if (currentStage && 'text' in currentStage && !isInitialized) {
      setIsInitialized(true);
    }
  }, [currentStage, isInitialized]);

  // **CORRECTED**: Character reaction effect based on relationship change
  useEffect(() => {
    // Check if currentSelectedOption exists AND has relationshipChange defined
    if (currentSelectedOption && currentSelectedOption.relationshipChange !== undefined) {
      if (currentSelectedOption.relationshipChange > 0) {
        setCharacterReaction('positive');
      } else if (currentSelectedOption.relationshipChange < 0) {
        setCharacterReaction('negative');
      }
      // Reset after a short delay
      const timer = setTimeout(() => setCharacterReaction('idle'), 800);
      return () => clearTimeout(timer);
    }
    // If no selected option or no relationship change, ensure reaction is idle
    else {
        setCharacterReaction('idle');
    }
  }, [currentSelectedOption]); // Depend on the local state copy

  // **NEW**: Screen shake effect
  useEffect(() => {
    if (applyScreenShake) {
      const timer = setTimeout(() => setApplyScreenShake(false), 300); // Duration of shake
      return () => clearTimeout(timer);
    }
  }, [applyScreenShake]);


  // Function to determine if an option is "correct"
  const isOptionCorrect = (option: DialogueOptionView & {
    relationshipChange?: number;
    approach?: string;
  }) => {
    // Options that improve relationship are considered "correct"
    if (option.relationshipChange && option.relationshipChange > 0) {
      return true;
  }

    // "precision" and "humble" approaches are generally correct
    if (option.approach === 'precision' || option.approach === 'humble') {
      return true;
  }

    // Options with critical path are correct
    if (option.isCriticalPath) {
      return true;
  }

    // Default to neutral (not breaking momentum)
    return true;
  };

  // Handle option selection with resource integration
  const handleOptionSelectWrapper = (option: DialogueOptionView & {
    relationshipChange?: number;
    insightGain?: number;
    approach?: string;
  }) => {
    // **CORRECTION**: Update local state copy for useEffect
    setCurrentSelectedOption(option);

    // Determine if option was "correct" for momentum
    const correct = isOptionCorrect(option);
    // Calculate base insight gain
    let baseInsightGain = option.insightGain || 0;
    // Get any relationship change
    const relationshipChange = option.relationshipChange || 0;
    // Handle momentum changes
    if (correct) {
      // Increment consecutive counter
      setConsecutiveCorrect(prev => prev + 1);
      // Apply to global momentum
      incrementMomentum();
      // Prepare positive feedback
      setShowOptionFeedback('correct');
      setFeedbackMessage(getFeedbackMessage('correct', option.approach));
      // **NEW**: Positive character reaction (useEffect will handle this now)
  } else {
      // Reset momentum
      setConsecutiveCorrect(0);
      resetMomentum();
      // Prepare negative feedback
      setShowOptionFeedback('incorrect');
      setFeedbackMessage(getFeedbackMessage('incorrect', option.approach));
      // **NEW**: Negative character reaction & screen shake (useEffect will handle reaction)
      setApplyScreenShake(true);
  }

    // Apply insight gain with momentum bonus if any
    if (baseInsightGain > 0) {
      // Double insight if boast is active
      if (activeAction === 'boast') {
        baseInsightGain *= 2;
  }

      // Calculate momentum multiplier
      const momentumMultiplier = 1 + (momentum * 0.25);
      // 1.0, 1.25, 1.5, 1.75
      const totalInsight = Math.floor(baseInsightGain * momentumMultiplier);
      // Update global insight
      updateInsight(totalInsight);
      // Update local tracking
      setInsightGained(prev => prev + totalInsight);
      setLastInsightGain(totalInsight);
      setShowInsightGain(true);
      // Clear gain effect after animation
      setTimeout(() => setShowInsightGain(false), 2000);
  }

    // Update player score for relationship
    if (relationshipChange) {
      setPlayerScore(prev => prev + relationshipChange);
  }

    // If an action is active, complete it
    if (activeAction) {
      completeAction(activeAction, correct);
  }

    // Show feedback animation & reset character reaction
    const feedbackTimer = setTimeout(() => {
      setShowOptionFeedback(null);
      // Character reaction reset is now handled by useEffect
    }, 1200); // Slightly shorter feedback display

    // Forward to dialogue handler
    handleOptionSelect(option);
  };
  // Handle strategic action activation
  const handleActionActivate = (actionType: StrategicActionType) => {
    // Add to used actions list
    if (!usedActions.includes(actionType)) {
      setUsedActions(prev => [...prev, actionType]);
  }

    // Apply action to dialogue
    applyStrategicAction(actionType, character, currentStageId);
    setCharacterReaction('thinking'); // **NEW**: Character thinking pose
    setTimeout(() => setCharacterReaction('idle'), 1000);
  };
  // Handle strategic action completion
  const handleActionComplete = (actionType: StrategicActionType, successful: boolean) => {
    // Could add more logic here if needed
  };
  // Handle strategic action cancellation
  const handleActionCancel = (actionType: StrategicActionType) => {
    // Could add more logic here if needed
  };
  // Handle continue button
  const handleContinueWrapper = () => {
    // **CORRECTION**: Clear the selected option when continuing
    setCurrentSelectedOption(null);

    // Check if at conclusion
    if ((currentStage?.isConclusion && !showResponse) ||
        currentStageId === 'journal-presentation') {

      // Complete the dialogue and challenge
      finalizeChallenge();
  return;
    }

    // Forward to dialogue handler
    handleContinue();
  };
  // Finalize the challenge
  const finalizeChallenge = () => {
    // Determine journal tier
    const journalTier = playerScore >= 3 ?
  'annotated' :
                     playerScore >= 0 ?
  'technical' : 'base';

    // Call completion callback
    onComplete({
      insightGained,
      relationshipChange: playerScore,
      knowledgeGained: {},
      journalTier,
      actionsUsed: usedActions
    });
    // Complete state machine flow
    if (stateMachineEnabled) {
      completeDialogue();
    }
  };
  // Initialize typewriter for main text (with safe fallbacks)
  const {
    displayText: displayedText,
    isTyping,
    complete: skipTyping
  } = useTypewriter(currentStage?.text || '', { speed: 20 }); // Faster typing

  // Initialize typewriter for backstory (with safe fallbacks)
  const {
    displayText: displayedBackstoryText,
    isTyping: isTypingBackstory,
    complete: skipBackstoryTyping
  } = useTypewriter(backstoryText || '', { speed: 20 });
  // Enhance options based on active action
  const enhancedOptions = useMemo(() => {
    if (!currentStage?.options) return [];

    // Apply strategic action enhancements
    return enhanceDialogueOptions(currentStage.options, activeAction);
  }, [currentStage?.options, activeAction]);
  // Get a feedback message based on response type
  const getFeedbackMessage = (type: 'correct' | 'incorrect', approach?: string): string => {
    if (type === 'correct') {
      if (approach === 'precision') {
        return 'Your precise approach shows strong technical understanding.';
  } else if (approach === 'humble') {
        return 'Your thoughtful consideration demonstrates professional maturity.';
  } else if (approach === 'confidence') {
        return 'Your confident analysis is well-founded.';
  }
      return 'Good approach to the situation.';
  } else {
      if (approach === 'overconfidence') {
        return 'A more measured approach would be advisable in this context.';
  } else if (approach === 'imprecision') {
        return 'Greater attention to technical details would strengthen your response.';
  }
      return 'Consider a different perspective on this issue.';
    }
  };
  // Render the option for Boast when momentum is maxed
  const renderBoastOption = (option: DialogueOptionView & {
    approach?: string;
    insightGain?: number;
  }) => {
    // Check if option has the 'confidence' approach and momentum is maxed
    if (momentum === 3 && option.approach === 'confidence' && option.insightGain) {
      return (
        <div className="absolute -left-4 top-1/2 transform -translate-y-1/2 bg-orange-600 text-white px-2 py-1 rounded-l text-xs font-pixel">
          CHALLENGE

       </div>
      );
  }

    return null;
  };
  // Loading state while dialogue initializes
  if (!isInitialized) {
    return (
      <div className="p-6 max-w-4xl mx-auto bg-surface pixel-borders">
        <div className="bg-surface-dark p-4 pixel-borders-thin mb-4 min-h-[120px] flex items-center justify-center">
          <PixelText>Initializing dialogue...</PixelText>
        </div>
      </div>
    );
  }

  // Main conversation UI
  return (
    <div className={`p-6 max-w-4xl mx-auto bg-surface pixel-borders relative transition-transform duration-300 ${applyScreenShake ? 'animate-shake-subtle' : ''}`}>
      {/* Character header - Enhanced with more space */}
      <div className="flex justify-between items-start mb-8">
        <div className="flex items-start">
          {/* Character portrait with dedicated space & reaction animation */}
          <motion.div
            className="w-70 h-70 mr-6 relative pixel-borders"
            animate={characterReaction} // Bind animation state
            variants={{
              idle: { scale: 1, rotate: 0 },
              positive: { scale: 1.05, rotate: 2 },
              negative: { x: [-2, 2, -2, 2, 0] }, // Shake animation
              thinking: { scale: 0.98, opacity: 0.8 }
            }}
            transition={{ type: 'spring', stiffness: 300, damping: 10 }}
          >
        <div
              className="absolute inset-0 bg-cover bg-center"
              style={{
                backgroundImage: `url(${charData.sprite})`,
                imageRendering: 'pixelated'
              }}
            ></div>
         <div className={`absolute inset-0 ${charData.bgClass} opacity-20 mix-blend-overlay`}></div>
          </motion.div>

          {/* Character info - now with more space */}
          <div className="mt-4">
            <PixelText className={`text-2xl ${charData.textClass} pixel-glow mb-1`}>
              {charData.name}
   </PixelText>
            <PixelText className="text-lg text-text-secondary">
              {charData.title}
            </PixelText>
          </div>
        </div>

        {/* Empty spacer div to push things to sides */}
        <div className="flex-grow"></div>


        {/* Resource meters - now in header with more space and 200% larger */}
        <div className="flex flex-col gap-5 w-80">
          <InsightMeter size="lg" showValue={true} />
          <div className="flex items-center gap-4">
            <MomentumCounter
              level={momentum}

           consecutiveCorrect={consecutiveCorrect}
              showLabel={true}
            />

            {/* Conditional boast button when momentum is maxed */}
            {momentum === 3 && (
              <motion.div

             className="bg-orange-700 border-orange-800 border-2 w-12 h-12 flex items-center justify-center pixel-borders"
                whileHover={{ y: -2 }}
                whileTap={{ y: 1 }}
                animate={{
                  scale: [1, 1.05, 1],

                 transition: { repeat: Infinity, duration: 1.5 }
                }}
              >
                <PixelText className="text-xs text-white">CHAL</PixelText>
              </motion.div>
            )}
          </div>

       </div>
      </div>

      {/* Strategic actions panel - moved to below the character header */}
      <div className="flex justify-center mb-6">
        <StrategicActionsContainer
          characterId={character}
          stageId={currentStageId}
          onActionActivate={handleActionActivate}
          onActionComplete={handleActionComplete}

     onActionCancel={handleActionCancel}
        />
      </div>

      {/* Dialogue area */}
      <div className="bg-surface-dark p-5 pixel-borders mb-5 min-h-[150px] relative">
        {/* Feedback overlay for correct/incorrect answers */}
        <AnimatePresence>
          {showOptionFeedback && (
            <motion.div

           className={`absolute inset-0 pointer-events-none z-10 ${
                showOptionFeedback === 'correct'
                  ?
  'bg-green-500/10 border border-green-500/30 feedback-correct-border' // **NEW** Class for CSS animation
                  : 'bg-red-500/10 border border-red-500/30 feedback-incorrect-border' // **NEW** Class for CSS animation
              }`}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}

    >
              <motion.div
                className={`absolute top-2 right-2 px-2 py-1 text-xs font-pixel ${
                  showOptionFeedback === 'correct' ?
  'bg-green-700 text-green-100' : 'bg-red-700 text-red-100'
                }`}
                initial={{ x: 20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                exit={{ x: 20, opacity: 0 }}
              >

                 {showOptionFeedback === 'correct' ?
  'Effective Approach' : 'Suboptimal Approach'}
              </motion.div>

              {/* Feedback message */}
              {feedbackMessage && (
                <motion.div
                  className={`absolute

   bottom-2 left-2 right-2 px-3 py-2 text-sm font-pixel ${
                    showOptionFeedback === 'correct' ? 'bg-green-900/70 text-green-100' : 'bg-red-900/70 text-red-100'
                  }`}
                  initial={{ y: 20, opacity: 0 }}
                  animate={{ y: 0, opacity: 1, transition:

  { delay: 0.2 } }}
                  exit={{ y: 20, opacity: 0 }}
                >
                  {feedbackMessage}
                </motion.div>
              )}

              {/* **NEW**: Particle burst effect on correct */}
              {showOptionFeedback === 'correct' && <div className="particle-burst-correct"></div>}

         </motion.div>
          )}
        </AnimatePresence>

        {/* Insight gain animation */}
        <AnimatePresence>
          {showInsightGain && lastInsightGain > 0 && (
            <motion.div
              className="absolute top-0 right-0 mt-2 mr-2 z-20 pointer-events-none"

             initial={{ y: -20, opacity: 0, scale: 0.5 }} // Added scale
              animate={{ y: 0, opacity: 1, scale: 1 }} // Added scale
              exit={{ y: 20, opacity: 0, scale: 0.5 }} // Added scale
            >
              <div className="flex items-center bg-blue-900/80 px-3 py-1 rounded shadow-lg">

           <span className="text-blue-300 font-pixel text-sm mr-1 animate-pulse-fast">+</span> {/* Added animation */}
                <span className="text-blue-200 font-pixel text-sm">{lastInsightGain}</span>
                <span className="text-blue-300 font-pixel text-sm ml-1">Insight</span>
              </div>
            </motion.div>
          )}
        </AnimatePresence>


         {/* Show backstory or main content */}
        {showBackstory ?
  (
          <PixelText className="italic text-xl leading-relaxed">
            {displayedBackstoryText}{isTypingBackstory ? '|' : ''}
          </PixelText>
        ) : (
          <div>
            <PixelText className="text-xl leading-relaxed">
              {displayedText}{isTyping ? '|' : ''}

         </PixelText>

            {/* Context note */}
            {!isTyping && currentStage?.contextNote && (
              <div className="mt-4 pt-2 border-t border-border">
                <PixelText className="text-text-secondary text-sm italic">

                 {currentStage.contextNote}
                </PixelText>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Options or continue button */}
      {showResponse ||
  showBackstory ? (
        <PixelButton
          className={`float-right ${charData.bgClass} text-white hover:opacity-90`}
          onClick={() => { skipTyping(); skipBackstoryTyping(); handleContinueWrapper(); }} // Allow skipping typewriters
        >
          {(isTyping || isTypingBackstory) ? "Skip »" : "Continue →"}
        </PixelButton>
      ) : (
        enhancedOptions && enhancedOptions.length > 0 ? (
          <div className="space-y-3">

           {enhancedOptions.map((option: any, index: number) => ( // Added index
              <motion.button
                key={option.id}
                className={`w-full text-left p-4 bg-surface hover:bg-surface-dark pixel-borders relative
                  ${activeAction === 'boast' ? 'border-orange-500/50' : ''}

                 ${activeAction === 'reframe' ? 'border-blue-500/50' : ''}
                `}
                onClick={() => handleOptionSelectWrapper(option)}
                disabled={isTyping}
                initial={{ opacity: 0, y: 10 }} // **NEW** Animate options in
                animate={{ opacity: 1, y: 0, transition: { delay: index * 0.05 } }} // **NEW** Staggered animation
                whileHover={{ x: 3 }}
                whileTap={{ scale:

   0.99 }}
              >
                {/* Render boast badge if applicable */}
                {renderBoastOption(option)}

                <div className="flex justify-between">

             <PixelText className="text-base">{option.text}</PixelText>

                  {/* Show insight preview */}
                  {option.insightGain && option.insightGain > 0 && (
                    <motion.span


                     className={`ml-2 text-xs ${
                        activeAction === 'boast'
                          ?
  'bg-orange-600 text-white'
                          : 'bg-blue-600 text-white'
                      } px-2 py-1 rounded-sm`}
                      animate={activeAction === 'boast' ?
  { scale: [1, 1.1, 1], transition: { repeat: Infinity, duration: 1.5 } } : {}}
                    >
                      {activeAction === 'boast' ?
  `+${option.insightGain * 2}` : `+${option.insightGain}`}
                    </motion.span>
                  )}

                  {/* Special indicators for strategic options */}

             {activeAction === 'reframe' && (option.approach === 'humble' || option.approach === 'precision') && (
                    <span className="absolute top-1 right-1 w-2 h-2 bg-blue-500 rounded-full"></span>
                  )}

                  {activeAction === 'boast' && (option.approach

   === 'confidence' || option.approach === 'precision') && (
                    <span className="absolute top-1 right-1 w-2 h-2 bg-orange-500 rounded-full"></span>
                  )}
                </div>


                 {/* Approach indicator - visually show player what type of response this is */}
                {option.approach && (
                  <div className="mt-2 text-sm">
                    {option.approach === 'humble' && (
                      <span className="text-blue-400">Humble approach</span>

                    )}
                    {option.approach === 'precision' && (
                      <span className="text-green-400">Precise approach</span>
                    )}

               {option.approach === 'confidence' && (
                      <span className="text-orange-400">Confident approach</span>
                    )}
                  </div>
                )}

           </motion.button>
            ))}
          </div>
        ) : (
          <PixelButton
            className={`float-right ${charData.bgClass} text-white hover:opacity-90`}
            onClick={handleContinueWrapper}
          >
            {isTyping ?
  "Skip »" : "Continue →"}
          </PixelButton>
        )
      )}

      {/* Debug info */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="mt-12 pt-4 border-t border-gray-700 text-xs opacity-50">
          <div>State Machine: {stateMachineEnabled ? 'Yes' : 'No'}</div>
          <div>Current Stage: {currentStageId}</div>

         <div>Player Score: {playerScore}</div>
          <div>Insight: {insight} (Gained: {insightGained})</div>
          <div>Momentum: {momentum} (Consecutive: {consecutiveCorrect})</div>
          <div>Active Action: {activeAction || 'None'}</div>
          <div>Used Actions: {usedActions.join(', ')}</div>
        </div>
      )}
    </div>
  );
 }

// Helper function for character data
function getCharacterData(characterId: string): CharacterData {
  const characterData: Record<string, CharacterData> = {
    'kapoor': {
      name: "Dr. Kapoor",
      title: "Chief Medical Physicist",
      sprite: "/characters/kapoor.png",
      primaryColor: "var(--clinical-color)",
      textClass: "text-clinical-light",
      bgClass: "bg-clinical"
    },
    'jesse': {
      name: "Technician Jesse",
      title: "Equipment Specialist",
      sprite: "/characters/jesse.png",

      primaryColor: "var(--qa-color)",
      textClass: "text-qa-light",
      bgClass: "bg-qa"
    },
    'quinn': {
      name: "Dr. Zephyr Quinn",
      title: "Experimental Researcher",
      sprite: "/characters/quinn.png",
      primaryColor: "var(--educational-color)",
      textClass: "text-educational-light",
      bgClass: "bg-educational"
    },
    'garcia': {
      name: "Dr. Garcia",
      title:
  "Radiation Oncologist",
      sprite: "/characters/garcia.png",
      primaryColor: "var(--clinical-alt-color)",
      textClass: "text-clinical-light",
      bgClass: "bg-clinical"
    }
  };
 return characterData[characterId] || characterData.kapoor;
}
==== END: app/components/challenges/formats/ConversationFormat.tsx ====

==== START: app/components/DayNightTransition.tsx ====
// components/DayNightTransition.tsx
// This creates the magical transition between day and night phases
import React, { useEffect, useState } from 'react';
import { useGameStore } from '../store/gameStore';
import { GameEventType } from '../core/events/EventTypes';
import { safeEventDispatch } from '../core/events/CentralEventBus';

const DayNightTransition: React.FC = () => {
  const { currentState, setGameState } = useGameStore();
  const [transitionState, setTransitionState] = useState<'idle' | 'fadeOut' | 'elevate' | 'stars' | 'fadeIn'>('idle');
  const [showStars, setShowStars] = useState(false);
  const [showHillhouse, setShowHillhouse] = useState(false);
  
  // Trigger the transition sequence
  useEffect(() => {
    if (currentState === 'transitioning-to-night') {
      // Start the transition sequence
      startTransition();
    }
  }, [currentState]);
  
  const startTransition = () => {
    // Log the start of transition
    safeEventDispatch(
      GameEventType.GAME_STATE_CHANGED,
      { from: 'day', to: 'transitioning' }
    );
    
    // Begin the transition sequence
    setTransitionState('fadeOut');
    
    // Schedule the sequence of transition states
    setTimeout(() => setTransitionState('elevate'), 2000);
    setTimeout(() => setTransitionState('stars'), 4000);
    setTimeout(() => {
      setShowStars(true);
      // Start subtle star twinkle animations
      document.querySelectorAll('.star').forEach(star => {
        star.classList.add('animate-twinkle');
      });
    }, 4500);
    setTimeout(() => setShowHillhouse(true), 5500);
    setTimeout(() => setTransitionState('fadeIn'), 6500);
    
    // Complete the transition
    setTimeout(() => {
      setGameState('night');
      safeEventDispatch(
        GameEventType.NIGHT_PHASE_STARTED,
        { location: 'hillHome' }
      );
    }, 8000);
  };
  
  // Early return if not in transition
  if (currentState !== 'transitioning-to-night') {
    return null;
  }
  
  return (
    <div className={`fixed inset-0 z-50 transition-opacity duration-2000 
                    ${transitionState === 'fadeOut' ? 'bg-black' : 
                     transitionState === 'fadeIn' ? 'opacity-0' : 'bg-black'}`}>
      
      {/* Hospital fading away */}
      <div className={`absolute inset-0 bg-hospital-bg bg-cover bg-center 
                      transition-opacity duration-2000
                      ${transitionState === 'idle' ? 'opacity-100' : 'opacity-0'}`} />
      
      {/* Elevation effect - moving upward */}
      <div className={`absolute inset-0 flex items-center justify-center
                      transition-transform duration-3000
                      ${transitionState === 'elevate' || transitionState === 'stars' ? 
                        'translate-y-[-30vh]' : 'translate-y-0'}`}>
        
        {/* Star field appears */}
        {showStars && (
          <>
            {/* Generate 100 random stars */}
            {Array.from({ length: 100 }).map((_, i) => {
              const size = Math.random() * 3 + 1;
              const left = Math.random() * 100;
              const top = Math.random() * 100;
              const delay = Math.random() * 2;
              const duration = 2 + Math.random() * 3;
              
              return (
                <div
                  key={i}
                  className="star absolute rounded-full bg-white"
                  style={{
                    width: `${size}px`,
                    height: `${size}px`,
                    left: `${left}%`,
                    top: `${top}%`,
                    opacity: Math.random() * 0.5 + 0.3,
                    animationDelay: `${delay}s`,
                    animationDuration: `${duration}s`
                  }}
                />
              );
            })}
          </>
        )}
        
        {/* Hill home appears */}
        {showHillhouse && (
          <div className="absolute bottom-0 left-0 right-0 h-[40vh]">
            <div className="relative w-full h-full">
              {/* Hill silhouette */}
              <div className="absolute bottom-0 left-0 right-0 h-[60%] bg-[#0a1828] rounded-tl-[50%] rounded-tr-[40%]" />
              
              {/* Home silhouette */}
              <div className="absolute bottom-[20%] left-[50%] translate-x-[-50%] w-[100px] h-[80px]">
                <div className="absolute bottom-0 w-full h-[60%] bg-[#162a3a]" />
                <div className="absolute bottom-[60%] left-[50%] translate-x-[-50%] w-[70%] h-[40%] bg-[#162a3a]"
                     style={{ clipPath: 'polygon(0 100%, 50% 0, 100% 100%)' }} />
                
                {/* Window with warm light */}
                <div className="absolute bottom-[30%] left-[50%] translate-x-[-50%] w-[20px] h-[20px] bg-[#ffb84d] opacity-80 rounded-sm" />
              </div>
            </div>
          </div>
        )}
      </div>
      
      {/* Narrative text */}
      <div className={`absolute inset-0 flex items-center justify-center 
                      transition-opacity duration-1000
                      ${transitionState === 'stars' ? 'opacity-100' : 'opacity-0'}`}>
        <p className="text-white text-xl font-light tracking-wide">
          You return to your hill home as night falls...
        </p>
      </div>
    </div>
  );
};

export default DayNightTransition;

// Add this to your CSS (tailwind.css)
/*
@keyframes twinkle {
  0% { opacity: var(--base-opacity); }
  50% { opacity: 1; }
  100% { opacity: var(--base-opacity); }
}

.animate-twinkle {
  animation: twinkle var(--duration, 3s) ease-in-out infinite;
  --base-opacity: 0.6;
}
*/
==== END: app/components/DayNightTransition.tsx ====

==== START: app/layout.tsx ====
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import PixelThemeProvider from "./components/PixelThemeProvider";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
  display: "swap", // Use display swap to prevent FOUT
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
  display: "swap", // Use display swap to prevent FOUT
});

export const metadata: Metadata = {
  title: "Rogue Resident: Medical Physics Residency",
  description: "An educational roguelike game about medical physics",
};

// Static font preloading in the document head
function FontPreloader() {
  return (
    <>
      {/* Font Preloading */}
      <link 
        rel="preload" 
        href="https://fonts.googleapis.com/css2?family=VT323&display=swap" 
        as="style"
        crossOrigin="anonymous"
      />
      <link 
        rel="preload" 
        href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" 
        as="style"
        crossOrigin="anonymous"
      />
      {/* Also preload the actual font files */}
      <link 
        rel="preload" 
        href="https://fonts.gstatic.com/s/vt323/v17/pxiKyp0ihIEF2isfFJU.woff2" 
        as="font"
        type="font/woff2"
        crossOrigin="anonymous"
      />
      <link 
        rel="preload" 
        href="https://fonts.gstatic.com/s/pressstart2p/v15/e3t4euO8T-267oIAQAu6jDQyK3nVivM.woff2" 
        as="font"
        type="font/woff2"
        crossOrigin="anonymous"
      />
      {/* Add stylesheet links to ensure they load immediately */}
      <link 
        rel="stylesheet" 
        href="https://fonts.googleapis.com/css2?family=VT323&display=swap" 
      />
      <link 
        rel="stylesheet" 
        href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" 
      />
    </>
  );
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // Determine if we're in development mode
  const isDevelopment = process.env.NODE_ENV !== 'production';
  
  return (
    <html lang="en">
      <head>
        <FontPreloader />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <PixelThemeProvider>
          {/* Note: Systems initialization happens in the page component */}
          {children}
        </PixelThemeProvider>
      </body>
    </html>
  );
}
==== END: app/layout.tsx ====

